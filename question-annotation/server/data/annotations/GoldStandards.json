{
  "questions": [
    {
      "id": "3",
      "title": "Überladene Methode",
      "text": "Was ist eine überladene Methode?",
      "type": "definition",
      "aspects": [
        {
          "text": "Methoden einer Klasse"
        },
        {
          "text": "mit demselben Namen"
        },
        {
          "text": "Die Signaturen der Methoden unterscheiden sich anhand unterschiedlicher Parameter"
        }
      ],
      "referenceAnswers": [
        {
          "id": "ref1",
          "text": "Das sind Methoden einer Klasse mit denselben Namen. Ihre Signaturen unterscheiden sich anhand unterschiedlicher Parameter.",
          "aspects": [
            {
              "text": "Das sind Methoden einer Klasse",
              "aIdx": 0,
              "elements": [
                [
                  0,
                  30
                ]
              ],
              "label": 0
            },
            {
              "text": "Das sind Methoden ;; mit demselben Namen",
              "aIdx": 1,
              "elements": [
                [
                  0,
                  17
                ],
                [
                  31,
                  50
                ]
              ],
              "label": 0
            },
            {
              "text": "Ihre Signaturen unterscheiden sich anhand unterschiedlicher Parameter",
              "aIdx": 2,
              "elements": [
                [
                  52,
                  121
                ]
              ],
              "label": 0
            }
          ]
        }
      ],
      "studentAnswers": [
        {
          "text": "Das sind Methoden mit denselben Namen aber unterschiedliche Signatur. Zum Beispiel: public double berechneZeitInStunden(int minuten){.....} public double berechneZeitInStunden(int sekunden){....} Rückgabewert ist egal. Hat den Vorteil das es Benutzerfreundlicher ist.",
          "id": "1",
          "answerCategory": "correct",
          "correctionOrComment": "Das sind Methoden mit denselben Namen aber unterschiedlicher Signatur. Der Rückgabewert ist egal. Es hat den Vorteil, dass es benutzerfreundlicher ist.",
          "aspects": [
            {
              "text": "Das sind Methoden mit denselben Namen",
              "elements": [
                [
                  0,
                  37
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "Das sind Methoden ;;  unterschiedlicher Signatur",
              "elements": [
                [
                  0,
                  17
                ],
                [
                  43,
                  69
                ]
              ],
              "aIdx": 2,
              "label": 1
            }
          ]
        },
        {
          "text": "eine überladene Methode ist, wenn man mehrere Konstruktoren mit unterschiedlichen Parametern definiert.",
          "id": "2",
          "answerCategory": "missconception",
          "correctionOrComment": "Eine Methode ist überladen, wenn man mehrere Konstruktoren mit unterschiedlichen Parametern definiert.",
          "aspects": []
        },
        {
          "text": "eine überladene Methode wurde mehr als einmal in einer Klasse implementiert, jedoch müssen die Parameter-Übergaben verschieden einzigartig sein, der rückgabetype kann \"\"belibig sein\"\" der methoden-name muss gleich sein. Ein Beispiel: public class Test { public int getOutput() { return 0; } //überladene Methode public int getOutput(int mode){ return 0; } //auch überladen public String getOutput(int mode, String prefix){ return prefix+mode; } }",
          "id": "3",
          "answerCategory": "correct",
          "correctionOrComment": "Eine überladene Methode wurde mehr als einmal in einer Klasse implementiert, jedoch müssen die Parameterübergaben verschieden einzigartig sein. Der Rückgabetype kann belibig sein. Der Methodenname muss gleich sein.",
          "aspects": [
            {
              "text": "Eine überladene Methode wurde mehr als einmal in einer Klasse implementiert",
              "elements": [
                [
                  0,
                  75
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Der Methodenname muss gleich sein",
              "elements": [
                [
                  180,
                  213
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "jedoch müssen die Parameterübergaben verschieden einzigartig sein",
              "elements": [
                [
                  77,
                  142
                ]
              ],
              "aIdx": 2,
              "label": 0
            }
          ]
        },
        {
          "text": "-",
          "id": "4",
          "answerCategory": "none",
          "correctionOrComment": "-",
          "aspects": []
        },
        {
          "text": "Man überlädt eine Methode damit der Rückgabe wert eine schöne lesbare Zahl ist und nicht irgendein code den man nicht entziffern kann.",
          "id": "5",
          "answerCategory": "guessing",
          "correctionOrComment": "Man überlädt eine Methode, damit der Rückgabewert eine schöne, lesbare Zahl ist und nicht irgendein Code, den man nicht entziffern kann.",
          "aspects": []
        },
        {
          "text": "eine methode die die auf alle objekte zugreift",
          "id": "6",
          "answerCategory": "guessing",
          "correctionOrComment": "Das ist eine Methode, die auf alle Objekte zugreift.",
          "aspects": []
        },
        {
          "text": "eine Methode aus die von mehreren klassen benutzt wird und somit immer wieder überschrieben wird",
          "id": "7",
          "answerCategory": "guessing",
          "correctionOrComment": "Das ist eine Methode, die von mehreren Klassen benutzt wird und somit immer wieder überschrieben wird.",
          "aspects": []
        },
        {
          "text": "es ist eine methode die false ausgibt",
          "id": "8",
          "answerCategory": "guessing",
          "correctionOrComment": "Es ist eine Methode, die 'false' ausgibt.",
          "aspects": []
        },
        {
          "text": "Eine Methode, die in der Basisklasse sowie in abgeleiteten Klassen gleichnamig auftritt und unterschiedliche Rückgabewerte liefert.",
          "id": "9",
          "answerCategory": "concept_mix-up",
          "correctionOrComment": "Das ist eine Methode, die in der Basisklasse sowie in abgeleiteten Klassen gleichnamig auftritt und unterschiedliche Rückgabewerte liefert.",
          "aspects": []
        },
        {
          "text": "Zwei Methoden mit dem selben namen bezeichnet man als Überladen. Deshalb müssen sie sich immer in der Signatur (Parameterliste, Typen) unterscheiden.",
          "id": "10",
          "answerCategory": "correct",
          "correctionOrComment": "Zwei Methoden mit dem selben Namen bezeichnet man als überladen. Deshalb müssen sie sich immer in der Signatur (Parameterliste, Typen) unterscheiden.",
          "aspects": [
            {
              "text": "Zwei Methoden mit dem selben Namen bezeichnet man als überladen",
              "elements": [
                [
                  0,
                  63
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "Deshalb müssen sie sich immer in der Signatur (Parameterliste, Typen) unterscheiden",
              "elements": [
                [
                  65,
                  148
                ]
              ],
              "aIdx": 2,
              "label": 0
            }
          ]
        },
        {
          "text": "Wenn der Speicher der Methoden nicht ausreicht.",
          "id": "11",
          "answerCategory": "guessing",
          "correctionOrComment": "Wenn der Speicher der Methoden nicht ausreicht, sind sie überladen.",
          "aspects": []
        },
        {
          "text": "die mit parametern überladen ist",
          "id": "12",
          "answerCategory": "guessing",
          "correctionOrComment": "Das ist ein Methode, die mit Parametern überladen ist.",
          "aspects": []
        },
        {
          "text": "wenn zuviele variablen deklariert sind, aber nicht alles benutzt werden",
          "id": "13",
          "answerCategory": "guessing",
          "correctionOrComment": "Das ist, wenn zu viele Variablen deklariert sind, aber nicht alle benutzt werden.",
          "aspects": []
        },
        {
          "text": "heist, das sich signatur, Parameterzahl bzw. die typen sich unterscheiden.",
          "id": "14",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Es bedeutet, dass die Signatur und Parameterzahl (bzw. die Typen) sich unterscheiden.",
          "aspects": [
            {
              "text": "Es bedeutet, dass die Signatur und Parameterzahl (bzw. die Typen) sich unterscheiden",
              "elements": [
                [
                  0,
                  84
                ]
              ],
              "aIdx": 2,
              "label": 1
            }
          ]
        },
        {
          "text": "-",
          "id": "15",
          "answerCategory": "none",
          "correctionOrComment": "-",
          "aspects": []
        },
        {
          "text": "-",
          "id": "16",
          "answerCategory": "none",
          "correctionOrComment": "-",
          "aspects": []
        },
        {
          "text": "eine überladene Methode hat denselben Namen wie eine andere Methode, jedoch andere Parameter. Z.B. bei Konstruktoren: Klasse(){} Klasse(Obj o){} Klasse(Person p, int alter){} durch die Überladung kann sich der \"\"User\"\" aussuchen, welche Methode er nutzen will (z.B. Klasse k = new Klasse(); oder Klasse k2 = new Klasse(anton);",
          "id": "17",
          "answerCategory": "correct",
          "correctionOrComment": "Eine überladene Methode hat denselben Namen wie eine andere Methode, jedoch andere Parameter. Durch die Überladung kann sich der 'User' aussuchen, welche Methode er nutzen will.",
          "aspects": [
            {
              "text": "Eine überladene Methode hat denselben Namen wie eine andere Methode",
              "elements": [
                [
                  0,
                  67
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "jedoch andere Parameter",
              "elements": [
                [
                  69,
                  92
                ]
              ],
              "aIdx": 2,
              "label": 0
            }
          ]
        },
        {
          "text": "Eine Methode die zu viele Methoden implementiert hat und unübersichtlich ist.",
          "id": "18",
          "answerCategory": "guessing",
          "correctionOrComment": "Das ist eine Methode, die zu viele Methoden implementiert hat und unübersichtlich ist.",
          "aspects": []
        },
        {
          "text": "Eine überladene Methode ist wenn 2 Methoen den selben namen haben, sie müsen sich durch Parammeter-leiste und Signatur unerscheiden",
          "id": "19",
          "answerCategory": "binary_correct",
          "correctionOrComment": "Eine Methode ist überladen, wenn 2 Methoden den selben Namen haben. Sie müssen sich durch Parameterliste und Signatur unerscheiden.",
          "aspects": [
            {
              "text": "Eine Methode ist überladen, wenn 2 Methoden den selben Namen haben",
              "elements": [
                [
                  0,
                  66
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "Sie müssen sich durch Parameterliste und Signatur unerscheiden",
              "elements": [
                [
                  68,
                  130
                ]
              ],
              "aIdx": 2,
              "label": 1
            }
          ]
        },
        {
          "text": "Eine überladene Methode ist eine definierte Methode, die durch eine neue Implementation der selben Methode eine neue Bedeutung bekommt. z.B. die vom Object definierte Methode toString(). Wird sie in einer Klasse neu geschrieben gilt sie als überladen.",
          "id": "20",
          "answerCategory": "concept_mix-up",
          "correctionOrComment": "Eine überladene Methode ist eine definierte Methode, die durch eine neue Implementation derselben Methode eine neue Bedeutung bekommt. Wird sie in einer Klasse neu geschrieben gilt sie als überladen.",
          "aspects": []
        },
        {
          "text": "Eine überladene Methode ist eine Methode die sowohl in der Basisklasse als auch in der abgeleitenden Klasse initialisiert wird, dies bedeutet die Methode wird 2 x mit dem gleichen namen initialisiert kann aber einen anderen Inhalt besitzen. Man erkennt erst welche Methode man benutzt beim auslesen.",
          "id": "21",
          "answerCategory": "concept_mix-up",
          "correctionOrComment": "Eine überladene Methode ist eine Methode, die sowohl in der Basisklasse als auch in der abgeleitenden Klasse initialisiert wird. Dies bedeutet, die Methode wird 2 mal mit dem gleichen Namen initialisiert, kann aber einen anderen Inhalt besitzen. Man erkennt erst beim Auslesen, welche Methode man benutzt.",
          "aspects": [
            {
              "text": "Eine überladene Methode ist eine Methode, die sowohl in der Basisklasse als auch in der abgeleitenden Klasse initialisiert wird",
              "elements": [
                [
                  0,
                  127
                ]
              ],
              "aIdx": 0,
              "label": 2
            },
            {
              "text": "Dies bedeutet, die Methode wird 2 mal mit dem gleichen Namen initialisiert",
              "elements": [
                [
                  129,
                  203
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Eine überladene Methode ist eine Methoe die eine Methode mit dem selben Namen an der momentanen Stelle ändert allerdings nicht die Methode mit dem selben Namen an der ursprünglichen Stelle.",
          "id": "22",
          "answerCategory": "concept_mix-up",
          "correctionOrComment": "Eine überladene Methode ist eine Methode, die eine Methode mit demselben Namen an der momentanen Stelle ändert, allerdings nicht die Methode mit dem selben Namen an der ursprünglichen Stelle.",
          "aspects": []
        },
        {
          "text": "Wenn eine Methode sehr häufig wiederholt geschrieben wird.",
          "id": "23",
          "answerCategory": "guessing",
          "correctionOrComment": "Das ist, wenn eine Methode sehr häufig wiederholt geschrieben wird.",
          "aspects": []
        },
        {
          "text": "wenn 2 methoden den selben Namen haben sind sie überladen. die methoden müssen sich jedoch durch die Parameter, typ undsignatur unterscheiden um zu funktionieren.",
          "id": "24",
          "answerCategory": "correct",
          "correctionOrComment": "Wenn 2 Methoden denselben Namen haben, sind sie überladen. Die Methoden müssen sich jedoch durch die Parameter (Typ und Signatur) unterscheiden um zu funktionieren.",
          "aspects": [
            {
              "text": "Wenn 2 Methoden denselben Namen haben, sind sie überladen",
              "elements": [
                [
                  0,
                  57
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "Die Methoden müssen sich jedoch durch die Parameter (Typ und Signatur) unterscheiden um zu funktionieren",
              "elements": [
                [
                  59,
                  163
                ]
              ],
              "aIdx": 2,
              "label": 1
            }
          ]
        },
        {
          "text": "Eine Methode die einen zu großen Wert aufnehmen muss für den sie nicht festgelegt ist.",
          "id": "25",
          "answerCategory": "guessing",
          "correctionOrComment": "Das ist eine Methode, die einen zu großen Wert aufnehmen muss, für den sie nicht festgelegt ist.",
          "aspects": []
        },
        {
          "text": "Wenn zwei Methoden den selben Namen haben, aber unterschiedliche Parameter",
          "id": "26",
          "answerCategory": "correct",
          "correctionOrComment": "Das ist, wenn zwei Methoden denselben Namen haben, aber unterschiedliche Parameter.",
          "aspects": [
            {
              "text": "Das ist, wenn zwei Methoden denselben Namen haben",
              "elements": [
                [
                  0,
                  49
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "zwei Methoden ;; haben, aber unterschiedliche Parameter",
              "elements": [
                [
                  14,
                  27
                ],
                [
                  44,
                  82
                ]
              ],
              "aIdx": 2,
              "label": 0
            }
          ]
        },
        {
          "text": "Eine überladene Methode ist eine Methode, der beim Aufruf Parameter übergeben werden.",
          "id": "27",
          "answerCategory": "guessing",
          "correctionOrComment": "Eine überladene Methode ist eine Methode, der beim Aufruf Parameter übergeben werden.",
          "aspects": []
        },
        {
          "text": "Eine uberladene methode ist eine Methode, die den Name von eine bereits existierende methode trägt",
          "id": "28",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Eine überladene Methode ist eine Methode, die den Name von einer bereits existierenden Methode trägt.",
          "aspects": [
            {
              "text": "Eine überladene Methode ist eine Methode, die den Name von einer bereits existierenden Methode trägt",
              "elements": [
                [
                  0,
                  100
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Eine überladene Methode ist wenn man z.B. eine abgeleitete Klasse einer Basisklasse hat, diese Methode der Basisklasse aber nicht für die Ableitung \"\"passt\"\", kann man eine weitere Methode schreiben, oder mehrere wenn man möchte!",
          "id": "29",
          "answerCategory": "concept_mix-up",
          "correctionOrComment": "Eine Methode ist überladen, wenn man beispielsweise eine abgeleitete Klasse einer Basisklasse hat. Wenn eine Methode der Basisklasse nicht für die Ableitung passt, kann man eine oder mehrere weitere Methode schreiben, wenn man möchte!",
          "aspects": []
        },
        {
          "text": "to string methode",
          "id": "30",
          "answerCategory": "none",
          "correctionOrComment": "to string methode",
          "aspects": []
        },
        {
          "text": "eine überladene Methode ist eine Methode die in einer anderen Klasse überschriben werden kann.",
          "id": "31",
          "answerCategory": "concept_mix-up",
          "correctionOrComment": "Eine überladene Methode ist eine Methode, die in einer anderen Klasse überschrieben werden kann.",
          "aspects": []
        },
        {
          "text": "Ein Methode, die es mehrmals gibt.(Gleicher Name)",
          "id": "32",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Ein Methode, die es mehrmals gibt (gleicher Name).",
          "aspects": [
            {
              "text": "Ein Methode, die es mehrmals gibt (gleicher Name)",
              "elements": [
                [
                  0,
                  49
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "eine Methode wo der Standart Konstruktur durch einen/mehrere eigenen Konstruktor ersetzt wurde",
          "id": "33",
          "answerCategory": "concept_mix-up",
          "correctionOrComment": "Das ist eine Methode, in der der Standartkonstruktur durch einen oder mehrere eigene Konstruktoren ersetzt wurde.",
          "aspects": []
        },
        {
          "text": "Eine Methode, die mehrmals verwende/aufgerufen wird, mit jeweils anderem Inhalt.",
          "id": "34",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Das ist eine Methode, die mehrmals verwendet oder aufgerufen wird, mit jeweils anderem Inhalt.",
          "aspects": []
        },
        {
          "text": "Überladene methoden sind zwei verschiedene methoden,, die aber mit verschiedenen Parameter und Typen defineirt sind. (2 verschiedene Methoden, aber verschiedene Parameter und Typen)",
          "id": "35",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Überladene Methoden sind zwei verschiedene Methoden, die aber mit verschiedenen Parametern und Typen definiert sind.",
          "aspects": [
            {
              "text": "Überladene Methoden sind ;; aber mit verschiedenen Parametern und Typen definiert sind",
              "elements": [
                [
                  0,
                  24
                ],
                [
                  57,
                  115
                ]
              ],
              "aIdx": 2,
              "label": 0
            }
          ]
        },
        {
          "text": "Wenn zwei verschiedene Methoden den selben Namen haben, heißen sie überladen. Sie müssen sich durch Parameterliste und - Typen) unterscheiden.",
          "id": "36",
          "answerCategory": "correct",
          "correctionOrComment": "Wenn zwei verschiedene Methoden den selben Namen haben, heißen sie überladen. Sie müssen sich durch die Parameterliste und -typen unterscheiden.",
          "aspects": [
            {
              "text": "Wenn zwei verschiedene Methoden den selben Namen haben, heißen sie überladen",
              "elements": [
                [
                  0,
                  76
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "Sie müssen sich durch die Parameterliste und -typen unterscheiden",
              "elements": [
                [
                  78,
                  143
                ]
              ],
              "aIdx": 2,
              "label": 0
            }
          ]
        },
        {
          "text": "das die selbe Methode mehrfach in einer Klasse funktioniert, nur wenn die Parameterliste (Typen) sich unterscheiden.",
          "id": "37",
          "answerCategory": "binary_correct",
          "correctionOrComment": "Es bedeutet, dass dieselbe Methode nur dann mehrfach in einer Klasse funktioniert, wenn die Parameterliste und -typen sich unterscheiden.",
          "aspects": [
            {
              "text": "Es bedeutet, dass dieselbe Methode nur dann mehrfach in einer Klasse funktioniert",
              "elements": [
                [
                  0,
                  81
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "wenn die Parameterliste und -typen sich unterscheiden",
              "elements": [
                [
                  83,
                  136
                ]
              ],
              "aIdx": 2,
              "label": 0
            }
          ]
        },
        {
          "text": "Eine überladene Methode ist eine bereits vorhandene Methode die vom Ersteller an das aktuelle Projekt angepasst wird.",
          "id": "38",
          "answerCategory": "concept_mix-up",
          "correctionOrComment": "Eine überladene Methode ist eine bereits vorhandene Methode, die vom Ersteller an das aktuelle Projekt angepasst wird.",
          "aspects": []
        },
        {
          "text": "Eine Methode, welche mehrere verschiedene Werte übergeben kann",
          "id": "39",
          "answerCategory": "missconception",
          "correctionOrComment": "Das ist eine Methode, welche mehrere verschiedene Werte übergeben kann.",
          "aspects": []
        },
        {
          "text": "Eine überladene Methode ist eine selbsterstellte Supermethode. Wie zum beispiel ein selbstgeschriebener Konstruktor der den Standart Konstruktor erstetzt.",
          "id": "40",
          "answerCategory": "concept_mix-up",
          "correctionOrComment": "Eine überladene Methode ist eine selbsterstellte Supermethode beispielsweise ein selbstgeschriebener Konstruktor, der den Standartkonstruktor erstetzt.",
          "aspects": []
        },
        {
          "text": "Als überladen bezeichnet man eine Methode, die den selben Namen hat, wie eine andere, aber andere Parameter erwartet.",
          "id": "41",
          "answerCategory": "correct",
          "correctionOrComment": "Als überladen bezeichnet man eine Methode, die den selben Namen hat, wie eine andere, aber andere Parameter erwartet.",
          "aspects": [
            {
              "text": "Als überladen bezeichnet man eine Methode, die den selben Namen hat, wie eine andere",
              "elements": [
                [
                  0,
                  84
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "eine Methode, die ;; aber andere Parameter erwartet",
              "elements": [
                [
                  29,
                  46
                ],
                [
                  86,
                  116
                ]
              ],
              "aIdx": 2,
              "label": 0
            }
          ]
        },
        {
          "text": "Das sind mehrere Methoden mit dem gleichen Namen der benutzt wird. Allerdings besitzen sie andere Ausgaben.",
          "id": "42",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Das sind mehrere Methoden mit dem gleichen Namen, der benutzt wird. Allerdings besitzen sie andere Ausgaben.",
          "aspects": [
            {
              "text": "Das sind mehrere Methoden mit dem gleichen Namen",
              "elements": [
                [
                  0,
                  48
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "ist eine Methode, den selben namen und die selbe funktion hat",
          "id": "43",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Das ist eine Methode, die den selben Namen und die selbe Funktion hat.",
          "aspects": [
            {
              "text": "Das ist eine Methode, die den selben Namen ;; hat",
              "elements": [
                [
                  0,
                  42
                ],
                [
                  66,
                  69
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Eine Methode die nichts zurückgeben kann.",
          "id": "44",
          "answerCategory": "guessing",
          "correctionOrComment": "Das ist eine Methode, die nichts zurückgeben kann.",
          "aspects": []
        },
        {
          "text": "Haben zwei verschiedene Methoden denselben Namen heißen Sie überladen. Sie unterscheiden sich durch ihre Parameter. Sie sorgen für Benutzerfreundlichkeit.",
          "id": "45",
          "answerCategory": "correct",
          "correctionOrComment": "Haben zwei verschiedene Methoden denselben Namen, heißen sie überladen. Sie unterscheiden sich durch ihre Parameter. Sie sorgen für Benutzerfreundlichkeit.",
          "aspects": [
            {
              "text": "Haben zwei verschiedene Methoden denselben Namen, heißen sie überladen",
              "elements": [
                [
                  0,
                  70
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "Sie unterscheiden sich durch ihre Parameter",
              "elements": [
                [
                  72,
                  115
                ]
              ],
              "aIdx": 2,
              "label": 0
            }
          ]
        },
        {
          "text": "Eine Methode, die sich nur ihrer Signatur (Parameterleiste und -typen) von einer anderen Methode unterscheidet, z.B. kann der Konstruktor einer Klasse überladen werden, indem er jeweils eine unterschiedliche Anzahl an Variablen und/oder verschiedene Typen entgegennimmt.",
          "id": "46",
          "answerCategory": "binary_correct",
          "correctionOrComment": "Das ist eine Methode, die sich nur anhand ihrer Signatur (Parameterliste und -typen) von einer anderen Methode unterscheidet. Beispielsweise kann der Konstruktor einer Klasse überladen werden, indem er jeweils eine unterschiedliche Anzahl an Variablen oder verschiedene Typen entgegennimmt.",
          "aspects": [
            {
              "text": "Das ist eine Methode, die sich nur anhand ihrer Signatur (Parameterliste und -typen) von einer anderen Methode unterscheidet",
              "elements": [
                [
                  0,
                  124
                ]
              ],
              "aIdx": 2,
              "label": 1
            }
          ]
        },
        {
          "text": "Eine überladene Methode ist eine Methode die den selben Namen hat wie eine oder mehrere Methoden und die je nach EIngabewert aufgerufen wird. So kann es sein das bei einer Eingabe eine andere Methode des selben Namens wie bei einer anderen Eingabe aufgerufen wird. So ist es möglich mit \"\"derselben\"\" Methode verschiedene EIngabetypen anzusprechen.",
          "id": "47",
          "answerCategory": "binary_correct",
          "correctionOrComment": "Eine überladene Methode ist eine Methode, die den selben Namen hat, wie eine oder mehrere Methoden und die je nach Eingabewert aufgerufen wird. So kann es sein, dass bei einer Eingabe eine andere Methode des selben Namens, wie bei einer anderen Eingabe aufgerufen wird. So ist es möglich mit derselben Methode verschiedene Eingabetypen anzusprechen.",
          "aspects": [
            {
              "text": "Eine überladene Methode ist eine Methode, die den selben Namen hat",
              "elements": [
                [
                  0,
                  66
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "eine Methode ;; die je nach Eingabewert aufgerufen wird",
              "elements": [
                [
                  28,
                  40
                ],
                [
                  103,
                  142
                ]
              ],
              "aIdx": 2,
              "label": 1
            }
          ]
        },
        {
          "text": "Eine Methode ist überladen, wenn mindestens eine weitere Methode mit dem selben Namen aber einer anderen Signatur vorliegt.",
          "id": "48",
          "answerCategory": "correct",
          "correctionOrComment": "Eine Methode ist überladen, wenn mindestens eine weitere Methode mit dem selben Namen aber einer anderen Signatur vorliegt.",
          "aspects": [
            {
              "text": "Eine Methode ist überladen, wenn mindestens eine weitere Methode mit dem selben Namen ;; vorliegt",
              "elements": [
                [
                  0,
                  85
                ],
                [
                  114,
                  122
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "wenn mindestens eine weitere Methode mit ;; einer anderen Signatur vorliegt",
              "elements": [
                [
                  28,
                  68
                ],
                [
                  91,
                  122
                ]
              ],
              "aIdx": 2,
              "label": 1
            }
          ]
        },
        {
          "text": "Eine überladene Methode ist eine Methode die andere Methoden aufruft.",
          "id": "49",
          "answerCategory": "guessing",
          "correctionOrComment": "Eine überladene Methode ist eine Methode, die andere Methoden aufruft.",
          "aspects": []
        },
        {
          "text": "-",
          "id": "50",
          "answerCategory": "none",
          "correctionOrComment": "-",
          "aspects": []
        },
        {
          "text": "Überlade Methoden sind Methoden die einander überschreiben können z.B. \"\"+\"\".",
          "id": "51",
          "answerCategory": "concept_mix-up",
          "correctionOrComment": "Überlade Methoden sind Methoden, die einander überschreiben können.",
          "aspects": []
        },
        {
          "text": "Eine Methode die es schonmal gibt. Also mit dem gleichen Namen. Mit der Methode kann man dann mehrere Sachen machen (sie überschreiben sich nicht).",
          "id": "52",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Das ist eine Methode, die es schonmal gibt, also mit dem gleichen Namen. Mit der Methode kann man dann mehrere Sachen machen. Sie überschreiben sich nicht.",
          "aspects": [
            {
              "text": "Das ist eine Methode, die es schonmal gibt, also mit dem gleichen Namen",
              "elements": [
                [
                  0,
                  71
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "eine überladene methode ist eine methode die aus einer basisklasse abgeleitet ist und in der der abgeleitetetn klasse überschrieben wird beispiellsweise hat jede klasse die methode toString(), da alle klassen von Object abgeleitet sind, um eine lesbare ausgabe zu erhalten muss die methode toString in der abgeleiteten Klasse überschrieben werden und ist dann überladen",
          "id": "53",
          "answerCategory": "concept_mix-up",
          "correctionOrComment": "Eine überladene Methode ist eine Methode, die aus einer Basisklasse abgeleitet ist und in der abgeleiteten Klasse überschrieben wird. Beispielsweise hat jede Klasse die Methode 'toString()', da alle Klassen von 'Object' abgeleitet sind. Um eine lesbare Ausgabe zu erhalten muss die Methode 'toString' in der abgeleiteten Klasse überschrieben werden und ist dann überladen.",
          "aspects": []
        },
        {
          "text": "Eine Methode, die das gleiche Schutzattribut, den gleichen Rückgabetyp und den gleichen Methodenname hat. Sie unterscheidet sich nur in den Übergabeparametern.",
          "id": "54",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Das ist eine Methode, die das gleiche Schutzattribut, den gleichen Rückgabetyp und den gleichen Methodenname hat. Sie unterscheidet sich nur in den Übergabeparametern.",
          "aspects": [
            {
              "text": "Das ist eine Methode, die ;; den gleichen Methodenname hat",
              "elements": [
                [
                  0,
                  25
                ],
                [
                  83,
                  112
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "Sie unterscheidet sich nur in den Übergabeparametern",
              "elements": [
                [
                  114,
                  166
                ]
              ],
              "aIdx": 2,
              "label": 0
            }
          ]
        },
        {
          "text": "Haben zwei verschieden Methoden derselben Namen heißen sie überladen. Überladen Methoiden müssen sich durch die Signatur(Parameterliste und -typen) unterscheiden, der Rückgabewert ist egal.",
          "id": "55",
          "answerCategory": "binary_correct",
          "correctionOrComment": "Haben zwei verschieden Methoden denselben Namen, heißen sie überladen. Überladene Methoden müssen sich durch die Signatur (Parameterliste und -typen) unterscheiden. Der Rückgabewert ist egal.",
          "aspects": [
            {
              "text": "Haben zwei verschieden Methoden denselben Namen, heißen sie überladen",
              "elements": [
                [
                  0,
                  69
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "Überladene Methoden müssen sich durch die Signatur (Parameterliste und -typen) unterscheiden",
              "elements": [
                [
                  71,
                  163
                ]
              ],
              "aIdx": 2,
              "label": 1
            }
          ]
        },
        {
          "text": "wenn zwei verschiedene methoden denselben namen haben, heißen sie überladen. sie müssen sich durch die Signatur (Parameterliste und typen) unterscheiden,der Rrückgabe wert ist egal.",
          "id": "56",
          "answerCategory": "binary_correct",
          "correctionOrComment": "Wenn zwei verschiedene Methoden denselben Namen haben, heißen sie überladen. Sie müssen sich durch die Signatur (Parameterliste und -typen) unterscheiden. Der Rrückgabewert ist egal.",
          "aspects": [
            {
              "text": "Wenn zwei verschiedene Methoden denselben Namen haben, heißen sie überladen",
              "elements": [
                [
                  0,
                  75
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "Sie müssen sich durch die Signatur (Parameterliste und -typen) unterscheiden",
              "elements": [
                [
                  77,
                  153
                ]
              ],
              "aIdx": 2,
              "label": 1
            }
          ]
        },
        {
          "text": "eine Methode die",
          "id": "57",
          "answerCategory": "none",
          "correctionOrComment": "eine Methode die",
          "aspects": []
        },
        {
          "text": "wenn zwei Methoden denselben namen haben dann sind sie überladen sie müssen sich durch die signatur unterscheiden der rückgabewert ist egal",
          "id": "58",
          "answerCategory": "correct",
          "correctionOrComment": "Wenn zwei Methoden denselben Namen haben, dann sind sie überladen. Sie müssen sich durch die Signatur unterscheiden. Der Rückgabewert ist egal.",
          "aspects": [
            {
              "text": "Wenn zwei Methoden denselben Namen haben, dann sind sie überladen",
              "elements": [
                [
                  0,
                  65
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "Sie müssen sich durch die Signatur unterscheiden",
              "elements": [
                [
                  67,
                  115
                ]
              ],
              "aIdx": 2,
              "label": 1
            }
          ]
        },
        {
          "text": "Wenn zwei verschiedene Methoden denselben Namen haben, dann heißen sie überladen. Überladene Methoden müssen sich durch die Parameterliste und -typen unterscheiden.",
          "id": "59",
          "answerCategory": "correct",
          "correctionOrComment": "Wenn zwei verschiedene Methoden denselben Namen haben, dann heißen sie überladen. Überladene Methoden müssen sich durch die Parameterliste und -typen unterscheiden.",
          "aspects": [
            {
              "text": "Wenn zwei verschiedene Methoden denselben Namen haben, dann heißen sie überladen",
              "elements": [
                [
                  0,
                  80
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "Überladene Methoden müssen sich durch die Parameterliste und -typen unterscheiden",
              "elements": [
                [
                  82,
                  163
                ]
              ],
              "aIdx": 2,
              "label": 0
            }
          ]
        },
        {
          "text": "-",
          "id": "60",
          "answerCategory": "none",
          "correctionOrComment": "-",
          "aspects": []
        },
        {
          "text": "Mehrere Methoden haben dieselben Namen, man kann sie durch ihre Eigenschaften entscheiden. Der Aufruf ist dabei egal.",
          "id": "61",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Mehrere Methoden haben dieselben Namen. Man kann sie durch ihre Eigenschaften unterscheiden. Der Aufruf ist dabei egal.",
          "aspects": [
            {
              "text": "Mehrere Methoden haben dieselben Namen",
              "elements": [
                [
                  0,
                  38
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "Man kann sie durch ihre Eigenschaften unterscheiden",
              "elements": [
                [
                  40,
                  91
                ]
              ],
              "aIdx": 2,
              "label": 1
            }
          ]
        },
        {
          "text": "Wenn zwei verschiedene Methoden den selben Namen haben nennt man sie Überladen. Sie müssen sich durch die Signatur unterscheiden. Der Rückgabewert ist egal.",
          "id": "62",
          "answerCategory": "correct",
          "correctionOrComment": "Wenn zwei verschiedene Methoden denselben Namen haben, nennt man sie überladen. Sie müssen sich durch die Signatur unterscheiden. Der Rückgabewert ist egal.",
          "aspects": [
            {
              "text": "Wenn zwei verschiedene Methoden denselben Namen haben, nennt man sie überladen",
              "elements": [
                [
                  0,
                  78
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "Sie müssen sich durch die Signatur unterscheiden",
              "elements": [
                [
                  80,
                  128
                ]
              ],
              "aIdx": 2,
              "label": 1
            }
          ]
        },
        {
          "text": "Vererbte Methode/Konstruktor die mit Override überschrieben wurde. Beispiel: Überschreibung des Standartkonstruktors.",
          "id": "63",
          "answerCategory": "concept_mix-up",
          "correctionOrComment": "Das sind vererbte Methoden oder Konstruktoren, die mit 'Override' überschrieben wurde.",
          "aspects": []
        },
        {
          "text": "Sind Methoden mit den selben Methodennamen, der unterschied besteht aber da drin, dass die Parameteranzahl bzw. Typen sich unterscheiden.",
          "id": "64",
          "answerCategory": "correct",
          "correctionOrComment": "Das sind Methoden mit den selben Methodennamen. Der Unterschied besteht aber darin, dass die Parameteranzahl oder -typen sich unterscheiden.",
          "aspects": [
            {
              "text": "Das sind Methoden mit den selben Methodennamen",
              "elements": [
                [
                  0,
                  46
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "Der Unterschied besteht aber darin, dass die Parameteranzahl oder -typen sich unterscheiden",
              "elements": [
                [
                  48,
                  139
                ]
              ],
              "aIdx": 2,
              "label": 0
            }
          ]
        },
        {
          "text": "Haben zwei verschiedene Methoden denselben Namen heißen sie Überladen Überladene Methoden müssen sich durch die Signatur (Parameterliste und typen) unterscheiden.",
          "id": "65",
          "answerCategory": "correct",
          "correctionOrComment": "Haben zwei verschiedene Methoden denselben Namen, heißen sie überladen. Überladene Methoden müssen sich durch die Signatur (Parameterliste und -typen) unterscheiden.",
          "aspects": [
            {
              "text": "Haben zwei verschiedene Methoden denselben Namen, heißen sie überladen",
              "elements": [
                [
                  0,
                  70
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "Überladene Methoden müssen sich durch die Signatur (Parameterliste und -typen) unterscheiden",
              "elements": [
                [
                  72,
                  164
                ]
              ],
              "aIdx": 2,
              "label": 1
            }
          ]
        },
        {
          "text": "Eine Methode ist überladen, wenn sie z.B. einen String erbt und diesen dann innerhalb der Methode mit einem neuen \"\"Wert\"\" überschreibt.",
          "id": "66",
          "answerCategory": "concept_mix-up",
          "correctionOrComment": "Eine Methode ist überladen, wenn sie beispielsweise einen String erbt und diesen dann innerhalb der Methode mit einem neuen Wert überschreibt.",
          "aspects": []
        },
        {
          "text": "überladen ist eine Methode, wenn sie doppelt implementiert wurde, mit den gleichen Parametern. Die Variable wurde gleichnamig definiert.",
          "id": "67",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Überladen ist eine Methode, wenn sie doppelt implementiert wurde, mit den gleichen Parametern. Die Variable wurde gleichnamig definiert.",
          "aspects": []
        },
        {
          "text": "Eine Methode in der zu viel Quellcode steht.",
          "id": "68",
          "answerCategory": "guessing",
          "correctionOrComment": "Eine Methode in der zu viel Quellcode steht.",
          "aspects": []
        },
        {
          "text": "Haben zwei verschiedene Methoden denselben Namen heißen sie überladen. Überladene Methoden müssen sich durch die Signatur (Parameterliste und -typen) unterscheiden den, der Rückgabewert ist egal.",
          "id": "69",
          "answerCategory": "correct",
          "correctionOrComment": "Haben zwei verschiedene Methoden denselben Namen, heißen sie überladen. Überladene Methoden müssen sich durch die Signatur (Parameterliste und -typen) unterscheiden. Der Rückgabewert ist egal.",
          "aspects": [
            {
              "text": "Haben zwei verschiedene Methoden denselben Namen, heißen sie überladen",
              "elements": [
                [
                  0,
                  70
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "Überladene Methoden müssen sich durch die Signatur (Parameterliste und -typen) unterscheiden",
              "elements": [
                [
                  72,
                  164
                ]
              ],
              "aIdx": 2,
              "label": 1
            }
          ]
        },
        {
          "text": "Überladene Methoden haben zwei verschiedene Methoden den selben Namen heißen sie Überladen. Überladene Methoden müssen sich durch die Signatur (Parameterliste und -typen) unterscheiden.",
          "id": "70",
          "answerCategory": "correct",
          "correctionOrComment": "Haben zwei verschiedene Methoden denselben Namen, heißen sie überladen. Überladene Methoden müssen sich durch die Signatur (Parameterliste und -typen) unterscheiden.",
          "aspects": [
            {
              "text": "Haben zwei verschiedene Methoden denselben Namen, heißen sie überladen",
              "elements": [
                [
                  0,
                  70
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "Überladene Methoden müssen sich durch die Signatur (Parameterliste und -typen) unterscheiden",
              "elements": [
                [
                  72,
                  164
                ]
              ],
              "aIdx": 2,
              "label": 1
            }
          ]
        },
        {
          "text": "Bedeutet dass derselbe Methodenname mehrfach in einer Klasse verwendet werden kann. Die Anzahl der Übergabeparameter ist unterschiedlich.",
          "id": "71",
          "answerCategory": "binary_correct",
          "correctionOrComment": "Es bedeutet, dass derselbe Methodenname mehrfach in einer Klasse verwendet werden kann. Die Anzahl der Übergabeparameter ist unterschiedlich.",
          "aspects": [
            {
              "text": "Es bedeutet, dass derselbe Methodenname mehrfach in einer Klasse verwendet werden kann",
              "elements": [
                [
                  0,
                  86
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "Die Anzahl der Übergabeparameter ist unterschiedlich",
              "elements": [
                [
                  88,
                  140
                ]
              ],
              "aIdx": 2,
              "label": 1
            }
          ]
        },
        {
          "text": "Eine vererbte Methode die überschrieben wird damit diese verändert werden kann für die Kindklasse. Diese werden konventionell mit @Override gekennzeichnet.",
          "id": "72",
          "answerCategory": "concept_mix-up",
          "correctionOrComment": "Das ist eine vererbte Methode, die überschrieben wird damit diese verändert werden kann für die Kindklasse. Diese werden konventionell mit '@Override' gekennzeichnet.",
          "aspects": []
        },
        {
          "text": "Eine überladene Methode ist wenn die maximale Kapazität an methoden überladen wurde.",
          "id": "73",
          "answerCategory": "guessing",
          "correctionOrComment": "Eine Methode ist überladen, wenn die maximale Kapazität an Methoden überladen wurde.",
          "aspects": []
        }
      ]
    },
    {
      "id": "4",
      "title": "Klassenattribute schätzen",
      "text": "Sie schreiben eine Klasse Beispielklasse mit einem Feld 'wert'. Wie erreichen Sie, dass 'wert' nur innerhalb von Beispielklasse schreibbar, aber von überall aus lesbar ist?",
      "type": "procedure",
      "aspects": [
        {
          "text": "Das Feld 'wert' muss mit dem Schutzattribute private deklariert werden"
        },
        {
          "text": "Die Klasse muss eine Methode bereitstellen, die das Auslesen des Feldes 'wert' ermöglicht"
        }
      ],
      "referenceAnswers": [
        {
          "id": "ref1",
          "text": "Das Feld 'wert' muss mit dem Schutzattribute private deklariert werden. Zusätzlich muss die Klasse eine Methode bereitstellen, die das Auslesen dieses Feldes ermöglicht.",
          "aspects": [
            {
              "text": "Das Feld 'wert' muss mit dem Schutzattribute private deklariert werden",
              "aIdx": 0,
              "elements": [
                [
                  0,
                  72
                ]
              ],
              "label": 0
            },
            {
              "text": "Zusätzlich muss die Klasse eine Methode bereitstellen, die das Auslesen dieses Feldes ermöglicht",
              "aIdx": 1,
              "elements": [
                [
                  74,
                  170
                ]
              ],
              "label": 0
            }
          ]
        }
      ],
      "studentAnswers": [
        {
          "text": "Ich setze \"\"Wert\"\" auf private und schreibe in der Beispielklasse einen Getter. So kann \"\"Wert\"\" gelesen von überall gelesen werden udn bleibt schreibgeschützt.",
          "id": "1",
          "answerCategory": "correct",
          "correctionOrComment": "Ich setze 'wert' auf 'private' und schreibe in der Beispielklasse einen 'Getter'. So kann 'wert' von überall gelesen werden und bleibt schreibgeschützt.",
          "aspects": [
            {
              "text": "Ich setze 'wert' auf 'private'",
              "elements": [
                [
                  0,
                  30
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Ich ;; schreibe in der Beispielklasse einen 'Getter'",
              "elements": [
                [
                  0,
                  3
                ],
                [
                  35,
                  80
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "indem man mit der sogenanneten Kapselung arbeitet: wert als Private definieren und mithilfe von Getter- und Setter-methoden den Zugrif ermöglichen.",
          "id": "2",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Indem man mit der sogenanneten Kapselung arbeitet. Man muss 'wert' als 'private' definieren und mithilfe von Getter- und Settermethoden den Zugriff ermöglichen.",
          "aspects": [
            {
              "text": "Man muss 'wert' als 'private' definieren ",
              "elements": [
                [
                  51,
                  91
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Man muss ;; mithilfe von Getter- und Settermethoden den Zugriff ermöglichen",
              "elements": [
                [
                  51,
                  59
                ],
                [
                  96,
                  159
                ]
              ],
              "aIdx": 1,
              "label": 1
            }
          ]
        },
        {
          "text": "Mit protect. Wemm man in der Beispielsklasse\"\" protect double wert\"\" schreibt ist sie für andere Klassen sichtbar aber nicht veränderbar.",
          "id": "3",
          "answerCategory": "missconception",
          "correctionOrComment": "Wenn man in der Beispielsklasse 'protected double wert' schreibt, ist sie für andere Klassen sichtbar aber nicht veränderbar.",
          "aspects": [
            {
              "text": "Wenn man in der Beispielsklasse 'protected double wert' schreibt",
              "elements": [
                [
                  0,
                  64
                ]
              ],
              "aIdx": 0,
              "label": 2
            }
          ]
        },
        {
          "text": "privat int wert und dann durch getter und setter aufrufen.",
          "id": "4",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Es muss als 'private int wert' initialisiert werden und kann dann durch 'Getter' und 'Setter' aufrufen werden.",
          "aspects": [
            {
              "text": "Es muss als 'private int wert' initialisiert werden",
              "elements": [
                [
                  0,
                  51
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Es muss ;; dann durch 'Getter' und 'Setter' aufrufen werden",
              "elements": [
                [
                  0,
                  7
                ],
                [
                  61,
                  109
                ]
              ],
              "aIdx": 1,
              "label": 1
            }
          ]
        },
        {
          "text": "man benutzt die protected um es schützen aber lesbar zu halten",
          "id": "5",
          "answerCategory": "missconception",
          "correctionOrComment": "Man benutzt 'protected' um es zu schützen aber lesbar zu halten.",
          "aspects": [
            {
              "text": "Man benutzt 'protected'",
              "elements": [
                [
                  0,
                  23
                ]
              ],
              "aIdx": 0,
              "label": 2
            }
          ]
        },
        {
          "text": "ich lege das schutzattribut von \"\"wert\"\" auf private fest und implementiere eine getter-methode sodass von überall auf den im Feld \"\"wert\"\" hinterlegten Wert über diese methode zugegriffen werden kann.",
          "id": "6",
          "answerCategory": "correct",
          "correctionOrComment": "Ich lege das Schutzattribut von 'wert' auf 'private' fest und implementiere eine Gettermethode, sodass von überall auf den im Feld 'wert' hinterlegten Wert über diese Methode zugegriffen werden kann.",
          "aspects": [
            {
              "text": "Ich lege das Schutzattribut von 'wert' auf 'private' fest",
              "elements": [
                [
                  0,
                  57
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Ich ;; implementiere eine Gettermethode",
              "elements": [
                [
                  0,
                  3
                ],
                [
                  62,
                  94
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "durch eine vererbung. mit extends können dann die anderen klassen die werte übernehmen",
          "id": "7",
          "answerCategory": "concept_mix-up",
          "correctionOrComment": "Das geht durch eine Vererbung. Mit 'extends' können dann die anderen Klassen die Werte übernehmen.",
          "aspects": []
        },
        {
          "text": "Indem man innerhalb der \"\"Beispielklasse\"\" nur einen Getter für \"\"wert\"\", aber keinen Setter verwendet.",
          "id": "8",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Das geht, indem man innerhalb der Beispielklasse nur einen 'Getter' für 'wert' aber keinen 'Setter' verwendet.",
          "aspects": [
            {
              "text": "Das geht, indem man innerhalb der Beispielklasse nur einen 'Getter' für 'wert' ;; verwendet",
              "elements": [
                [
                  0,
                  78
                ],
                [
                  100,
                  109
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "ich benutze vor wert den zustazt protected",
          "id": "9",
          "answerCategory": "missconception",
          "correctionOrComment": "Ich benutze vor 'wert' den Zusatz 'protected'.",
          "aspects": [
            {
              "text": "Ich benutze vor 'wert' den Zusatz 'protected'",
              "elements": [
                [
                  0,
                  45
                ]
              ],
              "aIdx": 0,
              "label": 2
            }
          ]
        },
        {
          "text": "protected int wert;",
          "id": "10",
          "answerCategory": "missconception",
          "correctionOrComment": "Das geht mit 'protected int wert'.",
          "aspects": [
            {
              "text": "Das geht mit 'protected int wert'",
              "elements": [
                [
                  0,
                  33
                ]
              ],
              "aIdx": 0,
              "label": 2
            }
          ]
        },
        {
          "text": "private Beispielklasse",
          "id": "11",
          "answerCategory": "missconception",
          "correctionOrComment": "Das geht mit 'private Beispielklasse'.",
          "aspects": [
            {
              "text": "Das geht mit 'private Beispielklasse'",
              "elements": [
                [
                  0,
                  37
                ]
              ],
              "aIdx": 0,
              "label": 2
            }
          ]
        },
        {
          "text": "private Typ wert; (Variable als private deklarieren, um direkten Zugriff zu vermeiden) public getWert(){return wert;} (auslesen, von überall möglich) private void setWert(Typ wert){this.wert = wert;} (schreiben, nur innerhalb der eigenen Klasse möglich)",
          "id": "12",
          "answerCategory": "correct",
          "correctionOrComment": "Man muss die Variable als 'private' deklarieren, um direkten Zugriff zu vermeiden. Ein 'public' Getter macht das  Auslesen, von überall möglich. Ein 'private'  'Setter' macht das Schreiben, nur innerhalb der eigenen Klasse möglich.",
          "aspects": [
            {
              "text": "Man muss die Variable als 'private' deklarieren",
              "elements": [
                [
                  0,
                  47
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Ein 'public' Getter macht das Auslesen, von überall möglich",
              "elements": [],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "public static final string wert...",
          "id": "13",
          "answerCategory": "missconception",
          "correctionOrComment": "Das geht mit 'public static final string wert'.",
          "aspects": [
            {
              "text": "Das geht mit 'public static final string wert'",
              "elements": [
                [
                  0,
                  46
                ]
              ],
              "aIdx": 0,
              "label": 2
            }
          ]
        },
        {
          "text": "man muss Proteced benützen damit sie von übeall lesbar ist aber nur innerhalb von Beispielklasse schreibbar ist",
          "id": "14",
          "answerCategory": "missconception",
          "correctionOrComment": "Man muss 'proteced' benutzen, damit sie von übeall lesbar, aber nur innerhalb von Beispielklasse schreibbar ist",
          "aspects": [
            {
              "text": "Man muss 'proteced' benutzen",
              "elements": [
                [
                  0,
                  28
                ]
              ],
              "aIdx": 0,
              "label": 2
            }
          ]
        },
        {
          "text": "Zuerst muss die Variable wert als private deklariert werden. So ist sie von außen schreibgeschützt. Um nun wert von außen lesbar zu machen muss ein Getter implementiert werden. Durch den Methodenaufruf getWert() kann nun wert ausgelesen werden aber nicht verändert werden.",
          "id": "15",
          "answerCategory": "correct",
          "correctionOrComment": "Zuerst muss die Variable 'wert' als 'private' deklariert werden. So ist sie von außen schreibgeschützt. Um nun 'wert' von außen lesbar zu machen muss ein 'Getter' implementiert werden. Durch den Methodenaufruf 'getWert()' kann nun 'wert' ausgelesen werden aber nicht verändert werden.",
          "aspects": [
            {
              "text": "Zuerst muss die Variable 'wert' als 'private' deklariert werden",
              "elements": [
                [
                  0,
                  63
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Um nun 'wert' von außen lesbar zu machen muss ein 'Getter' implementiert werden",
              "elements": [
                [
                  104,
                  183
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Durch das Atrribut private, schützt man Datenfelder davor das sie nur innerhalb ihrer Klasse schreibbar und sichtbar sind. Durch eine getter Methode können alle Klassen, die private geschriebene Variable lesen.",
          "id": "16",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Durch das Attribut 'private', schützt man Datenfelder davor, dass sie nur innerhalb ihrer Klasse schreibbar und sichtbar sind. Durch eine 'Getter' Methode können alle Klassen, die 'private' geschriebene Variable lesen.",
          "aspects": [
            {
              "text": "Durch das Attribut 'private', schützt man Datenfelder",
              "elements": [
                [
                  0,
                  53
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Durch eine 'Getter' Methode können alle Klassen, die 'private' geschriebene Variable lesen",
              "elements": [
                [
                  127,
                  217
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "ich erreichr es in dem ich den wert auf private setze und demendsprechende getter mache also ptivate int wert ; public int getWert(){ return wert; }",
          "id": "17",
          "answerCategory": "correct",
          "correctionOrComment": "Ich erreiche es, indem ich 'wert' auf 'private' setze und demendsprechende 'Getter' mache.",
          "aspects": [
            {
              "text": "Ich erreiche es, indem ich 'wert' auf 'private' setze",
              "elements": [
                [
                  0,
                  53
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Ich erreiche es, indem ich ;; demendsprechende 'Getter' mache",
              "elements": [
                [
                  0,
                  26
                ],
                [
                  58,
                  89
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Ich setze das Feld \"\"wert\"\" auf Private und benutze von den anderen Klassen aus Getter um den Wert des Feldes wert zu lesen.",
          "id": "18",
          "answerCategory": "correct",
          "correctionOrComment": "Ich setze das Feld 'wert' auf 'private' und benutze von den anderen Klassen aus 'Getter' um den Wert des Feldes 'wert' zu lesen.",
          "aspects": [
            {
              "text": "Ich setze das Feld 'wert' auf 'private'",
              "elements": [
                [
                  0,
                  39
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Ich ;; benutze von den anderen Klassen aus 'Getter'",
              "elements": [
                [
                  0,
                  3
                ],
                [
                  44,
                  88
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "protected",
          "id": "19",
          "answerCategory": "missconception",
          "correctionOrComment": "Das geht mit 'protected'.",
          "aspects": [
            {
              "text": "Das geht mit 'protected'.",
              "elements": [
                [
                  0,
                  25
                ]
              ],
              "aIdx": 0,
              "label": 2
            }
          ]
        },
        {
          "text": "Damit sie nur schreibbar innerhalbder Klasse ist deklariert man sie mit private. Lesbar machen Kann man die Variable indem man sie in eine get-methode steckt und diese Methode public macht.",
          "id": "20",
          "answerCategory": "correct",
          "correctionOrComment": "Damit sie nur schreibbar innerhalb der Klasse ist, deklariert man sie mit 'private'. Lesbar machen kann man die Variable, indem man sie in eine Gettermethode steckt und diese Methode 'public' macht.",
          "aspects": [
            {
              "text": "deklariert man sie mit 'private'",
              "elements": [
                [
                  51,
                  83
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Lesbar machen kann man die Variable, indem man sie in eine Gettermethode steckt",
              "elements": [
                [
                  85,
                  164
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Diese feld soll mit Attribut private deklarieren werden und mit eine methode überall lesbar wird",
          "id": "21",
          "answerCategory": "correct",
          "correctionOrComment": "Dieses Feld sollte mit dem Attribut 'private' deklariert werden und mit einer Gettermethode von überall lesbar gemacht werden.",
          "aspects": [
            {
              "text": "Dieses Feld sollte mit dem Attribut 'private' deklariert werden ",
              "elements": [
                [
                  0,
                  63
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Dieses Feld sollte ;; mit einer Gettermethode von überall lesbar gemacht werden",
              "elements": [
                [
                  0,
                  18
                ],
                [
                  68,
                  125
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "private (z.B. int) wert; Und erstelle dann eine Getter Methode. public int getWert() { return wert; }",
          "id": "22",
          "answerCategory": "correct",
          "correctionOrComment": "Das geht mit 'private int wert'. Man erstelle dann eine 'public' Gettermethode.",
          "aspects": [
            {
              "text": "Das geht mit 'private int wert'",
              "elements": [
                [
                  0,
                  31
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Man erstelle dann eine 'public' Gettermethode",
              "elements": [
                [
                  33,
                  78
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "public class zahl; private int wert; public int getWert(){ return wert; mit private ermöglichen wir das man nur in der eigenen klasse zugriff hat und mit getter machen wir sie aber in den anderen klassen sichtbar.",
          "id": "23",
          "answerCategory": "correct",
          "correctionOrComment": "Mit 'private' ermöglichen wir, dass man nur in der eigenen Klasse Zugriff hat und mit einem 'Getter' machen wir sie aber in den anderen Klassen sichtbar.",
          "aspects": [
            {
              "text": "Mit 'private' ermöglichen wir, dass man nur in der eigenen Klasse Zugriff hat",
              "elements": [
                [
                  0,
                  77
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "mit einem 'Getter' machen wir sie aber in den anderen Klassen sichtbar",
              "elements": [
                [
                  82,
                  152
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "public class Beispielklasse protected int wert; public String getWert(){ return this.wert;} Dadurch dass man nur mit dem Setter wert überschreiben kann es bzw scheibbar machen kann, benutz man hier nur einen getter.",
          "id": "24",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Das geht mit 'protected int wert'. Dadurch dass man nur mit dem 'Setter' 'wert' überschreiben kann, benutz man hier nur einen 'Getter'.",
          "aspects": [
            {
              "text": "Das geht mit 'protected int wert'",
              "elements": [
                [
                  0,
                  33
                ]
              ],
              "aIdx": 0,
              "label": 2
            },
            {
              "text": "benutz man hier nur einen 'Getter'",
              "elements": [
                [
                  100,
                  134
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "mit dem Präfix protected zb: protected int wert;",
          "id": "25",
          "answerCategory": "missconception",
          "correctionOrComment": "Das geht mit dem Präfix 'protected', also 'protected int wert'.",
          "aspects": [
            {
              "text": "Das geht mit dem Präfix 'protected', also 'protected int wert'",
              "elements": [
                [
                  0,
                  62
                ]
              ],
              "aIdx": 0,
              "label": 2
            }
          ]
        },
        {
          "text": "public final wert",
          "id": "26",
          "answerCategory": "missconception",
          "correctionOrComment": "Das geht mit 'public final wert'.",
          "aspects": [
            {
              "text": "Das geht mit 'public final wert'",
              "elements": [
                [
                  0,
                  32
                ]
              ],
              "aIdx": 0,
              "label": 2
            }
          ]
        },
        {
          "text": "Wir definiert die Variable \"\"wert\"\" mit dem Zugriffatributt protected. - (protected int wert)",
          "id": "27",
          "answerCategory": "missconception",
          "correctionOrComment": "Wir definieren die Variable 'wert' mit dem Zugriffsattribut protected ('protected int wert').",
          "aspects": [
            {
              "text": "Wir definieren die Variable 'wert' mit dem Zugriffsattribut protected ('protected int wert')",
              "elements": [
                [
                  0,
                  92
                ]
              ],
              "aIdx": 0,
              "label": 2
            }
          ]
        },
        {
          "text": "public class Beispielklasse private int wert; Durch eine getter Methode! und der wert muss private gesetzt sein!",
          "id": "28",
          "answerCategory": "correct",
          "correctionOrComment": "Durch eine Gettermethode und der Wert muss 'private' gesetzt sein!",
          "aspects": [
            {
              "text": "der Wert muss 'private' gesetzt sein",
              "elements": [
                [
                  29,
                  65
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Durch eine Gettermethode",
              "elements": [
                [
                  0,
                  24
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "indem ich die Klasse ableite mit extends",
          "id": "29",
          "answerCategory": "missconception",
          "correctionOrComment": "Das geht, indem ich die Klasse ableite mit extends.",
          "aspects": []
        },
        {
          "text": "protected wert;",
          "id": "30",
          "answerCategory": "missconception",
          "correctionOrComment": "Das geht mit 'protected wert'.",
          "aspects": [
            {
              "text": "Das geht mit 'protected wert'",
              "elements": [
                [
                  0,
                  29
                ]
              ],
              "aIdx": 0,
              "label": 2
            }
          ]
        },
        {
          "text": "indem man den \"\"wert\"\" auf private setzt und ihn danach mit getter/setter aufruft. Dadurch kann man nur innerhalb der Beispielklasse den \"\"wert\"\" verändern.",
          "id": "31",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Das geht, indem man den Wert auf 'private' setzt und ihn danach mit 'Getter' und 'Setter' aufruft. Dadurch kann man nur innerhalb der Beispielklasse den Wert verändern.",
          "aspects": [
            {
              "text": "Das geht, indem man den Wert auf 'private' setzt und ihn danach mit ;; 'Setter' aufruft",
              "elements": [
                [
                  0,
                  67
                ],
                [
                  81,
                  97
                ]
              ],
              "aIdx": 0,
              "label": 2
            },
            {
              "text": "Das geht, indem man ;; ihn danach mit 'Getter' ;; aufruft",
              "elements": [
                [
                  0,
                  19
                ],
                [
                  53,
                  76
                ],
                [
                  90,
                  97
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "indem man das Feld \"\"wert\"\" als private deglariert. man kann es dann über die getterMethode aufrufen!",
          "id": "32",
          "answerCategory": "correct",
          "correctionOrComment": "Das geht, indem man das Feld 'wert' als 'private' deklariert. Man kann es dann über die Gettermethode aufrufen!",
          "aspects": [
            {
              "text": "Das geht, indem man das Feld 'wert' als 'private' deklariert",
              "elements": [
                [
                  0,
                  60
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Man kann es dann über die Gettermethode aufrufen",
              "elements": [
                [
                  62,
                  110
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Das Feld wert ist auf private zu setzen. Durch einen getter für wert kann die Variable von außen ausgelesen werden. Das private verhindert jeden Schreibzugriff außer aus der eigenen Klasse.",
          "id": "33",
          "answerCategory": "correct",
          "correctionOrComment": "Das Feld 'wert' ist auf 'private' zu setzen. Durch einen 'Getter' für 'wert' kann die Variable von außen ausgelesen werden. Das 'private' verhindert jeden Schreibzugriff außer aus der eigenen Klasse.",
          "aspects": [
            {
              "text": "Das Feld 'wert' ist auf 'private' zu setzen",
              "elements": [
                [
                  0,
                  43
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Durch einen 'Getter' für 'wert' kann die Variable von außen ausgelesen werden",
              "elements": [
                [
                  45,
                  122
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Man nimmt sogenannte Schutzattribute zu Hilfe. In dem Beispiel nimmt man nicht public sondern private und protected.",
          "id": "34",
          "answerCategory": "missconception",
          "correctionOrComment": "Man nimmt sogenannte Schutzattribute zur Hilfe. In dem Beispiel nimmt man nicht 'public' sondern 'private' und 'protected'.",
          "aspects": [
            {
              "text": "In dem Beispiel nimmt man nicht 'public' sondern 'private' und 'protected'",
              "elements": [
                [
                  48,
                  122
                ]
              ],
              "aIdx": 0,
              "label": 2
            }
          ]
        },
        {
          "text": "mit der get Methode. Beispielklasse ist auf private gesezt kann aber von außerhalb mit der get Methode gelesen werden",
          "id": "35",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Das geht mit der Gettermethode. Die Beispielklasse ist auf 'private' gesezt, kann aber von außerhalb mit der Gettermethode gelesen werden.",
          "aspects": [
            {
              "text": "Die Beispielklasse ist auf 'private' gesezt",
              "elements": [
                [
                  32,
                  75
                ]
              ],
              "aIdx": 0,
              "label": 1
            },
            {
              "text": "Die Beispielklasse ;; kann aber von außerhalb mit der Gettermethode gelesen werden",
              "elements": [
                [
                  32,
                  50
                ],
                [
                  77,
                  137
                ]
              ],
              "aIdx": 1,
              "label": 1
            }
          ]
        },
        {
          "text": "Indem man den dazugehörigen getter definiert aber nicht den setter, der das schreiben erlauben würde.",
          "id": "36",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Indem man den dazugehörigen 'Getter' definiert aber nicht den 'Setter', der das schreiben erlauben würde.",
          "aspects": [
            {
              "text": "Indem man den dazugehörigen 'Getter' definiert",
              "elements": [
                [
                  0,
                  46
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "class Beispielklasse { private int wert; public Beispielklasse (int wert) { this.wert = wert; } public int getWert () { return wert; } private void setWert (int i) { this.wert = i; } } Wennn nur eine private set-Methode für die private Variable wert definiert wird, kann der Wert von wert nicht von außen geändert werden, sondern nur innerhalb der Klasse. Eine public get-Methode ermöglicht jedoch, dass der Wert von überall aus gelesen werden kann.",
          "id": "37",
          "answerCategory": "correct",
          "correctionOrComment": "Der Wert wird mit 'private int wert' deklariert. Wenn nur eine 'private' set-Methode für die 'private' Variable 'wert' definiert wird, kann der Wert von 'wert' nicht von außen geändert werden, sondern nur innerhalb der Klasse. Eine 'public' get-Methode ermöglicht jedoch, dass der Wert von überall aus gelesen werden kann.",
          "aspects": [
            {
              "text": "Der Wert wird mit 'private int wert' deklariert",
              "elements": [
                [
                  0,
                  47
                ]
              ],
              "aIdx": 0,
              "label": 1
            },
            {
              "text": "Eine 'public' get-Methode ermöglicht jedoch, dass der Wert von überall aus gelesen werden kann",
              "elements": [
                [
                  227,
                  321
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Es wird nur eine getter- und keine setter-Methode eingefügt. So kann zwar auf die getter-Methode zurückgegriffen und der Wert ausgelesen werden, jedoch kann nicht mithilfe der setter-Methode der Wert verändert werden.",
          "id": "38",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Es wird nur eine getter- und keine setter-Methode eingefügt. So kann zwar auf die getter-Methode zurückgegriffen und der Wert ausgelesen werden, jedoch kann nicht mithilfe der setter-Methode der Wert verändert werden.",
          "aspects": [
            {
              "text": "Es wird nur eine getter- und keine setter-Methode eingefügt",
              "elements": [
                [
                  0,
                  59
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Das Feld wert muss private und darf nicht final sein, es muss eine get-Methode und es darf keine set-Methode vorliegen.",
          "id": "39",
          "answerCategory": "correct",
          "correctionOrComment": "Das Feld 'wert' muss 'private' und darf nicht 'final' sein. Ss muss eine get-Methode und es darf keine set-Methode vorliegen.",
          "aspects": [
            {
              "text": "Das Feld 'wert' muss 'private' ;; sein",
              "elements": [
                [
                  0,
                  30
                ],
                [
                  54,
                  58
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Ss muss eine get-Methode und es darf keine set-Methode vorliegen",
              "elements": [
                [
                  60,
                  124
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "wert wird als \"\"private\"\" deklariert. danach wird ein getter gesetzt um wert von überall aus lesbar zu machen.",
          "id": "40",
          "answerCategory": "correct",
          "correctionOrComment": "'wert' wird als 'private' deklariert. Danach wird ein Getter gesetzt um 'wert' von überall aus lesbar zu machen.",
          "aspects": [
            {
              "text": "'wert' wird als 'private' deklariert",
              "elements": [
                [
                  0,
                  36
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Danach wird ein Getter gesetzt um 'wert' von überall aus lesbar zu machen",
              "elements": [
                [
                  38,
                  111
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "-",
          "id": "41",
          "answerCategory": "none",
          "correctionOrComment": "-",
          "aspects": []
        },
        {
          "text": "Falls Wert z.B.: als int. private int wert; public int getWert() { return wert; } //Methode zum Lesen kann von überall aufgerufen werden. private int setWert(int wert) { this.wert = wert;} //methode zum Schreiben kann nur innerhalb der Klasse verwendet werden.",
          "id": "42",
          "answerCategory": "correct",
          "correctionOrComment": "Das Feld wird als 'private int wert' deklariert. Eine 'public' getter-Methode zum Lesen kann von überall aufgerufen werden. Eine private setter-Methode zum Schreiben kann nur innerhalb der Klasse verwendet werden.",
          "aspects": [
            {
              "text": "Das Feld wird als 'private int wert' deklariert",
              "elements": [
                [
                  0,
                  47
                ]
              ],
              "aIdx": 0,
              "label": 1
            },
            {
              "text": "Eine 'public' getter-Methode zum Lesen kann von überall aufgerufen werden",
              "elements": [
                [
                  49,
                  122
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "mit getter und setter",
          "id": "43",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Das geht mit Getter und Setter.",
          "aspects": [
            {
              "text": "Das geht mit  ;; Setter",
              "elements": [
                [
                  0,
                  12
                ],
                [
                  24,
                  30
                ]
              ],
              "aIdx": 0,
              "label": 2
            },
            {
              "text": "Das geht mit Getter",
              "elements": [
                [
                  0,
                  19
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Feld wert wird mit private deklariert, so ist es nur innerhalb von Beispielklasse lesbar und schreibbar. um es von überall lesen zu können benötigt man noch einer getter methode : public getWert(){ return this.wert; }",
          "id": "44",
          "answerCategory": "correct",
          "correctionOrComment": "Das Feld 'wert' wird mit 'private' deklariert. So ist es nur innerhalb der Beispielklasse lesbar und schreibbar. Um es von überall lesen zu können benötigt man noch eine getter-Methode.",
          "aspects": [
            {
              "text": "Das Feld 'wert' wird mit 'private' deklariert",
              "elements": [
                [
                  0,
                  45
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Um es von überall lesen zu können benötigt man noch eine getter-Methode",
              "elements": [
                [
                  113,
                  184
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "In der Beispielklasse die Getter-Methode mit Schutzattribut private schreiben. Die Setter-Methode in der gleichen Klasse mit public schreiben.",
          "id": "45",
          "answerCategory": "missconception",
          "correctionOrComment": "In der Beispielklasse die getter-Methode mit dem Schutzattribut 'private' schreiben. Die setter-Methode in der gleichen Klasse mit 'public' schreiben.",
          "aspects": [
            {
              "text": "Die setter-Methode in der gleichen Klasse mit 'public' schreiben",
              "elements": [
                [
                  85,
                  149
                ]
              ],
              "aIdx": 0,
              "label": 2
            },
            {
              "text": "In der Beispielklasse die getter-Methode mit dem Schutzattribut 'private' schreiben",
              "elements": [
                [
                  0,
                  83
                ]
              ],
              "aIdx": 1,
              "label": 2
            }
          ]
        },
        {
          "text": "wert ist schreibgeschutz d.h privarte. wir konnen eine getWert methode machen und dann diese methode von außen aufrufen.",
          "id": "46",
          "answerCategory": "correct",
          "correctionOrComment": "Das Feld 'wert' ist schreibgeschutz mittels 'private'. Wir konnen eine 'getWert' Methode machen und dann diese Methode von außen aufrufen.",
          "aspects": [
            {
              "text": "Das Feld 'wert' ist schreibgeschutz mittels 'private'",
              "elements": [
                [
                  0,
                  53
                ]
              ],
              "aIdx": 0,
              "label": 1
            },
            {
              "text": "Wir konnen eine 'getWert' Methode machen und dann diese Methode von außen aufrufen",
              "elements": [
                [
                  55,
                  137
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "private int wert --> dadurch ist sie nicht von außen zu ändern. public int getWert(){ return wert; die methode ist public, sodass man den wert von außen lesen kann",
          "id": "47",
          "answerCategory": "correct",
          "correctionOrComment": "Durch 'private int wert' ist die Variable nicht von außen zu ändern. Man braucht eine 'public' 'getWert' Methode, sodass man den Wert von außen lesen kann.",
          "aspects": [
            {
              "text": "Durch 'private int wert' ist die Variable nicht von außen zu ändern",
              "elements": [
                [
                  0,
                  67
                ]
              ],
              "aIdx": 0,
              "label": 1
            },
            {
              "text": "Man braucht eine 'public' 'getWert' Methode, sodass man den Wert von außen lesen kann",
              "elements": [
                [
                  69,
                  154
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "den Feld wert muss protected sein.",
          "id": "48",
          "answerCategory": "missconception",
          "correctionOrComment": "Das Feld 'wert' muss protected sein.",
          "aspects": [
            {
              "text": "Das Feld 'wert' muss protected sein",
              "elements": [
                [
                  0,
                  35
                ]
              ],
              "aIdx": 0,
              "label": 2
            }
          ]
        },
        {
          "text": "wert final setzen und mit public getWert() für andere lesbar machen",
          "id": "49",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Man muss 'wert' 'final' setzen und mit 'public' 'getWert()' für andere lesbar machen.",
          "aspects": [
            {
              "text": "Man muss 'wert' 'final' setzen",
              "elements": [
                [
                  0,
                  30
                ]
              ],
              "aIdx": 0,
              "label": 2
            },
            {
              "text": "Man muss 'wert' ;; mit 'public' 'getWert()' für andere lesbar machen",
              "elements": [
                [
                  0,
                  15
                ],
                [
                  35,
                  84
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Zu erst muss das Schutzatribut \"\"private\"\" sein. Dannach kann man mit setter die Variable innerhalb der Klasse schreiben und mit getter überall zu lesen.",
          "id": "50",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Zuerst muss das Schutzattribut 'private' sein. Danach kann man mit einem Setter die Variable innerhalb der Klasse schreiben und mit einem Getter überall lesen.",
          "aspects": [
            {
              "text": "Zuerst muss das Schutzattribut 'private' sein. Danach kann man mit einem Setter die Variable innerhalb der Klasse schreiben",
              "elements": [
                [
                  0,
                  123
                ]
              ],
              "aIdx": 0,
              "label": 2
            },
            {
              "text": "Danach kann man ;; die Variable ;; mit einem Getter überall lesen",
              "elements": [
                [
                  47,
                  62
                ],
                [
                  80,
                  92
                ],
                [
                  128,
                  158
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "mit einem Getter und keinem Setter",
          "id": "51",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Das geht mit einem Getter und keinem Setter.",
          "aspects": [
            {
              "text": "Das geht mit einem Getter und keinem Setter",
              "elements": [
                [
                  0,
                  43
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Man will, dass \"\"wert\"\" schreibgeschütz auf andere abgeleitete Klassen ist. Deswegen macht man einen Konstruktoir, womit man in der Basisklasse diese Variable benutzen kann. Außerdem braucht man eine getter-methode, damit sie in anderen Klassen lesbar ist. Da privat vor \"\"wert\"\" gesetzt wird, ist es nun nur lesbar aber abgeleitet Klassen können es nicht überscxhreiben. Esa ist das Prinzip der Kapselung/ Schutz vor Überschreibung.",
          "id": "52",
          "answerCategory": "binary_correct",
          "correctionOrComment": "Man will, dass 'wert' schreibgeschütz auf andere abgeleitete Klassen ist. Deswegen macht man einen Konstruktoir, womit man in der Basisklasse diese Variable benutzen kann. Außerdem braucht man eine getter-Methode, damit sie in anderen Klassen lesbar ist. Da 'private' vor 'wert' gesetzt wird, ist es nun nur lesbar aber abgeleitet Klassen können es nicht überschreiben. Es ist das Prinzip der Kapselung und dem Schutz vor Überschreibung.",
          "aspects": [
            {
              "text": "Da 'private' vor 'wert' gesetzt wird",
              "elements": [
                [
                  255,
                  291
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Außerdem braucht man eine getter-Methode, damit sie in anderen Klassen lesbar ist",
              "elements": [
                [
                  172,
                  253
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Ich setzen \"\"wert\"\" private, dadurch ist es nur für die Klassse Beispielklasse schreibbar. Durch eine Getter Methode ist es überall lesbar.",
          "id": "53",
          "answerCategory": "correct",
          "correctionOrComment": "Ich setze 'wert' 'private'. Dadurch ist es nur für die Klassse Beispielklasse schreibbar. Durch eine getter-Methode ist es überall lesbar.",
          "aspects": [
            {
              "text": "Ich setze 'wert' 'private'",
              "elements": [
                [
                  0,
                  26
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Durch eine getter-Methode ist es überall lesbar",
              "elements": [
                [
                  90,
                  137
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Mit dem Schutzattribut protected",
          "id": "54",
          "answerCategory": "missconception",
          "correctionOrComment": "Das geht mit dem Schutzattribut 'protected'.",
          "aspects": [
            {
              "text": "Das geht mit dem Schutzattribut 'protected'",
              "elements": [
                [
                  0,
                  43
                ]
              ],
              "aIdx": 0,
              "label": 2
            }
          ]
        },
        {
          "text": "protected",
          "id": "55",
          "answerCategory": "missconception",
          "correctionOrComment": "Das geht mit 'protected'.",
          "aspects": [
            {
              "text": "Das geht mit 'protected'",
              "elements": [
                [
                  0,
                  24
                ]
              ],
              "aIdx": 0,
              "label": 2
            }
          ]
        },
        {
          "text": "Indem ich wert auf die Sichtbarkeit private lese, aber zusätzlich eine Methode getWert() implementiere (welche public ist). getWert() gibt dann die variable wert zurück (mit return) damit jeder sie auslesen kann.",
          "id": "56",
          "answerCategory": "correct",
          "correctionOrComment": "Das geht, indem ich 'wert' auf die Sichtbarkeit 'private' setze, aber zusätzlich eine Methode 'getWert()' implementiere, welche 'public' ist. 'getWert()' gibt dann die Variable 'wert' zurück, damit jeder sie auslesen kann.",
          "aspects": [
            {
              "text": "Das geht, indem ich 'wert' auf die Sichtbarkeit 'private' setze",
              "elements": [
                [
                  0,
                  63
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Das geht, indem ich ;; aber zusätzlich eine Methode 'getWert()' implementiere, welche 'public' ist",
              "elements": [
                [
                  0,
                  19
                ],
                [
                  65,
                  140
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        }
      ]
    },
    {
      "id": "5",
      "title": "Vererbung - Schnittstellen und abstrakte Klassen",
      "text": "Sie möchten eine als 'private' deklarierte Variable und mehrere implementierte Methoden vererben. Verwenden Sie eine Schnittstelle oder eine abstrakte Klasse? Begründen Sie Ihre Antwort.",
      "type": "reason",
      "aspects": [
        {
          "text": "eine abstrakte Klasse"
        },
        {
          "text": "Schnittstellen können keine implementierten Methoden bereitstellen"
        }
      ],
      "referenceAnswers": [
        {
          "id": "ref1",
          "text": "Man muss eine abstrakte Klasse verwenden, weil Schnittstellen keine implementierten Methoden bereitstellen können.",
          "aspects": [
            {
              "text": "Man muss eine abstrakte Klasse verwenden",
              "aIdx": 0,
              "elements": [
                [
                  0,
                  40
                ]
              ],
              "label": 0
            },
            {
              "text": "weil Schnittstellen keine implementierten Methoden bereitstellen können",
              "aIdx": 1,
              "elements": [
                [
                  42,
                  113
                ]
              ],
              "label": 0
            }
          ]
        }
      ],
      "studentAnswers": [
        {
          "text": "Abstrakte Klassen Basisklassen vererben nur implemetierte Mehtoden, Schnittstellen stellen keine implementierten Methoden bereit Abstrakte klassen werden durch abstract class deklariert",
          "id": "1",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Abstrakte Klassen vererben nur implemetierte Mehtoden. Schnittstellen stellen keine implementierten Methoden bereit. Abstrakte klassen werden durch 'abstract class' deklariert.",
          "aspects": [
            {
              "text": "Schnittstellen stellen keine implementierten Methoden bereit",
              "elements": [
                [
                  55,
                  115
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Eine abstrakte Klasse, da Schnittstellen keine implemenierte Methoden bereit stellen.",
          "id": "2",
          "answerCategory": "correct",
          "correctionOrComment": "Man verwendet eine abstrakte Klasse, da Schnittstellen keine implemenierte Methoden bereitstellen.",
          "aspects": [
            {
              "text": "Man verwendet eine abstrakte Klasse",
              "elements": [
                [
                  0,
                  35
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "da Schnittstellen keine implemenierte Methoden bereitstellen",
              "elements": [
                [
                  37,
                  97
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Eine Schnittstelle, da abstrakte Klasse keine Methoden weitergeben.",
          "id": "3",
          "answerCategory": "missconception",
          "correctionOrComment": "Man verwendet eine Schnittstelle, da abstrakte Klassen keine Methoden weitergeben.",
          "aspects": [
            {
              "text": "Man verwendet eine Schnittstelle",
              "elements": [
                [
                  0,
                  32
                ]
              ],
              "aIdx": 0,
              "label": 2
            },
            {
              "text": "da abstrakte Klassen keine Methoden weitergeben",
              "elements": [
                [
                  34,
                  81
                ]
              ],
              "aIdx": 1,
              "label": 2
            }
          ]
        },
        {
          "text": "Schnittstellen vererben keine implementierten Methoden, doch abstrakte Klassen können, wenn sie vereerbt werden implementierte Methoden vererben. Normalerweise müssen sie immer später implementiert werden.",
          "id": "4",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Schnittstellen vererben keine implementierten Methoden. Abstrakte Klassen können, wenn sie vereerbt werden, implementierte Methoden vererben. Normalerweise müssen sie immer später implementiert werden.",
          "aspects": [
            {
              "text": "Schnittstellen vererben keine implementierten Methoden",
              "elements": [
                [
                  0,
                  54
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Basisklassen vererben nur implementierte Methoden, Schnittstellen stellen keine implementierten Methoden bereit. manche Methoden brauchen eine Implementierung gleichzeitig können manche Methoden in der Basisklasse nicht implementiert sein. eine abstrakte Klasse kann unimplementierte Methoden enthalten markiert durch abstract. dacher würde ich eine abstrakte Kalsse wählen.",
          "id": "5",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Basisklassen vererben nur implementierte Methoden. Schnittstellen stellen keine implementierten Methoden bereit. Manche Methoden brauchen eine Implementierung. Gleichzeitig können manche Methoden in der Basisklasse nicht implementiert sein. Eine abstrakte Klasse kann unimplementierte Methoden enthalten. Sie wird markiert durch 'abstract'. Daher würde ich eine abstrakte Klasse wählen.",
          "aspects": [
            {
              "text": "Daher würde ich eine abstrakte Klasse wählen",
              "elements": [
                [
                  341,
                  385
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Schnittstellen stellen keine implementierten Methoden bereit",
              "elements": [
                [
                  51,
                  111
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "-",
          "id": "6",
          "answerCategory": "none",
          "correctionOrComment": "-",
          "aspects": []
        },
        {
          "text": "Abstrakte Klasse: da Schnittstellen keine implementierten Methoden bereitstellen.",
          "id": "7",
          "answerCategory": "correct",
          "correctionOrComment": "Man verwendet abstrakte Klassen, da Schnittstellen keine implementierten Methoden bereitstellen.",
          "aspects": [
            {
              "text": "Man verwendet abstrakte Klassen",
              "elements": [
                [
                  0,
                  31
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "a Schnittstellen keine implementierten Methoden bereitstellen",
              "elements": [
                [
                  34,
                  95
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Abstrakte Klasse da Schnittstellen keine Implementierten Methoden bereit stellen.",
          "id": "8",
          "answerCategory": "correct",
          "correctionOrComment": "Man verwendet eine abstrakte Klasse, da Schnittstellen keine implementierten Methoden bereitstellen.",
          "aspects": [
            {
              "text": "Man verwendet eine abstrakte Klasse",
              "elements": [
                [
                  0,
                  35
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "da Schnittstellen keine implementierten Methoden bereitstellen",
              "elements": [
                [
                  37,
                  99
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "ich verwende eine abstrakte Klasse weil aus schnittstelle kann ich keine implementierte Methoden vererben.",
          "id": "9",
          "answerCategory": "correct",
          "correctionOrComment": "Ich verwende eine abstrakte Klasse, weil ich aus Schnittstellen keine implementierte Methoden vererben kann.",
          "aspects": [
            {
              "text": "Ich verwende eine abstrakte Klasse",
              "elements": [
                [
                  0,
                  34
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "weil ich aus Schnittstellen keine implementierte Methoden vererben kann",
              "elements": [
                [
                  36,
                  107
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "eine schnittstelle, weil man die darin enthaltenen methoden vererben kann",
          "id": "10",
          "answerCategory": "missconception",
          "correctionOrComment": "Man verwendet eine Schnittstelle, weil man die darin enthaltenen methoden vererben kann.",
          "aspects": [
            {
              "text": "Man verwendet eine Schnittstelle",
              "elements": [
                [
                  0,
                  32
                ]
              ],
              "aIdx": 0,
              "label": 2
            },
            {
              "text": "weil man die darin enthaltenen methoden vererben kann",
              "elements": [
                [
                  34,
                  87
                ]
              ],
              "aIdx": 1,
              "label": 2
            }
          ]
        },
        {
          "text": "ich verwende eine abstakte Klasse, weil nur in einer abstrakte klasse darf man Variablen deklarieren.",
          "id": "11",
          "answerCategory": "missconception",
          "correctionOrComment": "Ich verwende eine abstakte Klasse, weil man nur in einer abstrakten Klasse Variablen deklarieren darf.",
          "aspects": [
            {
              "text": "Ich verwende eine abstakte Klasse",
              "elements": [
                [
                  0,
                  33
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "",
          "id": "12",
          "answerCategory": "none",
          "correctionOrComment": "",
          "aspects": []
        },
        {
          "text": "eine abstrakte klasse, da in einer schnittstelle die methoden nicht implementiert sein dürfen",
          "id": "13",
          "answerCategory": "correct",
          "correctionOrComment": "Man verwendet eine abstrakte Klasse, da in einer Schnittstelle die Methoden nicht implementiert sein dürfen.",
          "aspects": [
            {
              "text": "Man verwendet eine abstrakte Klasse",
              "elements": [
                [
                  0,
                  35
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "da in einer Schnittstelle die Methoden nicht implementiert sein dürfen",
              "elements": [
                [
                  37,
                  107
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "abstrakte Klasse. Weil sie private ist und sonst nicht verwendet werden kann.",
          "id": "14",
          "answerCategory": "missconception",
          "correctionOrComment": "Man verwendet eine abstrakte Klasse, weil sie 'private' ist und sonst nicht verwendet werden kann.",
          "aspects": [
            {
              "text": "Man verwendet eine abstrakte Klasse",
              "elements": [
                [
                  0,
                  35
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "Bereits implementierte Methoden können nicht mit einer abstrakten Klasse vererbt werden. Daher Schnittstelle.",
          "id": "15",
          "answerCategory": "missconception",
          "correctionOrComment": "Bereits implementierte Methoden können nicht mit einer abstrakten Klasse vererbt werden. Daher verwendet man eine Schnittstelle.",
          "aspects": [
            {
              "text": "Daher verwendet man eine Schnittstelle",
              "elements": [
                [
                  89,
                  127
                ]
              ],
              "aIdx": 0,
              "label": 2
            },
            {
              "text": "Bereits implementierte Methoden können nicht mit einer abstrakten Klasse vererbt werden",
              "elements": [
                [
                  0,
                  87
                ]
              ],
              "aIdx": 1,
              "label": 2
            }
          ]
        },
        {
          "text": "eine abstrakte Klasse, da Schnittstellen keine Datenfelder zurück geben.",
          "id": "16",
          "answerCategory": "missconception",
          "correctionOrComment": "Man verwendet eine abstrakte Klasse, da Schnittstellen keine Datenfelder zurückgeben.",
          "aspects": [
            {
              "text": "Man verwendet eine abstrakte Klasse",
              "elements": [
                [
                  0,
                  35
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "Da Schnittstellen keine Methoden implementieren und deren private deklarierte Variablen nicht vererbt werden, verwende man eine abstrakte Klasse.",
          "id": "17",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Da Schnittstellen keine Methoden implementieren und deren private deklarierte Variablen nicht vererbt werden, verwendet man eine abstrakte Klasse.",
          "aspects": [
            {
              "text": "verwendet man eine abstrakte Klasse",
              "elements": [
                [
                  110,
                  145
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Da Schnittstellen keine Methoden implementieren",
              "elements": [
                [
                  0,
                  47
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Man verwendet eine abstrakte Klasse, da die Schnittstellen nur Konstanten bereitstellen können und die Methoden bei abstrakten Klassen sowohl implementiert, als auch unimplementiert sein können.",
          "id": "18",
          "answerCategory": "correct",
          "correctionOrComment": "Man verwendet eine abstrakte Klasse, da die Schnittstellen nur Konstanten bereitstellen können und die Methoden bei abstrakten Klassen sowohl implementiert, als auch unimplementiert sein können.",
          "aspects": [
            {
              "text": "Man verwendet eine abstrakte Klasse",
              "elements": [
                [
                  0,
                  35
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "Eine abstrakte Klasse, da nur diese Datenfelder vererben kann.",
          "id": "19",
          "answerCategory": "missconception",
          "correctionOrComment": "Man verwendet eine abstrakte Klasse, da nur diese Datenfelder vererben kann.",
          "aspects": [
            {
              "text": "Man verwendet eine abstrakte Klasse",
              "elements": [
                [
                  0,
                  35
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "Es sollte eine abstrakte Klasse verwendet werden. Die abstrakte Klasse füllt die Lücke zwischen der Basisklasse und der Schnittstelle. Mit einer Schnittstelle lassen sich außerdem keine Variablen und auch keine implementierte Methoden vererben.",
          "id": "20",
          "answerCategory": "binary_correct",
          "correctionOrComment": "Es sollte eine abstrakte Klasse verwendet werden. Die abstrakte Klasse füllt die Lücke zwischen der Basisklasse und der Schnittstelle. Mit einer Schnittstelle lassen sich außerdem keine Variablen und auch keine implementierte Methoden vererben.",
          "aspects": [
            {
              "text": "Es sollte eine abstrakte Klasse verwendet werden",
              "elements": [
                [
                  0,
                  48
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Mit einer Schnittstelle lassen sich außerdem ;; keine implementierte Methoden vererben",
              "elements": [
                [
                  135,
                  179
                ],
                [
                  205,
                  243
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Schnittstelle",
          "id": "21",
          "answerCategory": "missconception",
          "correctionOrComment": "Man verwendet ein Schnittstelle.",
          "aspects": [
            {
              "text": "Man verwendet ein Schnittstelle",
              "elements": [
                [
                  0,
                  31
                ]
              ],
              "aIdx": 0,
              "label": 2
            }
          ]
        },
        {
          "text": "Man verwendet eine Schnittstelle da abstrakte Klassen unimplementierte methoden enthalten können.",
          "id": "22",
          "answerCategory": "missconception",
          "correctionOrComment": "Man verwendet eine Schnittstelle, da abstrakte Klassen unimplementierte Methoden enthalten können.",
          "aspects": [
            {
              "text": "Man verwendet eine Schnittstelle",
              "elements": [
                [
                  0,
                  32
                ]
              ],
              "aIdx": 0,
              "label": 2
            }
          ]
        },
        {
          "text": "Die Verwendung einer abstrakten Klasse ist hier sinnvoller, da die bereits implementierten Methoden erhalten bleiben sollten, was bei einer Schnittstelle nicht möglich ist.",
          "id": "23",
          "answerCategory": "correct",
          "correctionOrComment": "Die Verwendung einer abstrakten Klasse ist hier sinnvoller, da die bereits implementierten Methoden erhalten bleiben, was bei einer Schnittstelle nicht möglich ist.",
          "aspects": [
            {
              "text": "Die Verwendung einer abstrakten Klasse ist hier sinnvoller",
              "elements": [
                [
                  0,
                  58
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "da die bereits implementierten Methoden erhalten bleiben, was bei einer Schnittstelle nicht möglich ist",
              "elements": [
                [
                  60,
                  163
                ]
              ],
              "aIdx": 1,
              "label": 1
            }
          ]
        },
        {
          "text": "Ich verwende eine abstrakte Klasse, da man in einer Schnittstelle Methoden nur deklarieren kann und noch nicht implementieren. Außerdem kann man in einer Schnittstelle nur Konstanten verwenden.",
          "id": "24",
          "answerCategory": "correct",
          "correctionOrComment": "Ich verwende eine abstrakte Klasse, da man in einer Schnittstelle Methoden nur deklarieren kann und noch nicht implementieren. Außerdem kann man in einer Schnittstelle nur Konstanten verwenden.",
          "aspects": [
            {
              "text": "Ich verwende eine abstrakte Klasse",
              "elements": [
                [
                  0,
                  34
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "da man in einer Schnittstelle Methoden nur deklarieren kann und noch nicht implementieren",
              "elements": [
                [
                  36,
                  125
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "eine abstrakte Klasse, da in einer Schnittstelle nur die Methoden deklariert werden und keine variablen.",
          "id": "25",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Man verwendet eine abstrakte Klasse, da in einer Schnittstelle nur die Methoden deklariert werden und keine Variablen.",
          "aspects": [
            {
              "text": "Man verwendet eine abstrakte Klasse",
              "elements": [
                [
                  0,
                  35
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "Ich verwende eine abstrakte Klasse, da mit dieser problemlos Datenfelder vererbt werden können die nicht konstant sind.",
          "id": "26",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Ich verwende eine abstrakte Klasse, da mit dieser problemlos Datenfelder vererbt werden können, die nicht konstant sind.",
          "aspects": [
            {
              "text": "Ich verwende eine abstrakte Klasse",
              "elements": [
                [
                  0,
                  34
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "ich verwende eine abstrakte Klasse, da die abstrakte Klasse Datenfelder bereitstellen kann und Schnittstellen nur konstante. Die Abstrakte Klasse veerbt implementierte Methoden. Schnittstellen stellen keine implementierte Methoden bereit.",
          "id": "27",
          "answerCategory": "correct",
          "correctionOrComment": "Ich verwende eine abstrakte Klasse, da die abstrakte Klasse Datenfelder bereitstellen kann und Schnittstellen nur Konstanten. Die Abstrakte Klasse vererbt implementierte Methoden. Schnittstellen stellen keine implementierten Methoden bereit.",
          "aspects": [
            {
              "text": "Ich verwende eine abstrakte Klasse",
              "elements": [
                [
                  0,
                  34
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Schnittstellen stellen keine implementierten Methoden bereit",
              "elements": [
                [
                  180,
                  240
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Abstrakte Klassen. Diese Klassen sind spezielle Klassen die viele abstrakte Methoden beinhalten. Entweder abgeleitete Klassen müssen abstract sein oder die abstrakte Methoden sind in dem Fall implementiert.",
          "id": "28",
          "answerCategory": "binary_correct",
          "correctionOrComment": "Man verwendet abstrakte Klassen. Diese Klassen sind spezielle Klassen, die viele abstrakte Methoden beinhalten. Entweder müssen abgeleitete Klassen 'abstract' sein oder die abstrakte Methoden sind in dem Fall implementiert.",
          "aspects": [
            {
              "text": "Man verwendet abstrakte Klassen",
              "elements": [
                [
                  0,
                  31
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "abstrakte Klasse",
          "id": "29",
          "answerCategory": "guessing",
          "correctionOrComment": "Man verwendet eine abstrakte Klasse.",
          "aspects": [
            {
              "text": "Man verwendet eine abstrakte Klasse",
              "elements": [
                [
                  0,
                  35
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "Man ver wendet eine abstrakte Klasse, weil Schnittstellen nur Konstanten breitstellen.",
          "id": "30",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Man verwendet eine abstrakte Klasse, weil Schnittstellen nur Konstanten breitstellen.",
          "aspects": [
            {
              "text": "Man verwendet eine abstrakte Klasse",
              "elements": [
                [
                  0,
                  35
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "Eine Klasse kann nur eine Basisklasse haben, aber beliebige Schnittsctellen implementieren. Deshalb Schnittstelle.",
          "id": "31",
          "answerCategory": "missconception",
          "correctionOrComment": "Eine Klasse kann nur eine Basisklasse haben, aber beliebige Schnittstellen implementieren. Deshalb verwendet man eine Schnittstelle.",
          "aspects": [
            {
              "text": "Deshalb verwendet man eine Schnittstelle",
              "elements": [
                [
                  91,
                  131
                ]
              ],
              "aIdx": 0,
              "label": 2
            }
          ]
        },
        {
          "text": "eine anstrakte Klassse denn abtrakte Klassen können implementiere Methoden enthalten und wenn eine abtrakte Klasse abgeleitet wird, müssen die abtrakt markierten Methoden implementiert werden. um eine private deklarierte Variable zu vererben braucht man auf jeden fall getter und setter. Deshalb verwendet man eine abtrakte Klasse",
          "id": "32",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Man verwendet eine anstrakte Klassse, denn abtrakte Klassen können implementiere Methoden enthalten und wenn eine abtrakte Klasse abgeleitet wird, müssen die abtrakt markierten Methoden implementiert werden. Um eine 'private' deklarierte Variable zu vererben braucht man auf jeden fall Getter und Setter. Deshalb verwendet man eine abtrakte Klasse.",
          "aspects": [
            {
              "text": "Man verwendet eine anstrakte Klassse",
              "elements": [
                [
                  0,
                  36
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "denn abtrakte Klassen können implementiere Methoden enthalten",
              "elements": [
                [
                  38,
                  99
                ]
              ],
              "aIdx": 1,
              "label": 1
            }
          ]
        },
        {
          "text": "eine abstrakte weil die basis klassen können datenfelder bereitstellen aber die schnittstellen nur konstanten Baisklassen vererben nur implementierte methoden. PS man kann keine konkrete objekte erzeugen.",
          "id": "33",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Man verwendet eine abstrakte Klasse, weil die Basisklassen Datenfelder bereitstellen können Schnittstellen aber  nur Konstanten. Baisklassen vererben nur implementierte Methoden.",
          "aspects": [
            {
              "text": "Man verwendet eine abstrakte Klasse",
              "elements": [
                [
                  0,
                  35
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "Ich verwende eine abstrakte Klasse: Impl. Methoden können verwendet werden. Bei Schnittstellen können Methoden nicht Impl.",
          "id": "34",
          "answerCategory": "correct",
          "correctionOrComment": "Ich verwende eine abstrakte Klasse, weil dort implementierte Methoden verwendet werden können. Bei Schnittstellen können Methoden nicht implementiert vererbt werden.",
          "aspects": [
            {
              "text": "Ich verwende eine abstrakte Klasse",
              "elements": [
                [
                  0,
                  34
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Bei Schnittstellen können Methoden nicht implementiert vererbt werden",
              "elements": [
                [
                  95,
                  164
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "mit Schnittstelle werden wir \"\"Implement\"\"benutzen ,weil die schnittstelle alle benötige Informationen beihaltet. Mit Abstrakte Klassen auf grund der kapselung von Intanzen.",
          "id": "35",
          "answerCategory": "missconception",
          "correctionOrComment": "Wir werden Schnittstellen mit 'implements' benutzen, weil die Schnittstelle alle benötigten Informationen beinhaltet.",
          "aspects": [
            {
              "text": "Wir werden Schnittstellen mit 'implements' benutzen",
              "elements": [
                [
                  0,
                  51
                ]
              ],
              "aIdx": 0,
              "label": 2
            },
            {
              "text": "weil die Schnittstelle alle benötigten Informationen beinhaltet",
              "elements": [
                [
                  53,
                  116
                ]
              ],
              "aIdx": 1,
              "label": 2
            }
          ]
        },
        {
          "text": "Ich verwende eine abstrakte Klasse, da diese implementierte Methoden enthalten darf und private Variablen erlaubt sind. Selbst wenn manche Methoden mit abstract gekennzeichnet sind, ist es erlaubt, die abstrakte Klasse zu vererben, wenn alle mit abstact gekennzeichneten Methoden implementiert sind. Wenn es eine abstrakte Methode gibt, die nicht implementiert ist, muss die abgeleitete Klasse auch abstract sein, was in diesem Fall aber nicht so ist.",
          "id": "36",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Ich verwende eine abstrakte Klasse, da diese implementierte Methoden enthalten darf und 'private' Variablen erlaubt sind. Selbst wenn manche Methoden mit 'abstract' gekennzeichnet sind, ist es erlaubt die abstrakte Klasse zu vererben, wenn alle mit 'abstract' gekennzeichneten Methoden implementiert sind. Wenn es eine abstrakte Methode gibt, die nicht implementiert ist, muss die abgeleitete Klasse auch 'abstract' sein, was in diesem Fall aber nicht so ist.",
          "aspects": [
            {
              "text": "Ich verwende eine abstrakte Klasse",
              "elements": [
                [
                  0,
                  34
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "da diese implementierte Methoden enthalten darf",
              "elements": [
                [
                  36,
                  83
                ]
              ],
              "aIdx": 1,
              "label": 1
            }
          ]
        },
        {
          "text": "ich verwende eine Abstrakte klasse, da ich ich Methoden Implementieren will und eine schnittstelle keine Implementierung erlaubt und die private variable ist auch ein hinweis darauf, da man auf sie mit einem Getter zugreifen muss",
          "id": "37",
          "answerCategory": "correct",
          "correctionOrComment": "Ich verwende eine abstrakte Klasse, da ich Methoden implementieren will und eine Schnittstelle keine Implementierung erlaubt. Die 'private' Variable ist auch ein Hinweis darauf, dass man auf sie mit einem Getter zugreifen muss.",
          "aspects": [
            {
              "text": "Ich verwende eine abstrakte Klasse",
              "elements": [
                [
                  0,
                  34
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "da ;; eine Schnittstelle keine Implementierung erlaubt",
              "elements": [
                [
                  36,
                  38
                ],
                [
                  76,
                  124
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Man verwendet dafür eine abstrakte Klasse. Da abstrakte Klassen nicht nur Mehtoden implementiern können sondern auch Datenfelder.",
          "id": "38",
          "answerCategory": "binary_correct",
          "correctionOrComment": "Man verwendet dafür eine abstrakte Klasse, da abstrakte Klassen nicht nur Mehtoden implementiern können sondern auch Datenfelder.",
          "aspects": [
            {
              "text": "Man verwendet dafür eine abstrakte Klasse",
              "elements": [
                [
                  0,
                  41
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "Man verwendet eine abstrakte Klasse, da Schnittstellen keine implementierte Methoden bereitstellen.",
          "id": "39",
          "answerCategory": "correct",
          "correctionOrComment": "Man verwendet eine abstrakte Klasse, da Schnittstellen keine implementierten Methoden bereitstellen.",
          "aspects": [
            {
              "text": "Man verwendet eine abstrakte Klasse",
              "elements": [
                [
                  0,
                  35
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "da Schnittstellen keine implementierten Methoden bereitstellen",
              "elements": [
                [
                  37,
                  99
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "eine abstrakte Klasse da Schnittstellen eher für das implementieren für Methoden zuständig sind.",
          "id": "40",
          "answerCategory": "missconception",
          "correctionOrComment": "Man verwendet eine abstrakte Klasse, da Schnittstellen eher für das implementieren von Methoden zuständig sind.",
          "aspects": [
            {
              "text": "Man verwendet eine abstrakte Klasse",
              "elements": [
                [
                  0,
                  35
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "da Schnittstellen eher für das implementieren von Methoden zuständig sind",
              "elements": [
                [
                  37,
                  110
                ]
              ],
              "aIdx": 1,
              "label": 2
            }
          ]
        },
        {
          "text": "Man nimmt eine abstrakte Klasse, da Schnittstellen nur Konstanten vererben können.",
          "id": "41",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Man nimmt eine abstrakte Klasse, da Schnittstellen nur Konstanten vererben können.",
          "aspects": [
            {
              "text": "Man nimmt eine abstrakte Klasse",
              "elements": [
                [
                  0,
                  31
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "Eine Schnittstelle, bei einer abstrakten Klasse darf man nicht inistanzieieren.",
          "id": "42",
          "answerCategory": "missconception",
          "correctionOrComment": "Man verwendet eine Schnittstelle, weil man bei einer abstrakten Klasse nicht instanziieren darf.",
          "aspects": [
            {
              "text": "Man verwendet eine Schnittstelle",
              "elements": [
                [
                  0,
                  32
                ]
              ],
              "aIdx": 0,
              "label": 2
            }
          ]
        },
        {
          "text": "Eine abstrakte Klasse, da Methoden in einer Schnittstelle nicht implementiert sein dürfen.",
          "id": "43",
          "answerCategory": "correct",
          "correctionOrComment": "Man nimmt eine abstrakte Klasse, da Methoden in einer Schnittstelle nicht implementiert sein dürfen.",
          "aspects": [
            {
              "text": "Man nimmt eine abstrakte Klasse",
              "elements": [
                [
                  0,
                  31
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "da Methoden in einer Schnittstelle nicht implementiert sein dürfen",
              "elements": [
                [
                  33,
                  99
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Abstrakte Klassen, denn sie können bereits implementierte Methoden beinhalten, Schnittstellen sind nicht implementiert.",
          "id": "44",
          "answerCategory": "correct",
          "correctionOrComment": "Man verwendet abstrakte Klassen, denn sie können bereits implementierte Methoden beinhalten. Methoden in Schnittstellen sind nicht implementiert.",
          "aspects": [
            {
              "text": "Man verwendet abstrakte Klassen",
              "elements": [
                [
                  0,
                  31
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Methoden in Schnittstellen sind nicht implementiert",
              "elements": [
                [
                  93,
                  144
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "-",
          "id": "45",
          "answerCategory": "none",
          "correctionOrComment": "-",
          "aspects": []
        },
        {
          "text": "-",
          "id": "46",
          "answerCategory": "none",
          "correctionOrComment": "-",
          "aspects": []
        },
        {
          "text": "eine abstrakte klasse weil es um merere methoden geht die private seien sollen",
          "id": "47",
          "answerCategory": "missconception",
          "correctionOrComment": "Man nimmt eine abstrakte Klasse, weil es um mehrere Methoden geht die 'private' seien sollen.",
          "aspects": [
            {
              "text": "Man nimmt eine abstrakte Klasse",
              "elements": [
                [
                  0,
                  31
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "Schnittstelle",
          "id": "48",
          "answerCategory": "guessing",
          "correctionOrComment": "Man nimmt eine Schnittstelle.",
          "aspects": [
            {
              "text": "Man nimmt eine Schnittstelle",
              "elements": [
                [
                  0,
                  28
                ]
              ],
              "aIdx": 0,
              "label": 2
            }
          ]
        },
        {
          "text": "Eine Abstrakte Klasse, weil diese auch auf private deklarierte Variable und Methoden zugreifen kann.",
          "id": "49",
          "answerCategory": "missconception",
          "correctionOrComment": "Man nimmt eine abstrakte Klasse, weil diese auch auf 'private' deklarierte Variablen und Methoden zugreifen kann.",
          "aspects": [
            {
              "text": "Man nimmt eine abstrakte Klasse",
              "elements": [
                [
                  0,
                  31
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "Man verwendet eine abstrakte Klasse, da Schnittstellen keine implementierte Methoden zur Verfügung stellen.",
          "id": "50",
          "answerCategory": "correct",
          "correctionOrComment": "Man verwendet eine abstrakte Klasse, da Schnittstellen keine implementierten Methoden zur Verfügung stellen.",
          "aspects": [
            {
              "text": "Man verwendet eine abstrakte Klasse",
              "elements": [
                [
                  0,
                  35
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "da Schnittstellen keine implementierten Methoden zur Verfügung stellen",
              "elements": [
                [
                  37,
                  107
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "-",
          "id": "51",
          "answerCategory": "none",
          "correctionOrComment": "-",
          "aspects": []
        },
        {
          "text": "eine abstrakte Klasse weil die Unterklassen von ihr erben.",
          "id": "52",
          "answerCategory": "missconception",
          "correctionOrComment": "Man nimmt eine abstrakte Klasse, weil die Unterklassen von ihr erben.",
          "aspects": [
            {
              "text": "Man nimmt eine abstrakte Klasse",
              "elements": [
                [
                  0,
                  31
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "Ich würde eine Schnittstelle benutzen.",
          "id": "53",
          "answerCategory": "guessing",
          "correctionOrComment": "Ich würde eine Schnittstelle benutzen.",
          "aspects": [
            {
              "text": "Ich würde eine Schnittstelle benutzen",
              "elements": [
                [
                  0,
                  37
                ]
              ],
              "aIdx": 0,
              "label": 2
            }
          ]
        },
        {
          "text": "eine Abstrakte, da bei der Schnittstelle man ,nach der Vererbung, die Methoden noch implementieren muss.",
          "id": "54",
          "answerCategory": "correct",
          "correctionOrComment": "Man nimmt eine abstrakte Klasse, da man bei der Schnittstelle die Methoden nach der Vererbung noch implementieren muss.",
          "aspects": [
            {
              "text": "Man nimmt eine abstrakte Klasse",
              "elements": [
                [
                  0,
                  31
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "da man bei der Schnittstelle die Methoden nach der Vererbung noch implementieren muss",
              "elements": [
                [
                  33,
                  118
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Eine abstrake Klasse da die Methoden implementiert sein sollen.",
          "id": "55",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Eine abstrake Klasse, da die Methoden implementiert sein sollen.",
          "aspects": [
            {
              "text": "Eine abstrake Klasse",
              "elements": [
                [
                  0,
                  20
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "Abstrakte Klasse: die privat deklarierte Variable ist nur in einer Klasse sichtbar.",
          "id": "56",
          "answerCategory": "missconception",
          "correctionOrComment": "Man nimmt eine abstrakte Klasse, da die privat deklarierte Variable nur in einer Klasse sichtbar ist.",
          "aspects": [
            {
              "text": "Man nimmt eine abstrakte Klasse",
              "elements": [
                [
                  0,
                  31
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        }
      ]
    },
    {
      "id": "13",
      "text": "Erklären Sie den Zusammenhang zwischen Klassen und Objekten.",
      "title": "Zusammenhang zwischen Klassen und Objekten",
      "type": "comparison",
      "aspects": [
        {
          "text": "Eine Klasse ist der Bauplan für ein Objekt"
        },
        {
          "text": "Ein Objekt ist eine konkrete Instanz einer Klasse"
        }
      ],
      "referenceAnswers": [
        {
          "id": "ref1",
          "text": "Eine Klasse ist der Bauplan für ein Objekt. Ein Objekt ist eine konkrete Instanz einer Klasse.",
          "aspects": [
            {
              "text": "Eine Klasse ist der Bauplan für ein Objekt",
              "aIdx": 0,
              "elements": [
                [
                  0,
                  42
                ]
              ],
              "label": 0
            },
            {
              "text": "Ein Objekt ist eine konkrete Instanz einer Klasse",
              "aIdx": 1,
              "elements": [
                [
                  44,
                  93
                ]
              ],
              "label": 0
            }
          ]
        }
      ],
      "studentAnswers": [
        {
          "text": "Alle Objekte haben einen Bauplan und dieser Bauplan des Objektes ist die klasse. Objekte haben den Typ ihrer Klasse. Die Klasse eines Objekte ist wie bei uns Menschen die DNA. Die Klasse bestimmt Aussehen und Eigenschaften. Aber ist selber nicht das Objekt.",
          "id": "61",
          "answerCategory": "binary_correct",
          "correctionOrComment": "Alle Objekte haben einen Bauplan und dieser Bauplan des Objektes ist die Klasse. Objekte haben den Typ ihrer Klasse. Die Klasse eines Objekte ist wie bei uns Menschen die DNA. Die Klasse bestimmt Aussehen und Eigenschaften, aber ist selber nicht das Objekt.",
          "aspects": [
            {
              "text": "Alle Objekte haben einen Bauplan und dieser Bauplan des Objektes ist die Klasse",
              "elements": [
                [
                  0,
                  79
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Objekte haben den Typ ihrer Klasse",
              "elements": [
                [
                  81,
                  115
                ]
              ],
              "aIdx": 1,
              "label": 1
            }
          ]
        },
        {
          "text": "alle objekte entstehen durch einen Bauplan. Dieser Bauplan ist die Klasse des Objektes, das Objekt ist eine Instanz der Klasse. Objekte haben ihren typ in der klasse. Die Klasseeines objektes ist für das objekt ca das selbe wie die DNA für den menschen. -sie bestimmt aussehen und eigenschaft. ist aber selbst nicht das Objekt.",
          "id": "62",
          "answerCategory": "correct",
          "correctionOrComment": "Alle Objekte entstehen durch einen Bauplan. Dieser Bauplan ist die Klasse des Objektes. Das Objekt ist eine Instanz der Klasse. Objekte haben ihren Typ in der Klasse. Die Klasse eines Objektes ist für das Objekt ungefähr dasselbe, wie die DNA für den Menschen. Sie bestimmt Aussehen und Eigenschaften sind aber nicht selbst das Objekt.",
          "aspects": [
            {
              "text": "Alle Objekte entstehen durch einen Bauplan. Dieser Bauplan ist die Klasse des Objektes",
              "elements": [
                [
                  0,
                  86
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Das Objekt ist eine Instanz der Klasse",
              "elements": [
                [
                  88,
                  126
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "objekt ist zum bsp ein bauplan und der Bauplan wäre in dem fall eine Klasse. Klassen sind bestimmte themen berreiche bsp auch Autos und objekt wäre in dem fall ein",
          "id": "63",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Ein Objekt ist zum Beispiel ein Bauplan und der Bauplan wäre in dem Fall eine Klasse. Klassen sind bestimmte Themenbereiche.",
          "aspects": [
            {
              "text": "Ein Objekt ist zum Beispiel ein Bauplan und der Bauplan wäre in dem Fall eine Klasse",
              "elements": [
                [
                  0,
                  84
                ]
              ],
              "aIdx": 0,
              "label": 2
            }
          ]
        },
        {
          "text": "Die Klassen sind der Bauplan von Objekten. Objekte kann man sich selber zulegen indem man sie mit \"\"new\"\" neu definiert.",
          "id": "64",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Die Klassen sind der Bauplan von Objekten. Objekte kann man sich selber zulegen, indem man sie mit 'new' neu definiert.",
          "aspects": [
            {
              "text": "Die Klassen sind der Bauplan von Objekten",
              "elements": [
                [
                  0,
                  41
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "Die Klasse ist der Bauplan für das Objekt, heißt das Objekt ist eine Instanz der Klasse. In der Klasse wird das Gerüst aufgebaut auf das sich das Objekt bezieht und hier die Fähigkeiten definiert werden bzw. Objekte haben den Typ ihrer Klasse",
          "id": "65",
          "answerCategory": "correct",
          "correctionOrComment": "Die Klasse ist der Bauplan für das Objekt. Das heißt, das Objekt ist eine Instanz der Klasse. In der Klasse wird das Gerüst aufgebaut auf das sich das Objekt bezieht und die Fähigkeiten werden definiert. Objekte haben den Typ ihrer Klasse.",
          "aspects": [
            {
              "text": "Die Klasse ist der Bauplan für das Objekt",
              "elements": [
                [
                  0,
                  41
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Das heißt, das Objekt ist eine Instanz der Klasse",
              "elements": [
                [
                  43,
                  92
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Objekt wird durch seine Klasse definiert. Die Klasse ist der Bauplan für das Objekt. Bauplan = Klasse des Objektes und Objekt = Instanz der Klasse. Objekte haben die Typen der Klasse Code der klasse legt die Eigenschaften der Objekte fest",
          "id": "66",
          "answerCategory": "correct",
          "correctionOrComment": "Ein Objekt wird durch seine Klasse definiert. Die Klasse ist der Bauplan für das Objekt. Der Bauplan ist die Klasse des Objektes und das Objekt ist die Instanz der Klasse. Objekte haben die Typen der Klasse. Der Code der Klasse legt die Eigenschaften der Objekte fest.",
          "aspects": [
            {
              "text": "Ein Objekt wird durch seine Klasse definiert. Die Klasse ist der Bauplan für das Objekt",
              "elements": [
                [
                  0,
                  87
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "das Objekt ist die Instanz der Klasse",
              "elements": [
                [
                  133,
                  170
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Die Klasse eines Objektes ist für das Objekt wie die DNA für den Menschen: Klasse bestimmt aussehen und Eigenschaften aber ist nicht selbst das Objekt. Objekte entstehen durch eine Art Bauplan. Der Bauplan ist die Klasse eines Objekts",
          "id": "67",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Die Klasse eines Objektes ist für das Objekt wie die DNA für den Menschen. Die Klasse bestimmt Aussehen und Eigenschaften aber ist nicht selbst das Objekt. Objekte entstehen durch eine Art Bauplan. Der Bauplan ist die Klasse eines Objekts.",
          "aspects": [
            {
              "text": "Der Bauplan ist die Klasse eines Objekts",
              "elements": [
                [
                  198,
                  238
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "Klassen sind der Bauplan von Objekten. Objekte entstehen mit new.",
          "id": "68",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Klassen sind der Bauplan von Objekten. Objekte entstehen mit 'new'.",
          "aspects": [
            {
              "text": "Klassen sind der Bauplan von Objekten",
              "elements": [
                [
                  0,
                  37
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "Die Klasse des Objektes ist für das Objekt in etwa wie die DNA beim Menschen. Sie bestimmt Aussehen und Eigenschaften des Objekts, aber die Klasse ist nicht das Objekt selbst, von jeder Klasse kann auch ein Objekt erstellt werden.",
          "id": "69",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Die Klasse des Objektes ist für das Objekt in etwa wie die DNA beim Menschen. Sie bestimmt Aussehen und Eigenschaften des Objekts, aber die Klasse ist nicht das Objekt selbst. Von jeder Klasse kann auch ein Objekt erstellt werden.",
          "aspects": [
            {
              "text": "Die Klasse des Objektes ist für das Objekt in etwa wie die DNA beim Menschen. Sie bestimmt Aussehen und Eigenschaften des Objekts",
              "elements": [
                [
                  0,
                  129
                ]
              ],
              "aIdx": 0,
              "label": 1
            }
          ]
        },
        {
          "text": "Eine Klasse ist wie eine Art Bauplan für den Objekt . Ein Objekt ist ein Instanz der Klasse und enthält die Element wie in der Klasse",
          "id": "70",
          "answerCategory": "correct",
          "correctionOrComment": "Eine Klasse ist wie eine Art Bauplan für ein Objekt . Ein Objekt ist eine Instanz der Klasse und enthält die Elemente wie in der Klasse.",
          "aspects": [
            {
              "text": "Eine Klasse ist wie eine Art Bauplan für ein Objekt",
              "elements": [
                [
                  0,
                  51
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Ein Objekt ist eine Instanz der Klasse",
              "elements": [
                [
                  54,
                  92
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "eine klasee ist wie baustein fuer die objektealle Faehigkeiten des objektes werden durch die Klasse definiert.",
          "id": "71",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Eine Klasse ist wie ein Baustein für die Objekte. Alle Fähigkeiten des Objektes werden durch die Klasse definiert.",
          "aspects": [
            {
              "text": "Eine Klasse ist wie ein Baustein für die Objekte",
              "elements": [
                [
                  0,
                  48
                ]
              ],
              "aIdx": 0,
              "label": 1
            },
            {
              "text": "Alle Fähigkeiten des Objektes werden durch die Klasse definiert",
              "elements": [
                [
                  50,
                  113
                ]
              ],
              "aIdx": 1,
              "label": 1
            }
          ]
        },
        {
          "text": "Alle Objekte entstehen durch einen Bauplan Dieser Bauplan ist die Klasse des Objektes, das Objekt ist eine Instanz der Klasse. Objekte haben den Typ ihrer Klasse Die Klasse eines Objektes ist für das Objekt in etwa dasselbe wie die DNA für den Menschen Sie besto,,t aussehen und eigenschaften ABER SIE selbst ist nicht das objekt",
          "id": "72",
          "answerCategory": "correct",
          "correctionOrComment": "Alle Objekte entstehen durch einen Bauplan. Dieser Bauplan ist die Klasse des Objektes. Das Objekt ist eine Instanz der Klasse. Objekte haben den Typ ihrer Klasse. Die Klasse eines Objektes ist für das Objekt in etwa dasselbe wie die DNA für den Menschen. Sie bestimmt aussehen und Eigenschaften, aber sie selbst ist nicht das Objekt.",
          "aspects": [
            {
              "text": "Alle Objekte entstehen durch einen Bauplan. Dieser Bauplan ist die Klasse des Objektes",
              "elements": [
                [
                  0,
                  86
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Das Objekt ist eine Instanz der Klasse",
              "elements": [
                [
                  88,
                  126
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Die Klasse ist übergeordnet. zum beispiel ist ein objekt eine instanz 7 eine eigenschaft der klasse.",
          "id": "73",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Die Klasse ist übergeordnet. Ein Objekt ist zum Beispiel eine Instanz. 7 ist eine Eigenschaft der Klasse.",
          "aspects": []
        },
        {
          "text": "In der Klasse wird der Code generiert und koppelt die Daten und die Funktion im Objekt. Somit ist die Klasse der Bauplan vom Objekt.",
          "id": "74",
          "answerCategory": "partially_correct",
          "correctionOrComment": "In der Klasse wird der Code generiert und koppelt die Daten und die Funktionen im Objekt. Somit ist die Klasse der Bauplan vom Objekt.",
          "aspects": [
            {
              "text": "Somit ist die Klasse der Bauplan vom Objekt",
              "elements": [
                [
                  90,
                  133
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "Eine Klasse ist ein Bauplan für dessen Objekte. Über den Klassennamen wird das Objekt instanziiert, z.B. Auto auto = new Auto() SEMICOLON Innerhalb der runden Klammern kann man nun, sofern im Konstruktor der Klasse Auto angelegt, schon Attribute übergeben, z.B. Auto auto = new Auto(\"\"Ferrari\"\") SEMICOLON Die Klasse legt also die Eigenschaften eines Objektes fest. (Bei Frage 2 wusste ich nicht ob auf oder absteigend, da die Zeilennummern anders herum da stehen. Ich habe in Zeile 3 den ersten Schritt geschrieben, Zeile 2 den zweiten und Zeile 1 den letzten)",
          "id": "75",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Eine Klasse ist ein Bauplan für dessen Objekte. Über den Klassennamen wird das Objekt instanziiert. Innerhalb der runden Klammern kann man nun sofern im Konstruktor der Klasse angelegt, schon Attribute übergeben. Die Klasse legt also die Eigenschaften eines Objektes fest.",
          "aspects": [
            {
              "text": "Eine Klasse ist ein Bauplan für dessen Objekte",
              "elements": [
                [
                  0,
                  46
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Über den Klassennamen wird das Objekt instanziiert",
              "elements": [
                [
                  48,
                  98
                ]
              ],
              "aIdx": 1,
              "label": 1
            }
          ]
        },
        {
          "text": "Klasse ist der Bauplan für ein Objekt. Das Objekt ist eine Instanz. Die Klasse enthält die wichtigsten \"\"Oberbegriffe\"\" für ein Objekt. Damit kann man viele Klassen anlegen und diese in einer Main-Methode zusammenfügen.",
          "id": "76",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Die Klasse ist der Bauplan für ein Objekt. Das Objekt ist eine Instanz. Die Klasse enthält die wichtigsten Oberbegriffe für ein Objekt. Damit kann man viele Klassen anlegen und diese in einer 'main' Methode zusammenfügen.",
          "aspects": [
            {
              "text": "Die Klasse ist der Bauplan für ein Objekt",
              "elements": [
                [
                  0,
                  41
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Das Objekt ist eine Instanz",
              "elements": [
                [
                  43,
                  70
                ]
              ],
              "aIdx": 1,
              "label": 1
            }
          ]
        },
        {
          "text": "Die Klasse ist der Bauplan des Objektes. Sie enthält die Attribute/Eigenschaften des Objektes. Ein Beispiel in der realen Welt für eine Klasse wäre die DNA des Objektes Mensch.",
          "id": "77",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Die Klasse ist der Bauplan des Objektes. Sie enthält die Attribute und Eigenschaften des Objektes. Ein Beispiel in der realen Welt für eine Klasse wäre die DNA des Objektes Mensch.",
          "aspects": [
            {
              "text": "Die Klasse ist der Bauplan des Objektes",
              "elements": [
                [
                  0,
                  39
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "Eine Klasse kann in mehreren Objekten sein, andersrum jedoch nicht.Verschiedene Klassen ergeben/definieren ein Objekt.",
          "id": "78",
          "answerCategory": "missconception",
          "correctionOrComment": "Eine Klasse kann in mehreren Objekten sein, andersrum jedoch nicht. Verschiedene Klassen ergeben und definieren ein Objekt.",
          "aspects": []
        },
        {
          "text": "Klassen bilden eine Anleitung für Objekte. Ein Objekt ist eine Instanz einer Klasse. Eine Klasse beschreibt die Methoden die auf ein Objekt angewendet werden können.",
          "id": "79",
          "answerCategory": "correct",
          "correctionOrComment": "Klassen bilden eine Anleitung für Objekte. Ein Objekt ist eine Instanz einer Klasse. Eine Klasse beschreibt die Methoden, die auf ein Objekt angewendet werden können.",
          "aspects": [
            {
              "text": "Klassen bilden eine Anleitung für Objekte",
              "elements": [
                [
                  0,
                  41
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Ein Objekt ist eine Instanz einer Klasse.",
              "elements": [
                [
                  43,
                  84
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Die Klasse eines Objektes ist wie die DNA eines Menschen.",
          "id": "80",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Die Klasse eines Objektes ist wie die DNA eines Menschen.",
          "aspects": []
        },
        {
          "text": "Der Code einer Klasse legt die Eigenschaft der Objekte fest",
          "id": "81",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Der Code einer Klasse legt die Eigenschaft der Objekte fest.",
          "aspects": []
        },
        {
          "text": "Klassen sind der Bauplan von Objekten. In Klassen werden die Attribute von Objekten beschrieben",
          "id": "82",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Klassen sind der Bauplan von Objekten. In Klassen werden die Attribute von Objekten beschrieben.",
          "aspects": [
            {
              "text": "Klassen sind der Bauplan von Objekten",
              "elements": [
                [
                  0,
                  37
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "Die Objekte sind Baupläne für das Programm. Die Klassen beinhalten diese Objekte und verwenden sie.",
          "id": "83",
          "answerCategory": "missconception",
          "correctionOrComment": "Die Objekte sind Baupläne für das Programm. Die Klassen beinhalten diese Objekte und verwenden sie.",
          "aspects": []
        },
        {
          "text": "Die Klasse ist der \"\"Plan\"\" für das Projekt, dort steht was mit den erstellten Projekten \"\"gemacht\"\" wird. Das heißt Sie beinhalten die Objekte und verwenden sie. Die Objekte werden erzeugt, um für eine Art mehrere Eigenschaften zu speichern, die dann in der Klasse aufgerufen werden können.",
          "id": "84",
          "answerCategory": "missconception",
          "correctionOrComment": "Die Klasse ist der Plan für das Projekt. Dort steht was mit den erstellten Projekten gemacht wird. Das heißt, sie beinhalten die Objekte und verwenden sie. Die Objekte werden erzeugt, um für eine Art mehrere Eigenschaften zu speichern, die dann in der Klasse aufgerufen werden können.",
          "aspects": []
        },
        {
          "text": "Objekte sind Baupläne für das Programm. Die Klassen sind deren Inhalte und werden von Objekten verwendet",
          "id": "85",
          "answerCategory": "missconception",
          "correctionOrComment": "Objekte sind Baupläne für das Programm. Die Klassen sind deren Inhalte und werden von Objekten verwendet.",
          "aspects": []
        },
        {
          "text": "Klassen sind vordefinierte Objekte",
          "id": "86",
          "answerCategory": "missconception",
          "correctionOrComment": "Klassen sind vordefinierte Objekte.",
          "aspects": []
        },
        {
          "text": "Objekte haben den typ ihrer klasse alle Objekte haben einen Bauplan dieser Bauplan ist die klasse des objektes das objekt ist das Instanz einer klasse",
          "id": "87",
          "answerCategory": "correct",
          "correctionOrComment": "Objekte haben den Typ ihrer Klasse. Alle Objekte haben einen Bauplan. Dieser Bauplan ist die Klasse des Objektes. Das Objekt ist die Instanz einer Klasse.",
          "aspects": [
            {
              "text": "Alle Objekte haben einen Bauplan. Dieser Bauplan ist die Klasse des Objektes",
              "elements": [
                [
                  36,
                  112
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Das Objekt ist die Instanz einer Klasse",
              "elements": [
                [
                  114,
                  153
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Die Klasse ist das Bauplan für das Objekt. Objekt ist das instanz der Klasse . Klasse bestimmt Eigenschaften des Objekts aber sie ist nicht das Objekt.",
          "id": "88",
          "answerCategory": "correct",
          "correctionOrComment": "Die Klasse ist der Bauplan für das Objekt. Das Objekt ist die Instanz der Klasse. Eine Klasse bestimmt die Eigenschaften des Objekts, aber sie ist nicht das Objekt.",
          "aspects": [
            {
              "text": "Die Klasse ist der Bauplan für das Objekt",
              "elements": [
                [
                  0,
                  41
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Das Objekt ist die Instanz der Klasse",
              "elements": [
                [
                  43,
                  80
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Klasse ist ein Bauplan für Objekt Klasse definiert den Typ des Objektes Objekt ist ein Ausprägung",
          "id": "89",
          "answerCategory": "binary_correct",
          "correctionOrComment": "Die Klasse ist ein Bauplan für das Objekt. Eine Klasse definiert den Typ des Objektes. Das Objekt ist ein Ausprägung.",
          "aspects": [
            {
              "text": "Die Klasse ist ein Bauplan für das Objekt",
              "elements": [
                [
                  0,
                  41
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Das Objekt ist ein Ausprägung",
              "elements": [
                [
                  87,
                  116
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Objekte werden von Klassen definiert. Eine Klasse beschreibt die Variablen, Eigenschaften .... eines Objekts. Objekte sind Instanzen von Klassen. Die klasse wird zu Verwendung von Objekten erstellt, daher sind Objekten Plätzchen.",
          "id": "90",
          "answerCategory": "correct",
          "correctionOrComment": "Objekte werden von Klassen definiert. Eine Klasse beschreibt die Variablen und Eigenschaften eines Objekts. Objekte sind Instanzen von Klassen. Die Klasse wird zur Verwendung von Objekten erstellt.",
          "aspects": [
            {
              "text": "Objekte werden von Klassen definiert. Eine Klasse beschreibt die Variablen und Eigenschaften eines Objekts",
              "elements": [
                [
                  0,
                  106
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Objekte sind Instanzen von Klassen",
              "elements": [
                [
                  108,
                  142
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Die Klasse ist der \"\"Bauplan\"\" für das Objekt, sie definiert u.a. die Fähigkeiten des Objekts und regelt den Zugriff auf das Objekt",
          "id": "91",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Die Klasse ist der Bauplan für das Objekt. Sie definiert unter anderem die Fähigkeiten des Objekts und regelt den Zugriff auf das Objekt.",
          "aspects": [
            {
              "text": "Die Klasse ist der Bauplan für das Objekt",
              "elements": [
                [
                  0,
                  41
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "-",
          "id": "92",
          "answerCategory": "none",
          "correctionOrComment": "-",
          "aspects": []
        }
      ]
    },
    {
      "id": "14",
      "text": "Was unterscheidet in JAVA Klassenvariablen von Instanzvariablen?",
      "title": "Klassen- und Instanzvariable",
      "type": "comparison",
      "aspects": [
        {
          "text": "Klassenvariablen existieren einmal pro Klasse"
        },
        {
          "text": "Klassenvariablen existieren auch ohne eine konkrete Instanz"
        },
        {
          "text": "Instanzvariable existiert einmal pro Objekt"
        }
      ],
      "referenceAnswers": [
        {
          "id": "ref1",
          "text": "Klassenvariablen existieren einmal pro Klasse, auch ohne eine konkrete Instanz. Instanzvariable existiert einmal pro Objekt.",
          "aspects": [
            {
              "text": "Klassenvariablen existieren einmal pro Klasse",
              "aIdx": 0,
              "elements": [
                [
                  0,
                  45
                ]
              ],
              "label": 0
            },
            {
              "text": "Klassenvariablen existieren ;; auch ohne eine konkrete Instanz",
              "aIdx": 1,
              "elements": [
                [
                  0,
                  37
                ],
                [
                  47,
                  78
                ]
              ],
              "label": 0
            },
            {
              "text": "Instanzvariable existiert einmal pro Objekt",
              "aIdx": 2,
              "elements": [
                [
                  80,
                  123
                ]
              ],
              "label": 0
            }
          ]
        }
      ],
      "studentAnswers": [
        {
          "text": "Klassenvariable ist für die ganze klasse bestimmte variable und die Instanzvariable ist für den jeweiligen Bereich.",
          "id": "93",
          "answerCategory": "missconception",
          "correctionOrComment": "Eine Klassenvariable ist eine für die ganze Klasse bestimmte Variable und die Instanzvariable ist für den jeweiligen Bereich gedacht.",
          "aspects": [
            {
              "text": "Eine Klassenvariable ist eine für die ganze Klasse bestimmte Variable",
              "elements": [
                [
                  0,
                  69
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "klassenvariablen sind in der klasse sichtbar und Instanzvariablen sind in dem Konstruktor in Parameterleiste",
          "id": "94",
          "answerCategory": "missconception",
          "correctionOrComment": "Klassenvariablen sind in der Klasse sichtbar und Instanzvariablen sind in dem Konstruktor in der Parameterliste.",
          "aspects": []
        },
        {
          "text": "-",
          "id": "95",
          "answerCategory": "none",
          "correctionOrComment": "-",
          "aspects": []
        },
        {
          "text": "öffentlich",
          "id": "96",
          "answerCategory": "none",
          "correctionOrComment": "öffentlich",
          "aspects": []
        },
        {
          "text": "Klassenvariable ist mit static und eine instanzvariable ist ohne static",
          "id": "97",
          "answerCategory": "concept_mix-up",
          "correctionOrComment": "Eine Klassenvariable wird mit 'static' definiert und eine instanzvariable ohne 'static'.",
          "aspects": []
        },
        {
          "text": "Klassenvariablen sind für die gesamte Klasse angelegt, Instatzvariablen für das Objekt das welches erzeugt wird",
          "id": "98",
          "answerCategory": "binary_correct",
          "correctionOrComment": "Klassenvariablen sind für die gesamte Klasse angelegt und Instanzvariablen nur für das Objekt, welches erzeugt wird.",
          "aspects": [
            {
              "text": "Klassenvariablen sind für die gesamte Klasse angelegt",
              "elements": [
                [
                  0,
                  53
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Instanzvariablen nur für das Objekt",
              "elements": [
                [
                  58,
                  93
                ]
              ],
              "aIdx": 2,
              "label": 0
            }
          ]
        },
        {
          "text": "klassenvariablen sind innerhald einer klasse deklariert und in der ganzen klasse sichtbar und instanzvarialblen sind in einer methode deklariert und nur in dieser methode sichtbar",
          "id": "99",
          "answerCategory": "missconception",
          "correctionOrComment": "Klassenvariablen sind innerhalb einer Klasse deklariert und in der ganzen Klasse sichtbar. Instanzvarialblen sind in einer Methode deklariert und nur in dieser Methode sichtbar.",
          "aspects": [
            {
              "text": "Klassenvariablen sind innerhalb einer Klasse deklariert und in der ganzen Klasse sichtbar",
              "elements": [
                [
                  0,
                  89
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "-",
          "id": "100",
          "answerCategory": "none",
          "correctionOrComment": "-",
          "aspects": []
        },
        {
          "text": "Klassenvariable nur in der Klasse, Instanzvariablen in mehreren Klassen",
          "id": "101",
          "answerCategory": "missconception",
          "correctionOrComment": "Eine Klassenvariable gibt es nur in der Klasse und Instanzvariablen in mehreren Klassen.",
          "aspects": []
        },
        {
          "text": "-",
          "id": "102",
          "answerCategory": "none",
          "correctionOrComment": "-",
          "aspects": []
        },
        {
          "text": "klassenvariablen sind public und instanzvariablen private",
          "id": "103",
          "answerCategory": "missconception",
          "correctionOrComment": "Klassenvariablen sind 'public' und Instanzvariablen 'private'.",
          "aspects": []
        },
        {
          "text": "Klassenvariablen definieren eine Klasse , Instanzvariablen definieren eine Methode",
          "id": "104",
          "answerCategory": "missconception",
          "correctionOrComment": "Klassenvariablen definieren eine Klasse und Instanzvariablen definieren eine Methode.",
          "aspects": []
        },
        {
          "text": "Klassenvariablen werden nur innerhalb der Klasse ohne modifikatoren sichtbar und benutzbar. Instanzvariablen können in mehrere Klassen benutzt werden.",
          "id": "105",
          "answerCategory": "missconception",
          "correctionOrComment": "Klassenvariablen werden nur innerhalb der Klasse ohne Modifikatoren sichtbar und benutzbar. Instanzvariablen können in mehrere Klassen benutzt werden.",
          "aspects": []
        },
        {
          "text": "Instanzvariablen gehören zu den Objekt und statischen Variablen gehören zu der Klasse und nicht zu einzelne Objekt",
          "id": "106",
          "answerCategory": "correct",
          "correctionOrComment": "Instanzvariablen gehören zu den Objekten und statische Variablen gehören zu der Klasse und nicht zum einzelnen Objekt.",
          "aspects": [
            {
              "text": "Instanzvariablen gehören zu den Objekten ",
              "elements": [
                [
                  0,
                  40
                ]
              ],
              "aIdx": 2,
              "label": 0
            },
            {
              "text": "statische Variablen gehören zu der Klasse",
              "elements": [
                [
                  45,
                  86
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "statische Variablen gehören ;; nicht zum einzelnen Objekt",
              "elements": [
                [
                  45,
                  72
                ],
                [
                  91,
                  117
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "this",
          "id": "107",
          "answerCategory": "none",
          "correctionOrComment": "this",
          "aspects": []
        },
        {
          "text": "instanz variable sind normale strings. klassen variablen haben ein public oder",
          "id": "108",
          "answerCategory": "missconception",
          "correctionOrComment": "Instanzvariablen sind normale 'Strings'. Klassenvariablen haben ein 'public'.",
          "aspects": []
        },
        {
          "text": "die Klassenvariablen sind für die ganze Klasse zugreifbar, instanzvariablen nur für die Objekten.",
          "id": "109",
          "answerCategory": "correct",
          "correctionOrComment": "Die Klassenvariablen sind für die ganze Klasse zugreifbar, Instanzvariablen nur für die Objekte.",
          "aspects": [
            {
              "text": "Die Klassenvariablen sind für die ganze Klasse zugreifbar",
              "elements": [
                [
                  0,
                  57
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Instanzvariablen nur für die Objekte",
              "elements": [
                [
                  59,
                  95
                ]
              ],
              "aIdx": 2,
              "label": 0
            }
          ]
        },
        {
          "text": "Klassenvariablen sind nur innerhalb der Klasse sichtbar, Instanzvariablen nicht",
          "id": "110",
          "answerCategory": "missconception",
          "correctionOrComment": "Klassenvariablen sind nur innerhalb der Klasse sichtbar, Instanzvariablen nicht.",
          "aspects": []
        },
        {
          "text": "Eine Java Klassen Variable beschreibt eine Variable, welche nur innerhalb einer Klasse gültig ist. DIe Instanzvariable gilt für ein Objekt einer Klasse.",
          "id": "111",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Eine Java Klassenvariable beschreibt eine Variable, welche nur innerhalb einer Klasse gültig ist. DIe Instanzvariable gilt für ein Objekt einer Klasse.",
          "aspects": [
            {
              "text": "DIe Instanzvariable gilt für ein Objekt einer Klasse",
              "elements": [
                [
                  98,
                  150
                ]
              ],
              "aIdx": 2,
              "label": 0
            }
          ]
        },
        {
          "text": "Die Instanzvariable x wird innerhalb des Konstruktors durch den Parameter x verdeckt, daher erfolgt im ersten Konstruktor der Zugriff auf die Instanzvariable durch this.x",
          "id": "112",
          "answerCategory": "missconception",
          "correctionOrComment": "Die Instanzvariable 'x' wird innerhalb des Konstruktors durch den Parameter 'x' verdeckt. Daher erfolgt im ersten Konstruktor der Zugriff auf die Instanzvariable durch 'this.x'.",
          "aspects": []
        },
        {
          "text": "Bei Klassenvariablen ist die definition in einer Klasse mit der schlüsselwort static, aber bei Instanzvariablen ohne der schlüsselwort static",
          "id": "113",
          "answerCategory": "concept_mix-up",
          "correctionOrComment": "Bei Klassenvariablen erfolg die Definition in einer Klasse mit dem Schlüsselwort 'static', aber bei Instanzvariablen ohne das Schlüsselwort 'static'.",
          "aspects": []
        },
        {
          "text": "Klassenvariablen sind in der Klasse sichtbar, während Instanzvariablen Objekte der Klasse sind",
          "id": "114",
          "answerCategory": "missconception",
          "correctionOrComment": "Klassenvariablen sind in der Klasse sichtbar, während Instanzvariablen Objekte der Klasse sind.",
          "aspects": []
        },
        {
          "text": "Instanzen werden immer mit \"\"new Text ()\"\" definiert. Und Klassenvariablen werden mit \"\"Text ()\"\" aufgerufen",
          "id": "115",
          "answerCategory": "missconception",
          "correctionOrComment": "Instanzen werden immer mit 'new' definiert und Klassenvariablen werden mit 'Text ()' aufgerufen.",
          "aspects": []
        },
        {
          "text": "Klassenvariablen definieren eine Klasse und Instanzvariablen sind die in einer Klasse definiert",
          "id": "116",
          "answerCategory": "missconception",
          "correctionOrComment": "Klassenvariablen definieren eine Klasse und Instanzvariablen sind in einer Klasse definiert.",
          "aspects": []
        },
        {
          "text": "Intanzvariablen können für jedes Objekt unterschiedlich sein, Klassenvariablen sind für jedes Objekt gleich.",
          "id": "117",
          "answerCategory": "correct",
          "correctionOrComment": "Intanzvariablen können für jedes Objekt unterschiedlich sein, Klassenvariablen sind für jedes Objekt gleich.",
          "aspects": [
            {
              "text": "Klassenvariablen sind für jedes Objekt gleich",
              "elements": [
                [
                  62,
                  107
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Intanzvariablen können für jedes Objekt unterschiedlich sein",
              "elements": [
                [
                  0,
                  60
                ]
              ],
              "aIdx": 2,
              "label": 0
            }
          ]
        },
        {
          "text": "Klassenvariablen sind mit static und innerhalb der ganzen Klasse sichtbar. Instanzvariablen nur innerhalb der Methode.",
          "id": "118",
          "answerCategory": "missconception",
          "correctionOrComment": "Klassenvariablen sind mit 'static' und innerhalb der ganzen Klasse sichtbar, Instanzvariablen nur innerhalb der Methode.",
          "aspects": []
        },
        {
          "text": "Klassenvariablen sind nicht initialisert (Bauplan-Variablen). Instanzvariablen sind die Attribute eines Objekts. Klassenvariablen werden somit zu Instanzvariablen",
          "id": "119",
          "answerCategory": "missconception",
          "correctionOrComment": "Klassenvariablen sind nicht initialisert. Instanzvariablen sind die Attribute eines Objekts. Klassenvariablen werden somit zu Instanzvariablen",
          "aspects": []
        },
        {
          "text": "-",
          "id": "120",
          "answerCategory": "none",
          "correctionOrComment": "-",
          "aspects": []
        },
        {
          "text": "klassenvariablen sind public und instanzvariablen sind private",
          "id": "121",
          "answerCategory": "missconception",
          "correctionOrComment": "Klassenvariablen sind 'public' und Instanzvariablen sind 'private'.",
          "aspects": []
        },
        {
          "text": "Instanzvariablen sind auch in anderen Klassen sichtbar. Klassenvariablen nur in der eigenen Klasse.",
          "id": "122",
          "answerCategory": "missconception",
          "correctionOrComment": "Instanzvariablen sind auch in anderen Klassen sichtbar. Klassenvariablen nur in der eigenen Klasse.",
          "aspects": []
        },
        {
          "text": "Instanzvariablen sind bereits initialisiert. Instanzvariablen gehören zu einem spObjekt. Bei Klassenvariablen muss dies nich der Fall sein.",
          "id": "123",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Instanzvariablen sind bereits initialisiert. Instanzvariablen gehören zu einem Objekt. Bei Klassenvariablen muss dies nicht der Fall sein.",
          "aspects": [
            {
              "text": "Instanzvariablen gehören zu einem Objekt",
              "elements": [
                [
                  45,
                  85
                ]
              ],
              "aIdx": 2,
              "label": 0
            }
          ]
        },
        {
          "text": "Die beiden unterscheiden sich durch \"\"this\"\". Insatanzvariablen werden durch \"\"this\"\" definiert.",
          "id": "124",
          "answerCategory": "missconception",
          "correctionOrComment": "Die beiden unterscheiden sich durch 'this'. Insatanzvariablen werden durch 'this' definiert.",
          "aspects": []
        },
        {
          "text": "Klassenvariablen nur in der eigenen Klasse genutzt, Instanzvariable in mehrern Klassen.",
          "id": "125",
          "answerCategory": "missconception",
          "correctionOrComment": "Klassenvariablen werden nur in der eigenen Klasse genutzt, Instanzvariablen in mehreren Klassen.",
          "aspects": []
        },
        {
          "text": "Instanzvariablen werden den Objekten übergeben und gehören den Objekten. Die Klassenvariablen gehören der ganzen Klasse",
          "id": "126",
          "answerCategory": "correct",
          "correctionOrComment": "Instanzvariablen werden den Objekten übergeben und gehören den Objekten. Die Klassenvariablen gehören der ganzen Klasse.",
          "aspects": [
            {
              "text": "Die Klassenvariablen gehören der ganzen Klasse",
              "elements": [
                [
                  73,
                  119
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Instanzvariablen werden den Objekten übergeben und gehören den Objekten",
              "elements": [
                [
                  0,
                  71
                ]
              ],
              "aIdx": 2,
              "label": 0
            }
          ]
        },
        {
          "text": "Jedes object hat seine eigene Instanzvariable unabhängig von anderen Objekten die von der selben klasse codiert wurden. klassenvariablen sind an die eigenen Klassen gebunden, die Objekte sehen die selben klassenvariablen",
          "id": "127",
          "answerCategory": "correct",
          "correctionOrComment": "Jedes Objekt hat seine eigene Instanzvariable unabhängig von anderen Objekten, die von derselben Klasse codiert wurden. Klassenvariablen sind an die eigenen Klassen gebunden. Die Objekte sehen die selben Klassenvariablen.",
          "aspects": [
            {
              "text": "Jedes Objekt hat seine eigene Instanzvariable unabhängig von anderen Objekten",
              "elements": [
                [
                  0,
                  77
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Klassenvariablen sind an die eigenen Klassen gebunden",
              "elements": [
                [
                  120,
                  173
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "Die Objekte sehen die selben Klassenvariablen",
              "elements": [
                [
                  175,
                  220
                ]
              ],
              "aIdx": 2,
              "label": 0
            }
          ]
        },
        {
          "text": "Instanzvariablen sind in einer Klasse definiert und man kann durch get und set zugreifen",
          "id": "128",
          "answerCategory": "missconception",
          "correctionOrComment": "Instanzvariablen sind in einer Klasse definiert und man kann durch 'get' und 'set' auf sie zugreifen.",
          "aspects": []
        },
        {
          "text": "Klassenvariablen sind in der Klasse überalle sichtbar. Instanzvariablen sind für die gegebene Instanz aufgerufen und danach werden sie von der garbage collection eingesammelt",
          "id": "129",
          "answerCategory": "missconception",
          "correctionOrComment": "Klassenvariablen sind in der Klasse überall sichtbar. Instanzvariablen sind für die gegebene Instanz aufgerufen und danach werden sie von dem 'garbage collector' eingesammelt.",
          "aspects": []
        },
        {
          "text": "-",
          "id": "130",
          "answerCategory": "none",
          "correctionOrComment": "-",
          "aspects": []
        },
        {
          "text": "-",
          "id": "131",
          "answerCategory": "none",
          "correctionOrComment": "-",
          "aspects": []
        },
        {
          "text": "Instanzvariablen können nur von einzelnen Methoden genutzt werden. Klassenvaroiablen von der ganzen Klasse.",
          "id": "132",
          "answerCategory": "missconception",
          "correctionOrComment": "Instanzvariablen können nur von einzelnen Methoden genutzt werden, Klassenvariablen von der ganzen Klasse.",
          "aspects": []
        },
        {
          "text": "instanzvariablengehören zu den objekten werden objekten übergeben",
          "id": "133",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Instanzvariablen gehören zu den Objekten. Sie werden Objekten übergeben.",
          "aspects": [
            {
              "text": "Instanzvariablen gehören zu den Objekten",
              "elements": [
                [
                  0,
                  40
                ]
              ],
              "aIdx": 2,
              "label": 0
            }
          ]
        },
        {
          "text": "Klassenvariablen sind in der Klasse sichtbar und Instanzvariablen sind",
          "id": "134",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Klassenvariablen sind in der Klasse sichtbar.",
          "aspects": []
        },
        {
          "text": "Insstanzvariblen sind bereits initialisiert.",
          "id": "135",
          "answerCategory": "missconception",
          "correctionOrComment": "Instanzvariablen sind bereits initialisiert.",
          "aspects": []
        },
        {
          "text": "Instanzvariable gehören zu den Objekt und statischen variable Klassen variable",
          "id": "136",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Instanzvariablen gehören zu dem Objekt und statische Variablen sind Klassenvariablen.",
          "aspects": [
            {
              "text": "Instanzvariablen gehören zu dem Objekt",
              "elements": [
                [
                  0,
                  38
                ]
              ],
              "aIdx": 2,
              "label": 0
            }
          ]
        },
        {
          "text": "Instanzvariablen gehören zu den Objekten werden den Objekten übergeben. Klassenvariablen hingegen nicht sie gehrlen einer klase",
          "id": "137",
          "answerCategory": "binary_correct",
          "correctionOrComment": "Instanzvariablen gehören zu den Objekten und werden den Objekten übergeben. Klassenvariablen hingegen nicht, sie gehören einer Klasse.",
          "aspects": [
            {
              "text": "Klassenvariablen ;; gehören einer Klasse",
              "elements": [
                [
                  76,
                  92
                ],
                [
                  113,
                  133
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Instanzvariablen gehören zu den Objekten und werden den Objekten übergeben",
              "elements": [
                [
                  0,
                  74
                ]
              ],
              "aIdx": 2,
              "label": 0
            }
          ]
        },
        {
          "text": "Klasse definiert in einem Block und Instanzvariable wird in der Klasse definiert",
          "id": "138",
          "answerCategory": "missconception",
          "correctionOrComment": "Eine Klasse definiert in einem Block und eine Instanzvariable wird in der Klasse definiert.",
          "aspects": []
        },
        {
          "text": "Klassenvariablen sind nur in der Klasse sichtbar, Instanzvariablen in mehreren Klassen",
          "id": "139",
          "answerCategory": "missconception",
          "correctionOrComment": "Klassenvariablen sind nur in der Klasse sichtbar, Instanzvariablen in mehreren Klassen.",
          "aspects": []
        },
        {
          "text": "Klassenvariablen werden in der Main Methode deklariert. Instanzvariablen in Konstruktoren.",
          "id": "140",
          "answerCategory": "missconception",
          "correctionOrComment": "Klassenvariablen werden in der 'main' Methode deklariert, Instanzvariablen in Konstruktoren.",
          "aspects": []
        },
        {
          "text": "Klassenvariablen sind in einer Klasse deklarierte und gegebenfalls initialisierte Variablen, dagegen sind Instanzvariablen in einem Objekt deklarierte und ggf Varibalen",
          "id": "141",
          "answerCategory": "binary_correct",
          "correctionOrComment": "Klassenvariablen sind in einer Klasse deklarierte und gegebenfalls initialisierte Variablen. Dagegen sind Instanzvariablen in einem Objekt deklarierte und gegebenenfalls Variablen.",
          "aspects": [
            {
              "text": "Klassenvariablen sind in einer Klasse deklarierte",
              "elements": [
                [
                  0,
                  49
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Dagegen sind Instanzvariablen in einem Objekt deklarierte",
              "elements": [
                [
                  93,
                  150
                ]
              ],
              "aIdx": 2,
              "label": 0
            }
          ]
        },
        {
          "text": "Instanzvariablen sind Objekte sozusagen und Klassenvariiable sind Variable die in defr klasse sichtbar sind",
          "id": "142",
          "answerCategory": "missconception",
          "correctionOrComment": "Instanzvariablen sind sozusagen Objekte und Klassenvariablen sind Variablen die in der Klasse sichtbar sind.",
          "aspects": []
        },
        {
          "text": "instanzsvariablen sind zb einfach public String, public int, und klassenvariablen computer (int variable){",
          "id": "143",
          "answerCategory": "missconception",
          "correctionOrComment": "Instanzsvariablen sind zum Beispiel einfach 'public String' oder 'public int', und Klassenvariablen Parameter.",
          "aspects": []
        },
        {
          "text": "this",
          "id": "144",
          "answerCategory": "none",
          "correctionOrComment": "this",
          "aspects": []
        }
      ]
    },
    {
      "id": "26",
      "title": "Swing Ablauf",
      "text": "In einer Swing-Demo ändert sich beim Klick auf einen Button der Text auf dem Button. Wie sieht der mehrschrittige Ablauf \"\"hinter den Kulissen\"\" aus?",
      "type": "procedure",
      "aspects": [
        {
          "text": "Der Klick auf den Button erzeugt ein ActionEvent"
        },
        {
          "text": "Das ActionEvent wird von einem Listener aufgefangen"
        },
        {
          "text": "Der Listener ist beim Button registriert",
          "implied": true
        },
        {
          "text": "Der Listener ändert den Text"
        }
      ],
      "referenceAnswers": [
        {
          "id": "ref1",
          "text": "Der Klick auf den Button erzeugt ein ActionEvent. Das ActionEvent wird von einem Listener aufgefangen, der beim Button registriert ist. Der Listener ändert daraufhin den Text.",
          "aspects": [
            {
              "text": "Der Klick auf den Button erzeugt ein ActionEvent",
              "aIdx": 0,
              "elements": [
                [
                  0,
                  48
                ]
              ],
              "label": 0
            },
            {
              "text": "Das ActionEvent wird von einem Listener aufgefangen",
              "aIdx": 1,
              "elements": [
                [
                  50,
                  101
                ]
              ],
              "label": 0
            },
            {
              "text": "der beim Button registriert ist",
              "aIdx": 2,
              "elements": [
                [
                  103,
                  134
                ]
              ],
              "label": 0
            },
            {
              "text": "Der Listener ändert daraufhin den Text",
              "aIdx": 3,
              "elements": [
                [
                  136,
                  176
                ]
              ],
              "label": 0
            }
          ]
        }
      ],
      "studentAnswers": [
        {
          "id": "1",
          "text": "Bei dem Klick wird ActionListener ausgeführt. Nach dem Klick wird ActionPerformed ausgeführt",
          "aspects": [
            {
              "text": "Bei dem Klick wird ActionListener ausgeführt",
              "elements": [
                [
                  0,
                  44
                ]
              ],
              "aIdx": 0,
              "label": 2
            }
          ],
          "correctionOrComment": "Bei dem Klick wird ActionListener ausgeführt. Nach dem Klick wird ActionPerformed ausgeführt"
        },
        {
          "id": "2",
          "text": "Es wird nach dem Klick auf einen Button ein ActionEvent ausgeführt, damit das Programm weißt es wurde geklickt und der ActionListener führt es dann aus.",
          "aspects": [
            {
              "text": "Es wird nach dem Klick auf einen Button ein ActionEvent ausgeführt",
              "elements": [
                [
                  0,
                  66
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "der ActionListener führt es dann aus",
              "elements": [
                [
                  115,
                  151
                ]
              ],
              "aIdx": 3,
              "label": 0
            }
          ],
          "correctionOrComment": "Es wird nach dem Klick auf einen Button ein ActionEvent ausgeführt, damit das Programm weißt, es wurde geklickt, und der ActionListener führt es dann aus."
        },
        {
          "id": "3",
          "text": "Nach dem Klick wird ein ActionEvent ausgeführt.",
          "aspects": [
            {
              "text": "Nach dem Klick wird ein ActionEvent ausgeführt",
              "elements": [
                [
                  0,
                  46
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ],
          "correctionOrComment": "Nach dem Klick wird ein ActionEvent ausgeführt."
        },
        {
          "id": "4",
          "text": "Beim Klicken entsteht ein ActionEvent und man hängt einen Listrener dran an das Objekt. Danach Checkt der Listener ob er einen Event bekommen hat und erst danach führt er seinen Code aus.",
          "aspects": [
            {
              "text": "Beim Klicken entsteht ein ActionEvent",
              "elements": [
                [
                  0,
                  37
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Danach Checkt der Listener ob er einen Event bekommen",
              "elements": [
                [
                  88,
                  141
                ]
              ],
              "aIdx": 1,
              "label": 1
            },
            {
              "text": "man hängt einen Listrener dran an das Objekt",
              "elements": [
                [
                  42,
                  86
                ]
              ],
              "aIdx": 2,
              "label": 1
            },
            {
              "text": "erst danach führt er seinen Code aus",
              "elements": [
                [
                  150,
                  186
                ]
              ],
              "aIdx": 3,
              "label": 0
            }
          ],
          "correctionOrComment": "Beim Klicken entsteht ein ActionEvent und man hängt einen Listrener dran an das Objekt. Danach Checkt der Listener ob er einen Event bekommen hat und erst danach führt er seinen Code aus."
        },
        {
          "id": "5",
          "text": "Man erstellt ein Button, fügt beim code byklick ein damit bei einem klick das Programm reagiert und dann fügt man noch Variablen hinzu die der Button annehmen kann.",
          "aspects": [],
          "correctionOrComment": "Man erstellt ein Button, fügt beim code byklick ein damit bei einem klick das Programm reagiert und dann fügt man noch Variablen hinzu die der Button annehmen kann."
        },
        {
          "id": "6",
          "text": "1.Durch den Klick wird ein Event erzeugt. 2.Klick wird vom ActionListener bemerkt, der mit dem Button verbunden ist. 3.Dann wird die jeweilige Methode dadurch aufgerufen.",
          "aspects": [
            {
              "text": "Durch den Klick wird ein Event erzeugt",
              "elements": [
                [
                  2,
                  40
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Klick wird vom ActionListener bemerkt",
              "elements": [
                [
                  44,
                  81
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "ActionListener ;; der mit dem Button verbunden ist",
              "elements": [
                [
                  59,
                  73
                ],
                [
                  83,
                  115
                ]
              ],
              "aIdx": 2,
              "label": 0
            },
            {
              "text": "Dann wird die jeweilige Methode dadurch aufgerufen",
              "elements": [
                [
                  119,
                  169
                ]
              ],
              "aIdx": 3,
              "label": 0
            }
          ],
          "correctionOrComment": "1.Durch den Klick wird ein Event erzeugt. 2.Klick wird vom ActionListener bemerkt, der mit dem Button verbunden ist. 3.Dann wird die jeweilige Methode dadurch aufgerufen."
        },
        {
          "id": "7",
          "text": "Durch den Klick auf den Button wird eine Action ausgelöst. Diese Action wird von einem Listener \"\"bemerkt\"\" (umgesetzt) und dieser führt dann den Code aus, um den Text zu ändern.",
          "aspects": [
            {
              "text": "Durch den Klick auf den Button wird eine Action ausgelöst",
              "elements": [
                [
                  0,
                  57
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Diese Action wird von einem Listener bemerkt",
              "elements": [],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "dieser führt dann den Code aus, um den Text zu ändern",
              "elements": [
                [
                  124,
                  177
                ]
              ],
              "aIdx": 3,
              "label": 0
            }
          ],
          "correctionOrComment": "Durch den Klick auf den Button wird eine Action ausgelöst. Diese Action wird von einem Listener bemerkt (umgesetzt) und dieser führt dann den Code aus, um den Text zu ändern."
        },
        {
          "id": "8",
          "text": "Man fügt dem Button einen ActionEvent ein der wiederrum einen ActionListener (Anonyme Klasse) erstellt und in ihn verändern wir das Text in dem Button mit einer setText() Methode.",
          "aspects": [
            {
              "text": "Man fügt dem Button einen ActionEvent ein",
              "elements": [
                [
                  0,
                  41
                ]
              ],
              "aIdx": 0,
              "label": 2
            },
            {
              "text": "der wiederrum einen ActionListener (Anonyme Klasse) erstellt ",
              "elements": [
                [
                  42,
                  102
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "in ihm verändern wir den Text in dem Button",
              "elements": [],
              "aIdx": 3,
              "label": 0
            }
          ],
          "correctionOrComment": "Man fügt dem Button einen ActionEvent ein der wiederrum einen ActionListener (Anonyme Klasse) erstellt und in ihm verändern wir den Text in dem Button mit einer setText() Methode."
        },
        {
          "id": "9",
          "text": "Ein Klick auf einen Button erzeugt ein ActionEvent und um auf Events zu reagieren, hängt man einen Listener an das Objekt, das Events erzeugen kann. Am Ende wenn der Listener ein Event gemeldet bekommt, führt er seinen Code aus.",
          "aspects": [
            {
              "text": "Ein Klick auf einen Button erzeugt ein ActionEvent",
              "elements": [
                [
                  0,
                  50
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Am Ende wenn der Listener ein Event gemeldet bekommt",
              "elements": [
                [
                  149,
                  201
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "um auf Events zu reagieren, hängt man einen Listener an das Objekt",
              "elements": [
                [
                  55,
                  121
                ]
              ],
              "aIdx": 2,
              "label": 0
            },
            {
              "text": "führt er seinen Code aus",
              "elements": [
                [
                  203,
                  227
                ]
              ],
              "aIdx": 3,
              "label": 0
            }
          ],
          "correctionOrComment": "Ein Klick auf einen Button erzeugt ein ActionEvent und um auf Events zu reagieren, hängt man einen Listener an das Objekt, das Events erzeugen kann. Am Ende wenn der Listener ein Event gemeldet bekommt, führt er seinen Code aus."
        },
        {
          "id": "10",
          "text": "Beim Klick auf einen Button wird die MEin Klick auf einen Button erzeugt ein ActionEvent",
          "aspects": [
            {
              "text": "Mein Klick auf einen Button erzeugt ein ActionEvent",
              "elements": [],
              "aIdx": 0,
              "label": 0
            }
          ],
          "correctionOrComment": "Mein Klick auf einen Button erzeugt ein ActionEvent"
        },
        {
          "id": "11",
          "text": "-> Key Event abfangen -> IF-Block auswerden (true/false) was wurde angeklickt -> neues Fenster anhand Ausgewerteter IF-Abfrage erstellen",
          "aspects": [],
          "correctionOrComment": "-> Key Event abfangen -> IF-Block auswerden (true/false) was wurde angeklickt -> neues Fenster anhand Ausgewerteter IF-Abfrage erstellen"
        },
        {
          "id": "12",
          "text": "-",
          "aspects": [],
          "correctionOrComment": "-"
        },
        {
          "id": "13",
          "text": "Beim Klick entsteht eine Aktion und schickt ein Signal an Listener und dies liefert die erwünschte Code. Bsp. Ok oder Weiter",
          "aspects": [
            {
              "text": "Beim Klick entsteht eine Aktion ",
              "elements": [
                [
                  0,
                  31
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "schickt ein Signal an Listener",
              "elements": [
                [
                  36,
                  66
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "dieser liefert den erwünschten Code",
              "elements": [],
              "aIdx": 3,
              "label": 1
            }
          ],
          "correctionOrComment": "Beim Klick entsteht eine Aktion und schickt ein Signal an Listener und dieser liefert den erwünschten Code. Bsp. Ok oder Weiter"
        },
        {
          "id": "14",
          "text": "Ein Klick auf den Button erzeugt einen Action Event daraufhin hört der ActionListener den Klick bzw. die Information. Der",
          "aspects": [
            {
              "text": "Ein Klick auf den Button erzeugt einen ActionEvent",
              "elements": [],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Daraufhin hört der ActionListener den Klick",
              "elements": [],
              "aIdx": 1,
              "label": 1
            }
          ],
          "correctionOrComment": "Ein Klick auf den Button erzeugt einen ActionEvent. Daraufhin hört der ActionListener den Klick"
        },
        {
          "id": "15",
          "text": "-",
          "aspects": [],
          "correctionOrComment": "-"
        },
        {
          "id": "16",
          "text": "wenn wir auf den Button klicken dann wird eine Action ausgelöst mit Actionlistener wird eine methode ausgeführt es wird ausgeführt was da drin programmiert wurde",
          "aspects": [
            {
              "text": "Wenn wir auf den Button klicken dann wird eine Action ausgelöst",
              "elements": [],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Mit ActionListener wird eine Methode ausgeführt",
              "elements": [],
              "aIdx": 3,
              "label": 0
            }
          ],
          "correctionOrComment": "Wenn wir auf den Button klicken dann wird eine Action ausgelöst. Mit ActionListener wird eine Methode ausgeführt. Es wird ausgeführt was da drin programmiert wurde"
        },
        {
          "id": "17",
          "text": "-",
          "aspects": [],
          "correctionOrComment": "-"
        },
        {
          "id": "18",
          "text": "Button drücken",
          "aspects": [],
          "correctionOrComment": "Button drücken"
        },
        {
          "id": "19",
          "text": "Ein Listener wartet auf einen Aufruf(Klick) des Benutzers. Beim Aufruf wird ruft der Listener eine Methode auf und lässt diese ausführen.",
          "aspects": [
            {
              "text": "Ein Listener wartet auf einen Aufruf(Klick) des Benutzers",
              "elements": [
                [
                  0,
                  57
                ]
              ],
              "aIdx": 2,
              "label": 1
            },
            {
              "text": "Beim Aufruf ruft der Listener eine Methode auf und lässt diese ausführen",
              "elements": [],
              "aIdx": 3,
              "label": 0
            }
          ],
          "correctionOrComment": "Ein Listener wartet auf einen Aufruf(Klick) des Benutzers. Beim Aufruf ruft der Listener eine Methode auf und lässt diese ausführen."
        },
        {
          "id": "20",
          "text": "der Klick erezeugt ein event, welches von einem ActionListener empfangen wird. dieser ActionListener ist mit dem Button verbunden und kann dann die methode zum ändern des Buttons aufrufen ( zB seIcon())",
          "aspects": [
            {
              "text": "Der Klick erezeugt ein Event",
              "elements": [],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "welches von einem ActionListener empfangen wird",
              "elements": [
                [
                  30,
                  77
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "Dieser ActionListener ist mit dem Button verbunden ",
              "elements": [],
              "aIdx": 2,
              "label": 0
            },
            {
              "text": "Dieser ActionListener ;; kann dann die Methode zum Ändern des Buttons aufrufen",
              "elements": [],
              "aIdx": 3,
              "label": 0
            }
          ],
          "correctionOrComment": "Der Klick erezeugt ein Event, welches von einem ActionListener empfangen wird. Dieser ActionListener ist mit dem Button verbunden und kann dann die Methode zum Ändern des Buttons aufrufen."
        },
        {
          "id": "21",
          "text": "-",
          "aspects": [],
          "correctionOrComment": "-"
        },
        {
          "id": "22",
          "text": "-ActionListener muss implementieren zum button -Methode ActionListener erstellen mit ActionPerformed und setText der veränderte Text",
          "aspects": [],
          "correctionOrComment": "-"
        },
        {
          "id": "23",
          "text": "Beim Klick auf einem Button wird ein Action Event ausgelöst, daß den vorhanden Text der vorher ausgegeben wurde durch den neuen Text erstetzt wird ( im Button Fenster).",
          "aspects": [
            {
              "text": "Beim Klick auf einem Button wird ein ActionEvent ausgelöst",
              "elements": [],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "dass den vorhanden Text der vorher ausgegeben wurde durch den neuen Text erstetzt",
              "elements": [],
              "aIdx": 3,
              "label": 2
            }
          ],
          "correctionOrComment": "Beim Klick auf einem Button wird ein ActionEvent ausgelöst, dass den vorhanden Text der vorher ausgegeben wurde durch den neuen Text erstetzt."
        },
        {
          "id": "24",
          "text": "Jeder Klick erzeugt ein Event, um das Event zu verarbeiten braucht man einen Listener der dann den Code ausführt",
          "aspects": [
            {
              "text": "Jeder Klick erzeugt ein Event",
              "elements": [
                [
                  0,
                  29
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "um das Event zu verarbeiten braucht man einen Listener",
              "elements": [
                [
                  31,
                  85
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "einen Listener, der dann den Code ausführt",
              "elements": [],
              "aIdx": 3,
              "label": 0
            }
          ],
          "correctionOrComment": "Jeder Klick erzeugt ein Event, um das Event zu verarbeiten braucht man einen Listener der dann den Code ausführt"
        },
        {
          "id": "25",
          "text": "Das Button-Objekt besitzt eine Listener-Instanz. Diese horcht auf das Klicken in Form eines ActionEvents. Wird ein Klicken registriert, ändert sich der Text.",
          "aspects": [
            {
              "text": "Diese horcht auf das Klicken in Form eines ActionEvents",
              "elements": [
                [
                  49,
                  104
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Diese horcht auf das Klicken in Form eines ActionEvents",
              "elements": [
                [
                  49,
                  104
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "Das Button-Objekt besitzt eine Listener-Instanz",
              "elements": [
                [
                  0,
                  47
                ]
              ],
              "aIdx": 2,
              "label": 0
            },
            {
              "text": "Wird ein Klicken registriert, ändert sich der Text",
              "elements": [
                [
                  106,
                  156
                ]
              ],
              "aIdx": 3,
              "label": 0
            }
          ],
          "correctionOrComment": "Das Button-Objekt besitzt eine Listener-Instanz. Diese horcht auf das Klicken in Form eines ActionEvents. Wird ein Klicken registriert, ändert sich der Text."
        },
        {
          "id": "26",
          "text": "Der User klickt den Button und löst damit eine Action aus. Der Actionlistener wird durch den Klick aktiviert und führt somit eine Methode aus, die in seinem Rumpf steht, welche den Text auf dem Button aktualisiert und ausgibt.",
          "aspects": [
            {
              "text": "Der User klickt den Button und löst damit eine Action aus",
              "elements": [
                [
                  0,
                  57
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Der ActionListener wird durch den Klick aktiviert ",
              "elements": [],
              "aIdx": 2,
              "label": 0
            },
            {
              "text": "Der ActionListener ;; führt somit eine Methode aus, die in seinem Rumpf steht, welche den Text auf dem Button aktualisiert",
              "elements": [
                [
                  113,
                  213
                ]
              ],
              "aIdx": 3,
              "label": 0
            }
          ],
          "correctionOrComment": "Der User klickt den Button und löst damit eine Action aus. Der ActionListener wird durch den Klick aktiviert und führt somit eine Methode aus, die in seinem Rumpf steht, welche den Text auf dem Button aktualisiert und ausgibt."
        },
        {
          "id": "27",
          "text": "Beim Klick auf den Button handelt es sich um ein sogenanntes Action-Event. Am entsprechenden Button hängt ein sogennater Listener/ ein Listener-Objekt, welches auf den Eintritt des Events \"\"Klick\"\" \"\"wartet\"\", diesen registriert und anschließend seinen zugehörigen Code (hier ändere den Text auf dem Button) ausführt.",
          "aspects": [
            {
              "text": "Beim Klick auf den Button handelt es sich um ein sogenanntes ActionEvent",
              "elements": [],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "ein sogennater Listener, welcher auf den Eintritt des KlickEvents  wartet",
              "elements": [],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "Am entsprechenden Button hängt ein sogennater Listener",
              "elements": [
                [
                  75,
                  129
                ]
              ],
              "aIdx": 2,
              "label": 0
            },
            {
              "text": "ein sogennater Listener, welcher ;; anschließend seinen zugehörigen Code, hier ändere den Text auf dem Button, ausführt",
              "elements": [],
              "aIdx": 3,
              "label": 0
            }
          ],
          "correctionOrComment": "Beim Klick auf den Button handelt es sich um ein sogenanntes ActionEvent. Am entsprechenden Button hängt ein sogennater Listener, welcher auf den Eintritt des KlickEvents  wartet, diesen registriert und anschließend seinen zugehörigen Code, hier ändere den Text auf dem Button, ausführt."
        },
        {
          "id": "28",
          "text": "Bevor auf den Klick reagiert werden kann muss dieser zunächst registriert und dann weitergegeben werden. Der listener erzeugt ein Action Event.",
          "aspects": [
            {
              "text": "Der Listener erzeugt ein Action Event",
              "elements": [],
              "aIdx": 0,
              "label": 2
            },
            {
              "text": "Bevor auf den Klick reagiert werden kann muss dieser zunächst registriert und dann weitergegeben werden",
              "elements": [
                [
                  0,
                  103
                ]
              ],
              "aIdx": 2,
              "label": 2
            }
          ],
          "correctionOrComment": "Bevor auf den Klick reagiert werden kann muss dieser zunächst registriert und dann weitergegeben werden. Der Listener erzeugt ein Action Event."
        },
        {
          "id": "29",
          "text": "Auf dem Button wird eine ActionList zugeordent. Diese sagt was der Button ausführen soll.",
          "aspects": [
            {
              "text": "Auf dem Button wird eine ActionList zugeordent",
              "elements": [
                [
                  0,
                  46
                ]
              ],
              "aIdx": 2,
              "label": 1
            },
            {
              "text": "Diese sagt was der Button ausführen soll",
              "elements": [
                [
                  48,
                  88
                ]
              ],
              "aIdx": 3,
              "label": 0
            }
          ],
          "correctionOrComment": "Auf dem Button wird eine ActionList zugeordent. Diese sagt was der Button ausführen soll."
        },
        {
          "id": "30",
          "text": "Beim Klick auf den Button wird ein ActionEvent erzeugt. Daraufhin hängt man einen Listener an um an weitere Events wie Mausklicks usw. aufmerksam zu machen. Der Listener fängt so weitere Events ab und erzeugt so den Code.",
          "aspects": [
            {
              "text": "Beim Klick auf den Button wird ein ActionEvent erzeugt",
              "elements": [
                [
                  0,
                  54
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Daraufhin hängt man einen Listener an um an weitere Events wie Mausklicks usw. aufmerksam zu machen",
              "elements": [
                [
                  56,
                  155
                ]
              ],
              "aIdx": 2,
              "label": 1
            },
            {
              "text": "Der Listener fängt so weitere Events ab",
              "elements": [
                [
                  157,
                  196
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "Der Listener ;; erzeugt so den Code",
              "elements": [
                [
                  157,
                  169
                ],
                [
                  201,
                  220
                ]
              ],
              "aIdx": 3,
              "label": 1
            }
          ],
          "correctionOrComment": "Beim Klick auf den Button wird ein ActionEvent erzeugt. Daraufhin hängt man einen Listener an um an weitere Events wie Mausklicks usw. aufmerksam zu machen. Der Listener fängt so weitere Events ab und erzeugt so den Code."
        },
        {
          "id": "31",
          "text": "Dem Button wird ein ActionListener zugeordnet, wird nun auf den Button geklickt, so wird die Methode des ActionListeners ausgeführt und der Text ändert sich, sofern man dies so programmiert hat.",
          "aspects": [
            {
              "text": "Wird nun auf den Button geklickt, so wird die Methode des ActionListeners ausgeführt ",
              "elements": [],
              "aIdx": 0,
              "label": 1
            },
            {
              "text": "Wird nun auf den Button geklickt, so wird die Methode des ActionListeners ausgeführt ",
              "elements": [],
              "aIdx": 1,
              "label": 1
            },
            {
              "text": "Dem Button wird ein ActionListener zugeordnet",
              "elements": [
                [
                  0,
                  45
                ]
              ],
              "aIdx": 2,
              "label": 0
            },
            {
              "text": "so wird die Methode des ActionListeners ausgeführt und der Text ändert sich, sofern man dies so programmiert hat",
              "elements": [
                [
                  81,
                  193
                ]
              ],
              "aIdx": 3,
              "label": 0
            }
          ],
          "correctionOrComment": "Dem Button wird ein ActionListener zugeordnet. Wird nun auf den Button geklickt, so wird die Methode des ActionListeners ausgeführt und der Text ändert sich, sofern man dies so programmiert hat."
        },
        {
          "id": "32",
          "text": "1. Durch den Klick wird ein Event gestartet 2. Der Listener bemerkt dieses und leitet es weiter 3. Der Text ändert sich",
          "aspects": [
            {
              "text": "Durch den Klick wird ein Event gestartet",
              "elements": [
                [
                  3,
                  43
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Der Listener bemerkt dieses",
              "elements": [
                [
                  47,
                  74
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "Der Listener ;; leitet es weiterr. Der Text ändert sich",
              "elements": [
                [
                  47,
                  59
                ]
              ],
              "aIdx": 3,
              "label": 1
            }
          ],
          "correctionOrComment": "Durch den Klick wird ein Event gestartet. Der Listener bemerkt dieses und leitet es weiter. Der Text ändert sich"
        },
        {
          "id": "33",
          "text": "Button erstellen, dann zu Frame hinzufügen, ein ActionListener muss zum Buttton hinzugefügt werden und in der Methode hinschreiben was verändert werden soll mit setText()",
          "aspects": [
            {
              "text": "ein ActionListener muss zum Buttton hinzugefügt werden",
              "elements": [
                [
                  44,
                  98
                ]
              ],
              "aIdx": 2,
              "label": 0
            },
            {
              "text": "in der Methode hinschreiben was verändert werden soll mit setText()",
              "elements": [
                [
                  103,
                  170
                ]
              ],
              "aIdx": 3,
              "label": 0
            }
          ],
          "correctionOrComment": "Button erstellen, dann zu Frame hinzufügen, ein ActionListener muss zum Buttton hinzugefügt werden und in der Methode hinschreiben was verändert werden soll mit setText()"
        },
        {
          "id": "34",
          "text": "Mit dem klicken auf den Button wird ein Action Event in Gang gesetzt. Im Anschluss nimmt der ActionListener die Information auf.",
          "aspects": [
            {
              "text": "Mit dem klicken auf den Button wird ein ActionEvent in Gang gesetzt",
              "elements": [],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": " Im Anschluss nimmt der ActionListener die Information auf",
              "elements": [
                [
                  70,
                  127
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Mit dem klicken auf den Button wird ein ActionEvent in Gang gesetzt. Im Anschluss nimmt der ActionListener die Information auf."
        },
        {
          "id": "35",
          "text": "beim Klicken auf dem Button,lauft der actionListener ,dann der ActionListener gibt dieser text zur Performance.aber dafür braucht Button settext.",
          "aspects": [
            {
              "text": "Beim Klicken auf dem Button, lauft der ActionListener",
              "elements": [],
              "aIdx": 0,
              "label": 1
            },
            {
              "text": "Beim Klicken auf dem Button, lauft der ActionListener",
              "elements": [],
              "aIdx": 1,
              "label": 1
            },
            {
              "text": "Der ActionListener gibt dieser dann Text zur Performance",
              "elements": [],
              "aIdx": 3,
              "label": 1
            }
          ],
          "correctionOrComment": "Beim Klicken auf dem Button, läuft der ActionListener. Der ActionListener gibt dieser dann Text zur Performance. Aber dafür braucht der Button setText."
        },
        {
          "id": "36",
          "text": "mit einem Klich wird eine Action ausgeführt. Diese Action wird von einem listener vorgemerkt, der den Code ausführt und den Text ändert.",
          "aspects": [
            {
              "text": "Mit einem Klick wird eine Action ausgeführt",
              "elements": [],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Diese Action wird von einem Listener vorgemerkt",
              "elements": [],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "der den Code ausführt und den Text ändert",
              "elements": [
                [
                  94,
                  135
                ]
              ],
              "aIdx": 3,
              "label": 0
            }
          ],
          "correctionOrComment": "Mit einem Klick wird eine Action ausgeführt. Diese Action wird von einem Listener vorgemerkt, der den Code ausführt und den Text ändert."
        },
        {
          "id": "37",
          "text": "Durch den Klick wird ein Event ausgeführt welches durch den \"\"ActionListener\"\" mit den Objekt \"\"Button\"\" Verbunden wird und dadurch wird die aufgerufene Methode mit den Button zugeordnet.",
          "aspects": [
            {
              "text": "Durch den Klick wird ein Event ausgeführt",
              "elements": [
                [
                  0,
                  41
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "welches durch den ActionListener mit den Objekt Button verbunden wird",
              "elements": [],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "welches durch den ActionListener mit den Objekt Button verbunden wird",
              "elements": [],
              "aIdx": 2,
              "label": 1
            },
            {
              "text": "dadurch wird die aufgerufene Methode mit den Button zugeordnet",
              "elements": [
                [
                  124,
                  186
                ]
              ],
              "aIdx": 3,
              "label": 1
            }
          ],
          "correctionOrComment": "Durch den Klick wird ein Event ausgeführt, welches durch den ActionListener mit den Objekt Button verbunden wird und dadurch wird die aufgerufene Methode mit den Button zugeordnet."
        },
        {
          "id": "38",
          "text": "BEIM kLICK AUF EINEM BUTTON WIRD EINE ACTIONEVENT ERZEUGT.",
          "aspects": [
            {
              "text": "Beim Klick auf einen Button wird ein ActionEvent erzeugt",
              "elements": [],
              "aIdx": 0,
              "label": 0
            }
          ],
          "correctionOrComment": "Beim Klick auf einen Button wird ein ActionEvent erzeugt."
        },
        {
          "id": "39",
          "text": "Beim Klick auf dem Button wird eine Methode aufgerufen, den Klick wahrnimmt und den Text auf dem Button ändert",
          "aspects": [
            {
              "text": "Beim Klick auf dem Button wird eine Methode aufgerufen",
              "elements": [
                [
                  0,
                  54
                ]
              ],
              "aIdx": 0,
              "label": 1
            },
            {
              "text": "die den Klick wahrnimmt",
              "elements": [],
              "aIdx": 1,
              "label": 1
            },
            {
              "text": "die den Text auf dem Button ändert",
              "elements": [],
              "aIdx": 3,
              "label": 1
            }
          ],
          "correctionOrComment": "Beim Klick auf dem Button wird eine Methode aufgerufen, die den Klick wahrnimmt und den Text auf dem Button ändert"
        },
        {
          "id": "40",
          "text": "Wenn man auf dem Button klickt wird ein ActionEvent, der dann den gegebenen Befehl ausgibt, ausgeführt.",
          "aspects": [
            {
              "text": "Wenn man auf dem Button klickt wird ein ActionEvent ;; ausgeführt",
              "elements": [
                [
                  0,
                  51
                ],
                [
                  92,
                  102
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "das dann den gegebenen Befehl ausgibt",
              "elements": [],
              "aIdx": 3,
              "label": 2
            }
          ],
          "correctionOrComment": "Wenn man auf dem Button klickt wird ein ActionEvent, das dann den gegebenen Befehl ausgibt, ausgeführt."
        },
        {
          "id": "41",
          "text": "bei klick auf button wird action event ausgelöst, wen listener event gemeldet bekommt wird code ausgeführt.",
          "aspects": [
            {
              "text": "vBeim Klick auf den Button wird ein ActionEvent ausgelöst",
              "elements": [],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Wenn der Listener ein Event gemeldet bekommt",
              "elements": [],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "wird der Code ausgeführt",
              "elements": [],
              "aIdx": 3,
              "label": 1
            }
          ],
          "correctionOrComment": "Beim Klick auf den Button wird ein ActionEvent ausgelöst. Wenn der Listener ein Event gemeldet bekommt, wird der Code ausgeführt."
        },
        {
          "id": "42",
          "text": "button erstellen button zu frame hinzufügen ActionListener zu button hinzufügen bei actionlistener methode sagen was geändert werden soll hier: button.setText(Text der nach dem Klicken angezeigt werden soll) wenn man also auf den Button klickt wird der ActionListener \"\"wach\"\" und weiß dass geklickt wurde und somit kann man in der methode sagen was nach dem klicken verändert werden soll",
          "aspects": [
            {
              "text": "Wenn man also auf den Button klickt wird der ActionListener wach",
              "elements": [],
              "aIdx": 0,
              "label": 1
            },
            {
              "text": "Wenn man also auf den Button klickt wird der ActionListener wach",
              "elements": [],
              "aIdx": 1,
              "label": 1
            },
            {
              "text": "ActionListener zum Button hinzufügen",
              "elements": [],
              "aIdx": 2,
              "label": 0
            },
            {
              "text": "Der Actionlistener Methode sagen, was geändert werden soll hier, setText mit dem Text der nach dem Klicken angezeigt werden soll",
              "elements": [],
              "aIdx": 3,
              "label": 0
            }
          ],
          "correctionOrComment": "Button erstellen. Button zum Frame hinzufügen. ActionListener zum Button hinzufügen. Der Actionlistener Methode sagen, was geändert werden soll hier, setText mit dem Text der nach dem Klicken angezeigt werden soll. Wenn man also auf den Button klickt wird der ActionListener wach und weiß dass geklickt wurde und somit kann man in der Methode sagen was nach dem Klicken verändert werden soll"
        },
        {
          "id": "43",
          "text": "um was zu ändern muss die methode Actionevent eingesetzt werden das heisst wenn mann auf den button klickt soll eine aktion geführt werden zum beispiel mit dem klick nach dem man auf klcik drauf klickt wird im hintergrund eine aktion ausgeführt und mit syso \"\"wurde geklickt\"\" ausgegeben . ich hoffe ich konnte es einigermaßen erklären :)",
          "aspects": [
            {
              "text": "Um was zu ändern muss die Methode ActionEvent eingesetzt werden",
              "elements": [],
              "aIdx": 0,
              "label": 1
            }
          ],
          "correctionOrComment": "Um was zu ändern muss die Methode ActionEvent eingesetzt werden. Das heißt, wenn man auf den Button klickt, soll eine Aktion ausgeführt werden, zum Beispiel nach dem man auf Klick drauf klickt wird im Hintergrund eine Aktion ausgeführt und mit syso 'wurde geklickt' ausgegeben. Ich hoffe ich konnte es einigermaßen erklären :)"
        },
        {
          "id": "44",
          "text": "Beim drücken des Buttons wird ein Befehl ausgeführt, der den Text des Buttons verändert. Dazu wird ein Befehl eingegeben, falls der Button gedrückt wird, ändere Button.Text",
          "aspects": [],
          "correctionOrComment": "Beim Drücken des Buttons wird ein Befehl ausgeführt, der den Text des Buttons verändert. Dazu wird ein Befehl eingegeben, falls der Button gedrückt wird, ändere den Button Text"
        },
        {
          "id": "45",
          "text": "Buttonojekt besitzt ein listener objekt das den zustand ändert.",
          "aspects": [
            {
              "text": "Das Button Objekt besitzt ein Listener Objekt ",
              "elements": [],
              "aIdx": 2,
              "label": 0
            },
            {
              "text": "das den Zustand ändert",
              "elements": [],
              "aIdx": 3,
              "label": 0
            }
          ],
          "correctionOrComment": "Das Button Objekt besitzt ein Listener Objekt, das den Zustand ändert."
        },
        {
          "id": "46",
          "text": "Der ActionListener erkennt/hört den Klick des Users. Der ActionListener wird aufgerufen, indem sich die Methode actionPerformed befindet, der dann angibt was der ActionListener bei dem Klick zu machen hat, nämlich die sogenannte setText() Funktion ausführen. Diese ändert den Text des Buttons.",
          "aspects": [
            {
              "text": "Der ActionListener erkennt den Klick des Users",
              "elements": [],
              "aIdx": 0,
              "label": 1
            },
            {
              "text": "Der ActionListener erkennt den Klick des Users",
              "elements": [],
              "aIdx": 1,
              "label": 1
            },
            {
              "text": "Der ActionListener wird aufgerufen, indem sich die Methode actionPerformed befindet, der dann angibt, was der ActionListener bei dem Klick zu machen hat, nämlich die sogenannte setText() Funktion ausführen. Diese ändert den Text des Buttons",
              "elements": [],
              "aIdx": 3,
              "label": 0
            }
          ],
          "correctionOrComment": "Der ActionListener erkennt den Klick des Users. Der ActionListener wird aufgerufen, indem sich die Methode actionPerformed befindet, der dann angibt, was der ActionListener bei dem Klick zu machen hat, nämlich die sogenannte setText() Funktion ausführen. Diese ändert den Text des Buttons."
        },
        {
          "id": "47",
          "text": "auf dem Button ist ein Listener, der von einem Actionevent ein ActionPerformed auslöst",
          "aspects": [
            {
              "text": "der von einem ActionEvent ein ActionPerformed auslöst",
              "elements": [],
              "aIdx": 0,
              "label": 1
            },
            {
              "text": "der von einem ActionEvent ein ActionPerformed auslöst",
              "elements": [],
              "aIdx": 1,
              "label": 1
            },
            {
              "text": "Auf dem Button ist ein Listener",
              "elements": [],
              "aIdx": 2,
              "label": 0
            }
          ],
          "correctionOrComment": "Auf dem Button ist ein Listener, der von einem ActionEvent ein ActionPerformed auslöst"
        },
        {
          "id": "48",
          "text": "-",
          "aspects": [],
          "correctionOrComment": "-"
        },
        {
          "id": "49",
          "text": "Durch den Mausklick bemerkt der Actionlistener im Code dieses Vorgehen. Da der Actionlistener mit einer Methode verbunden ist, wird wahrscheinlich in der Mehtode ein Code implementiert sein welcher den Text auf dem Button verändert.",
          "aspects": [
            {
              "text": "Durch den Mausklick bemerkt der ActionListener im Code dieses Vorgehen",
              "elements": [],
              "aIdx": 0,
              "label": 1
            },
            {
              "text": "Durch den Mausklick bemerkt der ActionListener im Code dieses Vorgehen",
              "elements": [],
              "aIdx": 1,
              "label": 1
            },
            {
              "text": "Da der Actionlistener mit einer Methode verbunden ist, wird wahrscheinlich in der Mehtode ein Code implementiert sein welcher den Text auf dem Button verändert",
              "elements": [
                [
                  72,
                  231
                ]
              ],
              "aIdx": 3,
              "label": 0
            }
          ],
          "correctionOrComment": "Durch den Mausklick bemerkt der ActionListener im Code dieses Vorgehen. Da der Actionlistener mit einer Methode verbunden ist, wird wahrscheinlich in der Mehtode ein Code implementiert sein welcher den Text auf dem Button verändert."
        },
        {
          "id": "50",
          "text": "Der implementierte Actionlistener registriert das Event des Mausklicks. Dadurch wird die Methode des Actionlisteners aufgerufen und sie führt Ihren Code aus. Der Code der Methode ändert nun den Text auf dem Button.",
          "aspects": [
            {
              "text": "Der implementierte ActionListener registriert das Event des Mausklicks",
              "elements": [],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Der implementierte ActionListener registriert das Event des Mausklicks",
              "elements": [],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": " Dadurch wird die Methode des Actionlisteners aufgerufen und sie führt Ihren Code aus. Der Code der Methode ändert nun den Text auf dem Button",
              "elements": [
                [
                  72,
                  213
                ]
              ],
              "aIdx": 3,
              "label": 0
            }
          ],
          "correctionOrComment": "Der implementierte ActionListener registriert das Event des Mausklicks. Dadurch wird die Methode des Actionlisteners aufgerufen und sie führt Ihren Code aus. Der Code der Methode ändert nun den Text auf dem Button."
        },
        {
          "id": "51",
          "text": "Auf den Button zu Klicken führt eine ActionListener aus.In dem wir eine code schreiben was ausgefürht wird wenn wir Button zu klciken.",
          "aspects": [
            {
              "text": "Auf den Button zu Klicken führt eine ActionListener aus",
              "elements": [
                [
                  0,
                  55
                ]
              ],
              "aIdx": 0,
              "label": 1
            },
            {
              "text": "Auf den Button zu Klicken führt eine ActionListener aus",
              "elements": [
                [
                  0,
                  55
                ]
              ],
              "aIdx": 1,
              "label": 1
            },
            {
              "text": "In dem schreiben wir einen Code, der ausgefürht wird, wenn wir den Button klicken",
              "elements": [],
              "aIdx": 3,
              "label": 0
            }
          ],
          "correctionOrComment": "Auf den Button zu klicken führt eine ActionListener aus. In dem schreiben wir einen Code, der ausgefürht wird, wenn wir den Button klicken."
        },
        {
          "id": "52",
          "text": "-",
          "aspects": [],
          "correctionOrComment": "-"
        },
        {
          "id": "53",
          "text": "lbl_text || btn_klick Wenn auf den btn_klick gedrückt wird, springt der entsprechende ActionListener an (meist als anonyme Klasse umgesetzt, kann jedoch auch eine eigenständige, von ActionListener abgeleitete Klasse sein). Darin wird ein ActionEvent ausgeführt, das den Text im lbl_text verändert.",
          "aspects": [
            {
              "text": "Darin wird ein ActionEvent ausgeführt",
              "elements": [
                [
                  223,
                  260
                ]
              ],
              "aIdx": 0,
              "label": 2
            },
            {
              "text": "Wenn auf den Button gedrückt wird, springt der entsprechende ActionListener an",
              "elements": [],
              "aIdx": 1,
              "label": 1
            },
            {
              "text": "das den Text im Button verändert",
              "elements": [],
              "aIdx": 3,
              "label": 2
            }
          ],
          "correctionOrComment": "Wenn auf den Button gedrückt wird, springt der entsprechende ActionListener an (meist als anonyme Klasse umgesetzt, kann jedoch auch eine eigenständige, von ActionListener abgeleitete Klasse sein). Darin wird ein ActionEvent ausgeführt, das den Text im Button verändert."
        },
        {
          "id": "54",
          "text": "-button frägt ab ob er gekickt wird -beim klicken bekommt der button den befehl den text hzu ändern -der text wird geändert",
          "aspects": [
            {
              "text": "Der Button fragt ab, ob er geklickt wird",
              "elements": [],
              "aIdx": 1,
              "label": 1
            },
            {
              "text": "Beim klicken bekommt der Button den Befehl den Text zu ändern. Der Text wird geändert",
              "elements": [],
              "aIdx": 3,
              "label": 1
            }
          ],
          "correctionOrComment": "Der Button fragt ab, ob er geklickt wird. Beim klicken bekommt der Button den Befehl den Text zu ändern. Der Text wird geändert"
        },
        {
          "id": "55",
          "text": "Ein Listener \"\"lauscht\"\" auf Aktivitäten des Nutzers und \"\"hört\"\" somit den Klick auf den Button. Dauraufhin wird der Actionlistener aufgerufen und die Methode actionPerformed, womit die Funktion .setText() den Text auf den Button ändert.",
          "aspects": [
            {
              "text": "Dauraufhin wird der ActionListener aufgerufen",
              "elements": [],
              "aIdx": 1,
              "label": 1
            },
            {
              "text": "Ein Listener lauscht auf Aktivitäten des Nutzers und hört somit den Klick auf den Button",
              "elements": [],
              "aIdx": 2,
              "label": 1
            },
            {
              "text": "womit die Funktion setText den Text auf dem Button ändert",
              "elements": [],
              "aIdx": 3,
              "label": 1
            }
          ],
          "correctionOrComment": "Ein Listener lauscht auf Aktivitäten des Nutzers und hört somit den Klick auf den Button. Dauraufhin wird der ActionListener aufgerufen und die Methode actionPerformed, womit die Funktion setText den Text auf dem Button ändert."
        },
        {
          "id": "56",
          "text": "es wird mit einer actionEvent erzeugt",
          "aspects": [
            {
              "text": "Es wird ein ActionEvent erzeugt",
              "elements": [],
              "aIdx": 0,
              "label": 0
            }
          ],
          "correctionOrComment": "Es wird ein ActionEvent erzeugt."
        },
        {
          "id": "57",
          "text": "Dem Button wird ein Actionevent erstellt. Dieser wird beim anklicken einem Actionlistener der an dem Event dranhängt übergeben. Das heisst beim klicken weis der Actionlistener durch die Verbindung zum Event was für eine Action er ausführen soll. Dies könnte zum beispiel setIcon sein der durch klick das Bild ändert.",
          "aspects": [
            {
              "text": "der an dem Event dranhängt",
              "elements": [
                [
                  90,
                  116
                ]
              ],
              "aIdx": 2,
              "label": 2
            },
            {
              "text": "Dieses wird beim anklicken einem ActionListener ;; übergeben",
              "elements": [
                [
                  117,
                  126
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "Das heißt beim klicken weiß der ActionListener;; was für eine Action er ausführen soll",
              "elements": [
                [
                  207,
                  244
                ]
              ],
              "aIdx": 3,
              "label": 0
            },
            {
              "text": "Mit dem Button wird ein ActionEvent erstellt ",
              "elements": [],
              "aIdx": 0,
              "label": 1
            }
          ],
          "correctionOrComment": "Mit dem Button wird ein ActionEvent erstellt. Dieses wird beim anklicken einem ActionListener, der an dem Event dranhängt, übergeben. Das heißt beim klicken weiß der ActionListener durch die Verbindung zum Event was für eine Action er ausführen soll. Dies könnte zum Beispiel setIcon sein, die durch den Klick das Bild ändert."
        },
        {
          "id": "58",
          "text": "-",
          "aspects": [],
          "correctionOrComment": "-"
        },
        {
          "id": "59",
          "text": "Der Klick erzeugt einen Event. Dieser Event wird vom ActionListener aufgegriffen der mit dem \"\"Button\"\"-Objekt verbunden ist, dann wird die jeweilige Methode aufgerufen, die dem Button zugewiesen wurde. zB. : setIcon()",
          "aspects": [
            {
              "text": "Der Klick erzeugt einen Event",
              "elements": [
                [
                  0,
                  29
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": " Dieses Event wird vom ActionListener aufgegriffen",
              "elements": [],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "er mit dem Button Objekt verbunden ist",
              "elements": [],
              "aIdx": 2,
              "label": 0
            },
            {
              "text": "Dann wird die jeweilige Methode aufgerufen, die dem Button zugewiesen wurde",
              "elements": [],
              "aIdx": 3,
              "label": 1
            }
          ],
          "correctionOrComment": "Der Klick erzeugt einen Event. Dieses Event wird vom ActionListener aufgegriffen, der mit dem Button Objekt verbunden ist. Dann wird die jeweilige Methode aufgerufen, die dem Button zugewiesen wurde."
        },
        {
          "id": "60",
          "text": "Der Klick auf einen Button erzeugt ein Action-Event. Damit nach dem Klick irgendeine Reaktion ausgeführt wird, hängt man an das Objekt einen Listener an. Dieser Listener erzeugt dann das Event und der Code wird ausgeführt.",
          "aspects": [
            {
              "text": "Der Klick auf einen Button erzeugt ein ActionEvent",
              "elements": [],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Der Klick auf einen Button erzeugt ein ActionEvent. Damit nach dem Klick irgendeine Reaktion ausgeführt wird, hängt man an das Objekt einen Listener an",
              "elements": [],
              "aIdx": 2,
              "label": 0
            },
            {
              "text": "Dieser Listener erzeugt dann das Event und der Code wird ausgeführt",
              "elements": [
                [
                  154,
                  221
                ]
              ],
              "aIdx": 3,
              "label": 1
            }
          ],
          "correctionOrComment": "Der Klick auf einen Button erzeugt ein ActionEvent. Damit nach dem Klick irgendeine Reaktion ausgeführt wird, hängt man an das Objekt einen Listener an. Dieser Listener erzeugt dann das Event und der Code wird ausgeführt."
        },
        {
          "id": "61",
          "text": "Beim Klick auf den Button wird ein event ausgelöst, dieses wird von ActionListener aufgenommen und die entsprechende methode ausgeführt.",
          "aspects": [
            {
              "text": "Beim Klick auf den Button wird ein Event ausgelöst",
              "elements": [],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Dieses wird von ActionListener aufgenommen",
              "elements": [],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": " und die entsprechende Methode ausgeführt",
              "elements": [],
              "aIdx": 3,
              "label": 1
            }
          ],
          "correctionOrComment": "Beim Klick auf den Button wird ein Event ausgelöst. Dieses wird von ActionListener aufgenommen und die entsprechende Methode ausgeführt."
        },
        {
          "id": "62",
          "text": "Durch den Klick entsteht ein \"\"Action- Event\"\". Ein \"\"Listener\"\" reagiert auf dieses \"\"Event\"\" und führt eine Aktion durch. In diesem Fall wird der Schriftzug auf den Button geändert.",
          "aspects": [
            {
              "text": "Durch den Klick entsteht ein ActionEvent",
              "elements": [],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Ein Listener reagiert auf dieses Event",
              "elements": [],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": " Ein Listener ;; ührt eine Aktion durch. In diesem Fall wird der Schriftzug auf den Button geändert",
              "elements": [
                [
                  100,
                  182
                ]
              ],
              "aIdx": 3,
              "label": 0
            }
          ],
          "correctionOrComment": "Durch den Klick entsteht ein ActionEvent. Ein Listener reagiert auf dieses Event und führt eine Aktion durch. In diesem Fall wird der Schriftzug auf den Button geändert."
        }
      ]
    },
    {
      "id": "31",
      "title": "Threads Synchronisation",
      "text": "Warum braucht man bei der Arbeit mit Threads Synchronisation?",
      "type": "reason",
      "aspects": [
        {
          "text": "Man muss vermeiden, dass verschiedene Threads gleichzeitig auf Daten oder Objekte zugreifen"
        },
        {
          "text": "Sonst kann es zur Zerstörung von Werten und zu inkonsistenten Zuständen kommen"
        }
      ],
      "referenceAnswers": [
        {
          "id": "ref1",
          "text": "Man muss vermeiden, dass verschiedene Threads gleichzeitig auf Daten oder Objekte zugreifen, weil es dadurch zur Zerstörung von Werten und zu inkonsistenten Zuständen kommen kann.",
          "aspects": [
            {
              "text": "Man muss vermeiden, dass verschiedene Threads gleichzeitig auf Daten oder Objekte zugreifen",
              "aIdx": 0,
              "elements": [
                [
                  0,
                  91
                ]
              ],
              "label": 0
            },
            {
              "text": "weil es dadurch zur Zerstörung von Werten und zu inkonsistenten Zuständen kommen kann",
              "aIdx": 1,
              "elements": [
                [
                  93,
                  178
                ]
              ],
              "label": 0
            }
          ]
        }
      ],
      "studentAnswers": [
        {
          "id": "1",
          "text": "ja damit threads miteinander daten austauschen können , müssen sie auf den selben speicherbereich zugreifen. ( gemeinsamer zugriff auf daten.)",
          "aspects": [],
          "correctionOrComment": "Damit Threads miteinander Daten austauschen können, müssen sie auf den selben Speicherbereich zugreifen."
        },
        {
          "id": "2",
          "text": "durch Synchronisation werden die Prozesse parallel laufen. Ohne Synchronisation würde man Einen Prozess mit dem anderen Prozess überschreiben.",
          "aspects": [],
          "correctionOrComment": "Durch Synchronisation werden die Prozesse parallel laufen. Ohne Synchronisation würde man einen Prozess mit dem anderen Prozess überschreiben."
        },
        {
          "id": "3",
          "text": "Damit ein Deadlock vermieden werden kann bei 2 paralelen threads",
          "aspects": [],
          "correctionOrComment": "Damit ein Deadlock vermieden werden kann bei 2 parallelen Threads"
        },
        {
          "id": "4",
          "text": "Um Deadlocks zu meiden",
          "aspects": [],
          "correctionOrComment": "Um Deadlocks zu meiden"
        },
        {
          "id": "5",
          "text": "Damit die Threads Daten einfach durch überschreiben der Zieldaten austauschen können.",
          "aspects": [],
          "correctionOrComment": "Damit die Threads Daten einfach durch überschreiben der Zieldaten austauschen können."
        },
        {
          "id": "6",
          "text": "Da zwei Threads, die die gleiche Variable verwenden, jedoch unterschiedliche Dinge mit ihr (beispielsweise) berechnen, durcheinander geraten oder Deadlocks 'herstellen'. Um Deadlocks zu vermeiden wird 'synchronized', (ein Thread wartet auf den anderen, bis die Variable für ihn frei ist.)",
          "aspects": [
            {
              "text": "Ein Thread wartet auf den anderen, bis die Variable für ihn frei ist",
              "elements": [],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Da zwei Threads, die die gleiche Variable verwenden, jedoch unterschiedliche Dinge mit ihr (beispielsweise) berechnen, durcheinander geraten oder Deadlocks 'herstellen'",
              "elements": [
                [
                  0,
                  168
                ]
              ],
              "aIdx": 1,
              "label": 1
            }
          ],
          "correctionOrComment": "Da zwei Threads, die die gleiche Variable verwenden, jedoch unterschiedliche Dinge mit ihr (beispielsweise) berechnen, durcheinander geraten oder Deadlocks 'herstellen'. Um Deadlocks zu vermeiden wird synchronized. Ein Thread wartet auf den anderen, bis die Variable für ihn frei ist."
        },
        {
          "id": "7",
          "text": "Das wenn zwei Threads oder mehr mit den gleichen Attributen arbeiten es zu keiner überschneidung kommt und die Threads sich gegenseitig behindern. Deswegen vergibt man Synchronisation Schlüssel die die Threads brauchen um zu arbeite. Jedoch muss man afpassen das es zu keinem Big-Lock kommt.",
          "aspects": [
            {
              "text": "Damit wenn zwei Threads oder mehr mit den gleichen Attributen arbeiten es zu keiner Überschneidung kommt und die Threads sich gegenseitig behindern",
              "elements": [],
              "aIdx": 0,
              "label": 0
            }
          ],
          "correctionOrComment": "Damit wenn zwei Threads oder mehr mit den gleichen Attributen arbeiten es zu keiner Überschneidung kommt und die Threads sich gegenseitig behindern. Deswegen vergibt man Synchronisation Schlüssel die die Threads brauchen um zu arbeite. Jedoch muss man afpassen das es zu keinem Big-Lock kommt."
        },
        {
          "id": "8",
          "text": "Wenn Threads parallel laufen, kann es sein, dass Änderungen nicht übernommen werden da jeder einzelne seinen Code ausführt. Damit man aber keine Daten verliert, sollte man mit synchronized() arbeiten. Dazu benutzt man auch Monitore. So können sie sich auch nicht gegenseitig in kritischen Abschnitten hindern und zu einem Deadlock führen, wenn man die Reihenfolge der Synchronisation einhält.",
          "aspects": [
            {
              "text": "Wenn Threads parallel laufen, kann es sein, dass Änderungen nicht übernommen werden da jeder einzelne seinen Code ausführt. Damit man aber keine Daten verliert, sollte man mit synchronized arbeiten",
              "elements": [],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Wenn Threads parallel laufen, kann es sein, dass Änderungen nicht übernommen werden da jeder einzelne seinen Code ausführt. Damit man aber keine Daten verliert, sollte man mit synchronized arbeiten. Dazu benutzt man auch Monitore. So können sie sich auch nicht gegenseitig in kritischen Abschnitten hindern und zu einem Deadlock führen, wenn man die Reihenfolge der Synchronisation einhält."
        },
        {
          "id": "9",
          "text": "rufen sich 2 Threads gegenseitig auf welche gleiche Befehlsketten ausführen (z. B Variabne wird um 1 erhöht) sobald sie beide fertig sind wird beim Letzten Schritt des letzten Threads nicht ausgeführt dafür gibt es einen besstimmtes Beegriff dafür.",
          "aspects": [],
          "correctionOrComment": "Rufen sich 2 Threads gegenseitig auf, welche gleiche Befehlsketten ausführen (z. B Variabne wird um 1 erhöht), sobald sie beide fertig sind wird beim letzten Schritt des letzten Threads nichts ausgeführt. Dafür gibt es einen bestimmtes Beegriff."
        },
        {
          "id": "10",
          "text": "Das Threads in einer Multithreaded-Anwendung Daten durch einfaches überschreiben der Methoden Zieldaten austauschen können.",
          "aspects": [],
          "correctionOrComment": "Da Threads in einer Multithread-Anwendung Daten durch einfaches überschreiben der Methoden Zieldaten austauschen können."
        },
        {
          "id": "11",
          "text": "Um die Daten in einer Multithreaded-Anwendung überschreiben zu können ,ohne dass Damit die Datenintegrität nicht verloren gehen.Threads können Daten einfach durch überschreiben der Zieldaten austauschen Bei der Modifikation besteht die Gefahr des Lost Update, wenn Threads Daten parallel ändern.",
          "aspects": [
            {
              "text": "wenn Threads Daten parallel ändern",
              "elements": [
                [
                  260,
                  294
                ]
              ],
              "aIdx": 0,
              "label": 1
            },
            {
              "text": "Um die Daten in einer Multithreaded-Anwendung überschreiben zu können, ohne dass damit die Datenintegrität verloren geht ;; Bei der Modifikation besteht die Gefahr des Lost Update",
              "elements": [
                [
                  203,
                  258
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Um die Daten in einer Multithreaded-Anwendung überschreiben zu können, ohne dass damit die Datenintegrität verloren geht. Threads können Daten einfach durch überschreiben der Zieldaten austauschen Bei der Modifikation besteht die Gefahr des Lost Update, wenn Threads Daten parallel ändern."
        },
        {
          "id": "12",
          "text": "Da es ohne Synchronisation zum Verlust von Daten kommen kann bzw. Threads hin und her springen obwohl sie evt. gerade etwas berechnen.",
          "aspects": [
            {
              "text": "Da es ohne Synchronisation zum Verlust von Daten kommen kann",
              "elements": [
                [
                  0,
                  60
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Da es ohne Synchronisation zum Verlust von Daten kommen kann oder Threads hin und her springen obwohl sie eventuell gerade etwas berechnen."
        },
        {
          "id": "13",
          "text": "Weil bei der Datenaustausch die Gefahr besteht das durch Lost Update Threads Daten parallel ändert.",
          "aspects": [
            {
              "text": "Weil beim Datenaustausch die Gefahr besteht, dass ;; Threads Daten parallel ändern",
              "elements": [],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "durch Lost Update Threads Daten parallel ändern",
              "elements": [],
              "aIdx": 1,
              "label": 2
            }
          ],
          "correctionOrComment": "Weil beim Datenaustausch die Gefahr besteht, dass durch Lost Update Threads Daten parallel ändern"
        },
        {
          "id": "14",
          "text": "Weil alle Threads aktuell sein müssen, wenn ein Thread nicht aktuell ist, ist es nicht gerade einfach bzw. effektiv mit den Threads zu arbeiten. Es kann aber gut sein, dass Probleme bei der Synchronisation auftreten.",
          "aspects": [],
          "correctionOrComment": "Weil alle Threads aktuell sein müssen, wenn ein Thread nicht aktuell ist, ist es nicht gerade einfach bzw. effektiv mit den Threads zu arbeiten. Es kann aber gut sein, dass Probleme bei der Synchronisation auftreten."
        },
        {
          "id": "15",
          "text": "Man benötigt erst mal threads es müssen min 2 threads vorhanden sein diese müssen gestartet werden und durchlaufen werden dort können sie Daten durch überschreiben der Zieldaten einfach austauschen",
          "aspects": [],
          "correctionOrComment": "Man benötigt erst mal Threads. Es müssen mindestens 2 Threads vorhanden sein. Diese müssen gestartet werden und durchlaufen werden dort können sie Daten durch überschreiben der Zieldaten einfach austauschen"
        },
        {
          "id": "16",
          "text": "man braucht bei Threads eine synchronistion , denn wenn beides Threads laufen und änderungen vorgenommen werden, soll durch die synchronisation erstmal alle befehle oder Operationen der erste thread aufgeführt werden , bevor das zweite Thread den kritischen abschnitt erreicht",
          "aspects": [
            {
              "text": " sollen durch die Synchronisation erstmal alle Befehle oder Operationen des ersten Threads aufgeführt werden, bevor der zweite Thread den kritischen Abschnitt erreicht",
              "elements": [],
              "aIdx": 0,
              "label": 0
            }
          ],
          "correctionOrComment": "Man braucht bei Threads eine Synchronistion, denn wenn beide Threads laufen und Änderungen vorgenommen werden, sollen durch die Synchronisation erstmal alle Befehle oder Operationen des ersten Threads aufgeführt werden, bevor der zweite Thread den kritischen Abschnitt erreicht"
        },
        {
          "id": "17",
          "text": "damit die Threads nicht nicht mit ein ander stoßen wenn ein thread ein wert benutzt und den wert verändert bekommt das andere thread nicht den gleichen wert. wir brauchen synchronisation , erst wird die erste anweisung nicht gestört durchgeführt und dann wenn er fertig ist , kann ein andere beginnen.",
          "aspects": [
            {
              "text": "damit die Threads nicht aufeinander stoßen ;; Erst wird die erste Anweisung nicht gestört durchgeführt und dann wenn diese fertig ist, kann ein andere beginnen",
              "elements": [],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "wenn ein Thread ein Wert benutzt und den Wert verändert bekommt der andere Thread nicht den gleichen Wert",
              "elements": [],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Damit die Threads nicht aufeinander stoßen wenn ein Thread ein Wert benutzt und den Wert verändert bekommt der andere Thread nicht den gleichen Wert. Wir brauchen Synchronisation. Erst wird die erste Anweisung nicht gestört durchgeführt und dann wenn diese fertig ist, kann ein andere beginnen."
        },
        {
          "id": "18",
          "text": "Durch die Anwendung können sie dann die Zieldaten überschreiben und austauschen.",
          "aspects": [],
          "correctionOrComment": "Durch die Anwendung können sie dann die Zieldaten überschreiben und austauschen."
        },
        {
          "id": "19",
          "text": "Die Synchronisation soll verhindern, dass man beispielsweise einen Deadlock hat.Außerdem wird damit ein kritischer Abschnitt erreicht, den man korrekt programmieren soll, sodass die Threads keine Fehler erzeugen können.",
          "aspects": [],
          "correctionOrComment": "Die Synchronisation soll verhindern, dass man beispielsweise einen Deadlock hat. Außerdem wird damit ein kritischer Abschnitt erreicht, den man korrekt programmieren soll, sodass die Threads keine Fehler erzeugen können."
        },
        {
          "id": "20",
          "text": "bei der Modifikation bessteht die gefahr dass lost update wenn Threads Daten parallel andern",
          "aspects": [
            {
              "text": "wenn Threads Daten parallel ändern",
              "elements": [],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Bei der Modifikation besteht die Gefahr dass Lost Update",
              "elements": [],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Bei der Modifikation besteht die Gefahr dass Lost Update, wenn Threads Daten parallel ändern"
        },
        {
          "id": "21",
          "text": "Weil es ansonsten passieren kann , das änderungen verloren gehen, wenn ein thread seinen kritischen pfad nicht alleine ablaufen kann. Diese gefahr besteht weil mehrere threads eines Prozesses denselben Speicher teilen.",
          "aspects": [
            {
              "text": "wenn ein thread seinen kritischen pfad nicht alleine ablaufen kann",
              "elements": [
                [
                  66,
                  132
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Weil es ansonsten passieren kann , das änderungen verloren gehen",
              "elements": [
                [
                  0,
                  64
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Weil es ansonsten passieren kann , das änderungen verloren gehen, wenn ein thread seinen kritischen pfad nicht alleine ablaufen kann. Diese gefahr besteht weil mehrere threads eines Prozesses denselben Speicher teilen."
        },
        {
          "id": "22",
          "text": "-",
          "aspects": [],
          "correctionOrComment": "-"
        },
        {
          "id": "23",
          "text": "sodass niemals zwei Threads gleichzeitig auf eine Ressource zugreifen können.",
          "aspects": [
            {
              "text": "Sodass niemals zwei Threads gleichzeitig auf eine Ressource zugreifen können.",
              "elements": [],
              "aIdx": 0,
              "label": 0
            }
          ],
          "correctionOrComment": "Sodass niemals zwei Threads gleichzeitig auf eine Ressource zugreifen können."
        },
        {
          "id": "24",
          "text": "Problem bei einem Multithread, es kann passieren das wir eine \"\"Race-Condition\"\" haben. Da die Threads unwillkürlich hin und her springen, schreiben bzw lesen sie in unterschiedlicher reihenfolge in die Daten/Speicher. Was unser Programm behindert.",
          "aspects": [],
          "correctionOrComment": "Das Problem bei einem Multithread ist, es kann passieren das wir eine Race-Condition haben. Da die Threads unwillkürlich hin und her springen, schreiben bzw lesen sie in unterschiedlicher reihenfolge in die Daten/Speicher. Was unser Programm behindert."
        },
        {
          "id": "25",
          "text": "Da man sonst Deadlocks (ein Thread wartet auf den anderen und umgekehrt) bekommen kann oder Einträge gehen verloren da zwei Threads gleichzeitig an etwas arbeiten.",
          "aspects": [
            {
              "text": "da zwei Threads gleichzeitig an etwas arbeiten",
              "elements": [
                [
                  116,
                  162
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Einträge gehen verloren",
              "elements": [
                [
                  92,
                  115
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Da man sonst Deadlocks (ein Thread wartet auf den anderen und umgekehrt) bekommen kann oder Einträge gehen verloren da zwei Threads gleichzeitig an etwas arbeiten."
        },
        {
          "id": "26",
          "text": "Um Threds paralell laufenzulassen, und um das nicht der gleiche . Man benötigt zuerst mal Threads mindestens 2. Threads müssen gestartet werden und durchlaufen können. Synchonize wird benötigt um die 2 oder mehrer Threads als erstet komplett durchlaufenzulassen und dann, wenn der der einer der Thread durchgelaufen ist der andere wenn er auf die gleiche Methode zugreift nicht ins Gehege kommt.",
          "aspects": [
            {
              "text": "wenn einer der Threads durchgelaufen ist der andere dran, wenn er auf die gleiche Methode zugreift, um nicht ins Gehege zu kommen",
              "elements": [],
              "aIdx": 0,
              "label": 0
            }
          ],
          "correctionOrComment": "Um Threds parallel laufen zulassen, und um das nicht der Gleiche . Man benötigt zuerst mal Threads, mindestens 2. Threads müssen gestartet werden und durchlaufen können. Synchonize wird benötigt um die 2 oder mehrere Threads als erstes komplett durchlaufenzulassen und dann, wenn einer der Threads durchgelaufen ist der andere dran, wenn er auf die gleiche Methode zugreift, um nicht ins Gehege zu kommen."
        },
        {
          "id": "27",
          "text": "Synchronisation bewirkt das bei der Arbeit mit mehreren Threats nur einer auf eine Methode oder ein Objekt zugreifen kann. So wird verhindert das wenn z.B. zwei Threats die gleiche Variable verändern kein Wert verloren geht.",
          "aspects": [
            {
              "text": "Synchronisation bewirkt das bei der Arbeit mit mehreren Threats nur einer auf eine Methode oder ein Objekt zugreifen kann",
              "elements": [
                [
                  0,
                  121
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "So wird verhindert das wenn z.B. zwei Threats die gleiche Variable verändern kein Wert verloren geh",
              "elements": [
                [
                  123,
                  222
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Synchronisation bewirkt das bei der Arbeit mit mehreren Threats nur einer auf eine Methode oder ein Objekt zugreifen kann. So wird verhindert das wenn z.B. zwei Threats die gleiche Variable verändern kein Wert verloren geht."
        },
        {
          "id": "28",
          "text": "Mehrere Threads könnten auf dieselben Daten oder Ressourcen zugreifen. Damit dabei keine Änderung verloren geht und damit kein Deadlock entsteht, werden die kritischen Abschnitte synchronized.",
          "aspects": [
            {
              "text": "Damit dabei keine Änderung verloren geht ;; werden die kritischen Abschnitte synchronized",
              "elements": [
                [
                  71,
                  111
                ],
                [
                  146,
                  191
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Mehrere Threads könnten auf dieselben Daten oder Ressourcen zugreifen. Damit dabei keine Änderung verloren geht und damit kein Deadlock entsteht, werden die kritischen Abschnitte synchronized."
        },
        {
          "id": "29",
          "text": "Um bei Kritischen Zuständen keinen Verlust von Daten oder Informationen zuzulassen, wird ein Block, der auf diese Informationen zurückgreift mit Hilfe der der Synchronisation gekennzeichnet. Wenn mehrere Threads auf die gleichen Daten zurückgreifen, kann es passieren, dass diese Daten zerstört werden. Die Synchronisation verhindert dies, in dem Sie regelt in welcher Reihenfolge die Threads zugriff haben.",
          "aspects": [
            {
              "text": "Um bei Kritischen Zuständen keinen Verlust von Daten oder Informationen zuzulassen, wird ein Block, der auf diese Informationen zurückgreift mit Hilfe der der Synchronisation gekennzeichnet. Wenn mehrere Threads auf die gleichen Daten zurückgreifen, kann es passieren, dass diese Daten zerstört werden",
              "elements": [
                [
                  0,
                  301
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "Die Synchronisation verhindert dies, in dem Sie regelt in welcher Reihenfolge die Threads zugriff haben",
              "elements": [
                [
                  303,
                  406
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ],
          "correctionOrComment": "Um bei Kritischen Zuständen keinen Verlust von Daten oder Informationen zuzulassen, wird ein Block, der auf diese Informationen zurückgreift mit Hilfe der der Synchronisation gekennzeichnet. Wenn mehrere Threads auf die gleichen Daten zurückgreifen, kann es passieren, dass diese Daten zerstört werden. Die Synchronisation verhindert dies, in dem Sie regelt in welcher Reihenfolge die Threads zugriff haben."
        },
        {
          "id": "30",
          "text": "Damit es nicht zu einer sogenannten Racecondition kommt. Diese könnte z.B.dann auftreten, wenn zwei Threads auf dieselben Variablen zugreifen und diese verändern. Die Änderungen des einen Threads könnten dann von denen des anderen überschrieben werden (die Threads \"\"liefern sich einen Rennen\"\") und damit verloren gehen. Das Programm arbeitet dann nicht mehr wie erwartet/ gedacht. Mithilfe von Synchronisation kann dies verhindert werden, indem Code vor dem gemeinsamen Zugriff geschützt wird.",
          "aspects": [
            {
              "text": "Mithilfe von Synchronisation kann dies verhindert werden, indem Code vor dem gemeinsamen Zugriff geschützt wird",
              "elements": [
                [
                  383,
                  494
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Damit es nicht zu einer sogenannten Racecondition kommt. Diese könnte z.B.dann auftreten, wenn zwei Threads auf dieselben Variablen zugreifen und diese verändern. Die Änderungen des einen Threads könnten dann von denen des anderen überschrieben werden (die Threads \"\"liefern sich einen Rennen\"\") und damit verloren gehen",
              "elements": [
                [
                  0,
                  320
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Damit es nicht zu einer sogenannten Racecondition kommt. Diese könnte z.B.dann auftreten, wenn zwei Threads auf dieselben Variablen zugreifen und diese verändern. Die Änderungen des einen Threads könnten dann von denen des anderen überschrieben werden (die Threads \"\"liefern sich einen Rennen\"\") und damit verloren gehen. Das Programm arbeitet dann nicht mehr wie erwartet/ gedacht. Mithilfe von Synchronisation kann dies verhindert werden, indem Code vor dem gemeinsamen Zugriff geschützt wird."
        },
        {
          "id": "31",
          "text": "Threads können Daten in einer Multithreaded Anwendung einfach durch überschreiben der Zieldaten austauschen. Es kommt so zu inkonsistenten Daten wenn Threads Daten zeitgleich ändern.In Java kommt das Monitorkonzept zum einsatz.",
          "aspects": [
            {
              "text": "wenn Threads Daten zeitgleich ändern",
              "elements": [
                [
                  145,
                  181
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Es kommt so zu inkonsistenten Daten ",
              "elements": [
                [
                  109,
                  144
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Threads können Daten in einer Multithreaded Anwendung einfach durch überschreiben der Zieldaten austauschen. Es kommt so zu inkonsistenten Daten wenn Threads Daten zeitgleich ändern.In Java kommt das Monitorkonzept zum einsatz."
        },
        {
          "id": "32",
          "text": "das es über benutzbar ist.",
          "aspects": [],
          "correctionOrComment": "das es über benutzbar ist."
        },
        {
          "id": "33",
          "text": "Damit Threads auch parallel arbeiten können und weil es auch die Sicherheit steigert.",
          "aspects": [],
          "correctionOrComment": "Damit Threads auch parallel arbeiten können und weil es auch die Sicherheit steigert."
        },
        {
          "id": "34",
          "text": "Damit es synchron ist",
          "aspects": [],
          "correctionOrComment": "Damit es synchron ist"
        },
        {
          "id": "35",
          "text": "Damit mehrere Threads gleichzeitig arbeiten können, ohne das Ergebnis zu verfälschen.",
          "aspects": [
            {
              "text": "Damit mehrere Threads gleichzeitig arbeiten können, ohne das Ergebnis zu verfälschen",
              "elements": [
                [
                  0,
                  84
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Damit mehrere Threads gleichzeitig arbeiten können, ohne das Ergebnis zu verfälschen."
        },
        {
          "id": "36",
          "text": "damit keine Anwesiungen verloren gehen, wenn Threads ihre Anweisungen gleichzeitig ändern.",
          "aspects": [
            {
              "text": "wenn Threads ihre Anweisungen gleichzeitig ändern",
              "elements": [
                [
                  40,
                  89
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Damit keine Anweisungen verloren gehen",
              "elements": [],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Damit keine Anweisungen verloren gehen, wenn Threads ihre Anweisungen gleichzeitig ändern."
        },
        {
          "id": "37",
          "text": "Weil das sehr wichtig ist, ohne die Synchronisation würde es nicht laufen wie man es erwartet. Es gibt aber Probleme mit der Synchronisation die folgende sind: - ...... - ...... - ......",
          "aspects": [],
          "correctionOrComment": "Weil das sehr wichtig ist, ohne die Synchronisation würde es nicht laufen wie man es erwartet. Es gibt aber Probleme mit der Synchronisation die folgende sind"
        },
        {
          "id": "38",
          "text": "Manchmal ,wenn zwei Thread gleichzeitig und parallel laufen ,können sich überschreiben, für Korriegieren dieser Fehler und bessere Update , kann man durch Synchronisation und mit der Reihefolge arbeiten",
          "aspects": [
            {
              "text": "Manchmal, wenn zwei Thread gleichzeitig und parallel laufen",
              "elements": [],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "können sie sich überschreiben",
              "elements": [],
              "aIdx": 1,
              "label": 1
            }
          ],
          "correctionOrComment": "Manchmal, wenn zwei Thread gleichzeitig und parallel laufen, können sie sich überschreiben. Zum Korriegieren dieser Fehler und bessere Update , kann man durch Synchronisation und mit der Reihefolge arbeiten"
        },
        {
          "id": "39",
          "text": "Wenn zwei oder mehrere parallel laufende Threads dasselbe Objekt ansprechen, kann es zu Problemem kommen, da beide gleichzeitig das Objekt ändern. Deswegen benutzt man Monitore, wobei die dazugehörigen Objekte in ein Monitor eingeschlossen werden. Eingekapselt werden kritische Abschnitte.",
          "aspects": [
            {
              "text": "es zu Problemem kommen, da beide gleichzeitig das Objekt ändern",
              "elements": [
                [
                  82,
                  145
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "es zu Problemem kommen, da beide gleichzeitig das Objekt ändern",
              "elements": [
                [
                  82,
                  145
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Wenn zwei oder mehrere parallel laufende Threads dasselbe Objekt ansprechen, kann es zu Problemem kommen, da beide gleichzeitig das Objekt ändern. Deswegen benutzt man Monitore, wobei die dazugehörigen Objekte in ein Monitor eingeschlossen werden. Eingekapselt werden kritische Abschnitte."
        },
        {
          "id": "40",
          "text": "Die\"\"Lost\"\" Upgrade können verloren gehen wenn man die Threads daten nebeneinander ändert.",
          "aspects": [
            {
              "text": "wenn die Threads Daten nebeneinander ändern",
              "elements": [],
              "aIdx": 0,
              "label": 1
            },
            {
              "text": "Die Lost Upgrades können verloren gehen",
              "elements": [],
              "aIdx": 1,
              "label": 2
            }
          ],
          "correctionOrComment": "Die Lost Upgrades können verloren gehen, wenn die Threads Daten nebeneinander ändern."
        },
        {
          "id": "41",
          "text": "Ohne Synchronisation besteht die Gefahr, Daten zu verlieren. Das kann passieren, wenn Threads parallel Daten ändern.",
          "aspects": [
            {
              "text": "Das kann passieren, wenn Threads parallel Daten ändern",
              "elements": [
                [
                  61,
                  115
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Ohne Synchronisation besteht die Gefahr, Daten zu verlieren",
              "elements": [
                [
                  0,
                  59
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Ohne Synchronisation besteht die Gefahr, Daten zu verlieren. Das kann passieren, wenn Threads parallel Daten ändern."
        },
        {
          "id": "42",
          "text": "man braucht dies, so dass bei der modifikation keine Gefahr des Lost Update bestehen könnte, wenn Threads Daten parallel ändern. Und damit auch die datenintegritität behaltet werden könnte.",
          "aspects": [
            {
              "text": "wenn Threads Daten parallel ändern",
              "elements": [
                [
                  93,
                  127
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Man braucht dies, so dass bei der Modifikation keine Gefahr des Lost Update bestehen könnte",
              "elements": [],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Man braucht dies, so dass bei der Modifikation keine Gefahr des Lost Update bestehen könnte, wenn Threads Daten parallel ändern. Und damit auch die Datenintegritität behaltet werden könnte."
        },
        {
          "id": "43",
          "text": "Solange nur ein Thread eine bestimme Methode aufruft, hat man die Garantie, dass der COde von der ersten bis letzten Anweisung durchlaufen wird. Bei mehreren Threads, könnte einer Threads eine Methode in einem nicht ausreichenden Zustand hinterlassen. Der Thread, der den Objektzustand vom Vorgänger übernimmt, produziert möglicherweise etwas falsches. Deshalb ist synchronisation wichtig.",
          "aspects": [],
          "correctionOrComment": "Solange nur ein Thread eine bestimme Methode aufruft, hat man die Garantie, dass der Code von der ersten bis zur letzten Anweisung durchlaufen wird. Bei mehreren Threads, könnte einer der Threads eine Methode in einem nicht ausreichenden Zustand hinterlassen. Der Thread, der den Objektzustand vom Vorgänger übernimmt, produziert möglicherweise etwas falsches. Deshalb ist synchronisation wichtig."
        },
        {
          "id": "44",
          "text": "damit die Threads nicht gegeneinander laufen wenn mehrere methoden aufgerufen werden. es könnte zu einem Deadlock führen wenn die Synchronisation nicht ordentlich ist.",
          "aspects": [
            {
              "text": "Damit die Threads nicht gegeneinander laufen wenn mehrere Methoden aufgerufen werden",
              "elements": [],
              "aIdx": 0,
              "label": 0
            }
          ],
          "correctionOrComment": "Damit die Threads nicht gegeneinander laufen wenn mehrere Methoden aufgerufen werden. Es könnte zu einem Deadlock führen wenn die Synchronisation nicht ordentlich ist."
        },
        {
          "id": "45",
          "text": "Weil Threads die Zieldaten durch überschreiben einfach löschen können braucht man die Synchronisation Vor allem wenn die Threads paralell geändert werden Außerdem sollten Deadlocks durch Einhaltung der Reihenfolge bei der Synchronisation vermieden werden",
          "aspects": [],
          "correctionOrComment": "Weil Threads die Zieldaten durch überschreiben einfach löschen können braucht man die Synchronisation. Vor allem wenn die Threads paralell geändert werden. Außerdem sollten Deadlocks durch Einhaltung der Reihenfolge bei der Synchronisation vermieden werden"
        },
        {
          "id": "46",
          "text": "Wenn man mehrere Threads benutzt kann es vorkommen dass z.B. verschiedene Methoden die gleichen Variablen besitzt und darduch die Variablen \"\"überschrieben\"\" werden. Wodurch dass Ergebnis sich ändert. Nun benutzt man Syncronized, um eine Reihenfolge einzubauen, die kritische Bereiche nacheinander abarbeitet. Somit wird verhindert, dass sich die Threads gegenseitig \"\"stören\"\".",
          "aspects": [
            {
              "text": "Nun benutzt man Syncronized, um eine Reihenfolge einzubauen, die kritische Bereiche nacheinander abarbeitet. Somit wird verhindert, dass sich die Threads gegenseitig stören",
              "elements": [],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Wenn man mehrere Threads benutzt kann es vorkommen dass z.B. verschiedene Methoden die gleichen Variablen besitzt und darduch die Variablen überschrieben werden",
              "elements": [],
              "aIdx": 1,
              "label": 1
            }
          ],
          "correctionOrComment": "Wenn man mehrere Threads benutzt kann es vorkommen dass z.B. verschiedene Methoden die gleichen Variablen besitzt und darduch die Variablen überschrieben werden. Wodurch dass Ergebnis sich ändert. Nun benutzt man Syncronized, um eine Reihenfolge einzubauen, die kritische Bereiche nacheinander abarbeitet. Somit wird verhindert, dass sich die Threads gegenseitig stören."
        },
        {
          "id": "47",
          "text": "Bei der modifikation betseht die gefahr das die threads gleichzeitig laufen und sich überschneiden. das heisst das die daten parallel geändert werden. zb. in einer multithreadet können daten einfach überschrieben werden",
          "aspects": [
            {
              "text": "Bei der Modifikation besteht die Gefahr, dass die Threads gleichzeitig laufen und sich überschneiden",
              "elements": [],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "n einem Multithread können Daten einfach überschrieben werden",
              "elements": [],
              "aIdx": 1,
              "label": 1
            }
          ],
          "correctionOrComment": "Bei der Modifikation besteht die Gefahr, dass die Threads gleichzeitig laufen und sich überschneiden. Das heißt, dass die Daten parallel geändert werden. In einem Multithread können Daten einfach überschrieben werden"
        },
        {
          "id": "48",
          "text": "Weil Threads wenn sie zur selben Aufgabe gehören auf dieselben Resurcen zugreifen müssen. Es kann aber immer nur ein Threads die jweilige Resurce bearbeiten nicht abre beide.",
          "aspects": [
            {
              "text": "Es kann aber immer nur einer der Threads die jeweilige Resourcen bearbeiten nicht aber beide.",
              "elements": [],
              "aIdx": 0,
              "label": 0
            }
          ],
          "correctionOrComment": "Weil Threads, wenn sie zur selben Aufgabe gehören auf dieselben Resourcen zugreifen müssen. Es kann aber immer nur einer der Threads die jeweilige Resourcen bearbeiten nicht aber beide."
        },
        {
          "id": "49",
          "text": "Threads in einer Mulitthreaded-Anwendung können Daten einfach durch überschreiben der Zieldaten austauschen.",
          "aspects": [],
          "correctionOrComment": "Threads in einer Mulitthreaded-Anwendung können Daten einfach durch überschreiben der Zieldaten austauschen."
        },
        {
          "id": "50",
          "text": "Um ein Deadlock zu vermeiden.",
          "aspects": [],
          "correctionOrComment": "Um ein Deadlock zu vermeiden."
        },
        {
          "id": "51",
          "text": "Um die jeweils mit einem anderen abzugleichen und das aktuelle ubdaten bei falschem synchronisieren kann ein Deadlock entstehen zum beispiel wenn ein bankkonto mit einem anderen verglichen wird.",
          "aspects": [],
          "correctionOrComment": "Um die jeweils mit einem anderen abzugleichen und das aktuelle updaten bei falschem synchronisieren kann ein Deadlock entstehen. zum beispiel wenn ein bankkonto mit einem anderen verglichen wird."
        },
        {
          "id": "52",
          "text": "Um Threads ein bestimmtes Objekt nach der Reihenfolge bearbeiten. Die Synchronisation wird verwendet um ein Objekt in meherere Threads zuzuordnen. Das Objekt wird in abwechselnder Reihenfolge dem jeweiligen Thread zur Verfügung gestellt um die Bearbeitung zu starten. Dient außerdem zur vermeidung von Deadlocks.",
          "aspects": [
            {
              "text": "Um Threads ein bestimmtes Objekt nach der Reihenfolge bearbeiten",
              "elements": [
                [
                  0,
                  64
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ],
          "correctionOrComment": "Um Threads ein bestimmtes Objekt nach der Reihenfolge bearbeiten. Die Synchronisation wird verwendet um ein Objekt in meherere Threads zuzuordnen. Das Objekt wird in abwechselnder Reihenfolge dem jeweiligen Thread zur Verfügung gestellt um die Bearbeitung zu starten. Dient außerdem zur vermeidung von Deadlocks."
        },
        {
          "id": "53",
          "text": "Um die bearbeiteten Daten nicht inkonsistent zu machen. Falls Threads nicht synchronisiert werden, kann es außerdem dazu kommen, dass ein sogenanntes Lost Update auftritt.",
          "aspects": [
            {
              "text": "Um die bearbeiteten Daten nicht inkonsistent zu machen ;; Falls Threads nicht synchronisiert werden, kann es außerdem dazu kommen, dass ein sogenanntes Lost Update auftritt.",
              "elements": [
                [
                  0,
                  54
                ],
                [
                  56,
                  171
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Um die bearbeiteten Daten nicht inkonsistent zu machen. Falls Threads nicht synchronisiert werden, kann es außerdem dazu kommen, dass ein sogenanntes Lost Update auftritt."
        },
        {
          "id": "54",
          "text": "weil die Daten können durch überschreiben von zieldaten ausgetauscht werden.Dann entsthet das gefahr von Lost von update Um diese fehler verhindern zu können,braucht man Synchrinisation.",
          "aspects": [
            {
              "text": "Dann ensteht die Gefahr von Lost Update",
              "elements": [],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Weil die Daten können durch überschreiben von Zieldaten ausgetauscht werden. Dann ensteht die Gefahr von Lost Update. Um diese fehler verhindern zu können, braucht man Synchrinisation."
        },
        {
          "id": "55",
          "text": "Damit Fehler durch verlorene Daten ausgeschlossen werden können. Zum Beispiel wenn ein Thread bis zu einem gewissen Punkt laufen muss bevor ein anderer Thread mit dessen Daten weiterarbeiten kann.",
          "aspects": [
            {
              "text": "Zum Beispiel wenn ein Thread bis zu einem gewissen Punkt laufen muss bevor ein anderer Thread mit dessen Daten weiterarbeiten kann",
              "elements": [
                [
                  65,
                  195
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Damit Fehler dadurch verlorene Daten ausgeschlossen werden können",
              "elements": [],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Damit Fehler dadurch verlorene Daten ausgeschlossen werden können. Zum Beispiel wenn ein Thread bis zu einem gewissen Punkt laufen muss bevor ein anderer Thread mit dessen Daten weiterarbeiten kann."
        },
        {
          "id": "56",
          "text": "Wenn mehrere Threads mit derselben Variablen arbeiten können sie unterschiedlich schnell fertig werden, wodurch andere Ergebnisse herauskommen. Durch die Synchronisation werden von beiden Threads genutzte Daten parallel gehalten, um Fehler zu verhindern",
          "aspects": [
            {
              "text": "Durch die Synchronisation werden von beiden Threads genutzte Daten parallel gehalten",
              "elements": [
                [
                  144,
                  228
                ]
              ],
              "aIdx": 0,
              "label": 2
            }
          ],
          "correctionOrComment": "Wenn mehrere Threads mit derselben Variable arbeiten können sie unterschiedlich schnell fertig werden, wodurch andere Ergebnisse herauskommen. Durch die Synchronisation werden von beiden Threads genutzte Daten parallel gehalten, um Fehler zu verhindern"
        },
        {
          "id": "57",
          "text": "Die Rheinfolge der Threads vermeidet somit das Deadlock, die abschnitte mehrer",
          "aspects": [],
          "correctionOrComment": "Die Rheinfolge der Threads vermeidet somit das Deadlock"
        },
        {
          "id": "58",
          "text": "Da teilweise auf gemeinsame Daten zugegriffen wird ist die Synchronisation sehr wichtig. Eine Reihenfolge des Zugriffs unterschiedlicher Threads, kann Datenverlust verhindern.",
          "aspects": [
            {
              "text": " Eine Reihenfolge des Zugriffs unterschiedlicher Threads",
              "elements": [
                [
                  89,
                  144
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "kann Datenverlust verhindern",
              "elements": [
                [
                  146,
                  174
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Da teilweise auf gemeinsame Daten zugegriffen wird ist die Synchronisation sehr wichtig. Eine Reihenfolge des Zugriffs unterschiedlicher Threads, kann Datenverlust verhindern."
        },
        {
          "id": "59",
          "text": "weil sie sich wärend der läufzeit verändern können und somit ist eine Synchronisation nötig",
          "aspects": [],
          "correctionOrComment": "Weil sie sich während der Läufzeit verändern können und somit ist eine Synchronisation nötig"
        },
        {
          "id": "60",
          "text": "-",
          "aspects": [],
          "correctionOrComment": "-"
        },
        {
          "id": "61",
          "text": "für Multithreaded Anwendung und können Daten einfach durch überschreiben der Zieldaten austauschen",
          "aspects": [],
          "correctionOrComment": "Multithreaded Anwendungen können Daten einfach durch überschreiben der Zieldaten austauschen"
        },
        {
          "id": "62",
          "text": "um zu verhindern das Attribute oder Werte in den kritischen abschnitt kommen oder zwei Threads. Dadurch werden Threads Synchronisiert um dies zu verhindern. So nimmt der eine Threads den Wert den er braucht und gibt ihn erst frei wenn er fertig ist. Beispiel skript mit Global (w,v).",
          "aspects": [
            {
              "text": "So nimmt der eine Thread den Wert, den er braucht und gibt ihn erst frei wenn er fertig ist",
              "elements": [],
              "aIdx": 0,
              "label": 0
            }
          ],
          "correctionOrComment": "Um zu verhindern das Attribute oder Werte in den kritischen Abschnitt kommen oder zwei Threads. Dadurch werden Threads Synchronisiert um dies zu verhindern. So nimmt der eine Thread den Wert, den er braucht und gibt ihn erst frei wenn er fertig ist."
        },
        {
          "id": "63",
          "text": "Damit nicht ein Thread die Daten des anderen überschreibt und um der Gefahr verlorener Daten entgegenzuwirken.",
          "aspects": [
            {
              "text": "um der Gefahr verlorener Daten entgegenzuwirken",
              "elements": [
                [
                  62,
                  109
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Damit nicht ein Thread die Daten des anderen überschreibt und um der Gefahr verlorener Daten entgegenzuwirken."
        },
        {
          "id": "64",
          "text": "Damit Variablen bzw deren Werte ggf nicht gleichzeitig von verschiedenen Threads überschrieben werden und es dadurch zu komplikatioinen im Programmablauf kommt.",
          "aspects": [
            {
              "text": "Damit Variablen beziwhungsweise deren Werte nicht gleichzeitig von verschiedenen Threads überschrieben werden ",
              "elements": [],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "und es dadurch zu Komplikatioinen im Programmablauf kommt",
              "elements": [],
              "aIdx": 1,
              "label": 1
            }
          ],
          "correctionOrComment": "Damit Variablen beziwhungsweise deren Werte nicht gleichzeitig von verschiedenen Threads überschrieben werden und es dadurch zu Komplikatioinen im Programmablauf kommt."
        },
        {
          "id": "65",
          "text": "Da bei dem gleichzeitigen Zugriff auf die selben Daten eventuell Fehler auftreten können",
          "aspects": [
            {
              "text": "Da bei dem gleichzeitigen Zugriff auf die selben Daten eventuell Fehler auftreten können",
              "elements": [
                [
                  0,
                  88
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Da bei dem gleichzeitigen Zugriff auf die selben Daten eventuell Fehler auftreten können",
              "elements": [
                [
                  0,
                  88
                ]
              ],
              "aIdx": 1,
              "label": 1
            }
          ],
          "correctionOrComment": "Da bei dem gleichzeitigen Zugriff auf die selben Daten eventuell Fehler auftreten können"
        },
        {
          "id": "66",
          "text": "Man will Deadlocks vermeiden. Das ist ein Zustand wo das Programm gestartet wird aber sich nicht beenden kann."
        }
      ]
    }
  ]
}