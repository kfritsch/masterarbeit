{
  "questions": [
    {
      "id": "3",
      "title": "Überladene Methode",
      "text": "Was ist eine überladene Methode?",
      "type": "definition",
      "referenceAnswer": {
        "text": "Das sind Methoden einer Klasse mit denselben Namen. Ihre Signaturen unterscheiden sich anhand unterschiedlicher Parameter.",
        "aspects": [
          {
            "text": "Das sind Methoden einer Klasse",
            "elements": [
              [
                0,
                30
              ]
            ]
          },
          {
            "text": "Das sind Methoden ;; mit demselben Namen",
            "elements": [
              [
                0,
                17
              ],
              [
                31,
                50
              ]
            ]
          },
          {
            "text": "Ihre Signaturen unterscheiden sich anhand unterschiedlicher Parameter",
            "elements": [
              [
                52,
                121
              ]
            ]
          }
        ]
      },
      "answersAnnotation": [
        {
          "text": "Das sind Methoden mit denselben Namen aber unterschiedliche Signatur. Zum Beispiel: public double berechneZeitInStunden(int minuten){.....} public double berechneZeitInStunden(int sekunden){....} Rückgabewert ist egal. Hat den Vorteil das es Benutzerfreundlicher ist.",
          "id": "1",
          "answerCategory": "correct",
          "correctionOrComment": "Das sind Methoden mit denselben Namen aber unterschiedlicher Signatur. Der Rückgabewert ist egal. Es hat den Vorteil, dass es benutzerfreundlicher ist.",
          "aspects": [
            {
              "text": "Das sind Methoden mit denselben Namen",
              "elements": [
                [
                  0,
                  37
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            },
            {
              "text": "Das sind Methoden ;;  unterschiedlicher Signatur",
              "elements": [
                [
                  0,
                  17
                ],
                [
                  43,
                  69
                ]
              ],
              "referenceAspects": [
                2
              ],
              "label": 1
            }
          ]
        },
        {
          "text": "eine überladene Methode ist, wenn man mehrere Konstruktoren mit unterschiedlichen Parametern definiert.",
          "id": "2",
          "answerCategory": "missconception",
          "correctionOrComment": "Eine Methode ist überladen, wenn man mehrere Konstruktoren mit unterschiedlichen Parametern definiert.",
          "aspects": []
        },
        {
          "text": "eine überladene Methode wurde mehr als einmal in einer Klasse implementiert, jedoch müssen die Parameter-Übergaben verschieden einzigartig sein, der rückgabetype kann \"\"belibig sein\"\" der methoden-name muss gleich sein. Ein Beispiel: public class Test { public int getOutput() { return 0; } //überladene Methode public int getOutput(int mode){ return 0; } //auch überladen public String getOutput(int mode, String prefix){ return prefix+mode; } }",
          "id": "3",
          "answerCategory": "correct",
          "correctionOrComment": "Eine überladene Methode wurde mehr als einmal in einer Klasse implementiert, jedoch müssen die Parameterübergaben verschieden einzigartig sein. Der Rückgabetype kann belibig sein. Der Methodenname muss gleich sein.",
          "aspects": [
            {
              "text": "Eine überladene Methode wurde mehr als einmal in einer Klasse implementiert",
              "elements": [
                [
                  0,
                  75
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "Der Methodenname muss gleich sein",
              "elements": [
                [
                  180,
                  213
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            },
            {
              "text": "jedoch müssen die Parameterübergaben verschieden einzigartig sein",
              "elements": [
                [
                  77,
                  142
                ]
              ],
              "referenceAspects": [
                2
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "-",
          "id": "4",
          "answerCategory": "none",
          "correctionOrComment": "-",
          "aspects": []
        },
        {
          "text": "Man überlädt eine Methode damit der Rückgabe wert eine schöne lesbare Zahl ist und nicht irgendein code den man nicht entziffern kann.",
          "id": "5",
          "answerCategory": "guessing",
          "correctionOrComment": "Man überlädt eine Methode, damit der Rückgabewert eine schöne, lesbare Zahl ist und nicht irgendein Code, den man nicht entziffern kann.",
          "aspects": []
        },
        {
          "text": "eine methode die die auf alle objekte zugreift",
          "id": "6",
          "answerCategory": "guessing",
          "correctionOrComment": "Das ist eine Methode, die auf alle Objekte zugreift.",
          "aspects": []
        },
        {
          "text": "eine Methode aus die von mehreren klassen benutzt wird und somit immer wieder überschrieben wird",
          "id": "7",
          "answerCategory": "guessing",
          "correctionOrComment": "Das ist eine Methode, die von mehreren Klassen benutzt wird und somit immer wieder überschrieben wird.",
          "aspects": []
        },
        {
          "text": "es ist eine methode die false ausgibt",
          "id": "8",
          "answerCategory": "guessing",
          "correctionOrComment": "Es ist eine Methode, die 'false' ausgibt.",
          "aspects": []
        },
        {
          "text": "Eine Methode, die in der Basisklasse sowie in abgeleiteten Klassen gleichnamig auftritt und unterschiedliche Rückgabewerte liefert.",
          "id": "9",
          "answerCategory": "concept_mix-up",
          "correctionOrComment": "Das ist eine Methode, die in der Basisklasse sowie in abgeleiteten Klassen gleichnamig auftritt und unterschiedliche Rückgabewerte liefert.",
          "aspects": []
        },
        {
          "text": "Zwei Methoden mit dem selben namen bezeichnet man als Überladen. Deshalb müssen sie sich immer in der Signatur (Parameterliste, Typen) unterscheiden.",
          "id": "10",
          "answerCategory": "correct",
          "correctionOrComment": "Zwei Methoden mit dem selben Namen bezeichnet man als überladen. Deshalb müssen sie sich immer in der Signatur (Parameterliste, Typen) unterscheiden.",
          "aspects": [
            {
              "text": "Zwei Methoden mit dem selben Namen bezeichnet man als überladen",
              "elements": [
                [
                  0,
                  63
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            },
            {
              "text": "Deshalb müssen sie sich immer in der Signatur (Parameterliste, Typen) unterscheiden",
              "elements": [
                [
                  65,
                  148
                ]
              ],
              "referenceAspects": [
                2
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Wenn der Speicher der Methoden nicht ausreicht.",
          "id": "11",
          "answerCategory": "guessing",
          "correctionOrComment": "Wenn der Speicher der Methoden nicht ausreicht, sind sie überladen.",
          "aspects": []
        },
        {
          "text": "die mit parametern überladen ist",
          "id": "12",
          "answerCategory": "guessing",
          "correctionOrComment": "Das ist ein Methode, die mit Parametern überladen ist.",
          "aspects": []
        },
        {
          "text": "wenn zuviele variablen deklariert sind, aber nicht alles benutzt werden",
          "id": "13",
          "answerCategory": "guessing",
          "correctionOrComment": "Das ist, wenn zu viele Variablen deklariert sind, aber nicht alle benutzt werden.",
          "aspects": []
        },
        {
          "text": "heist, das sich signatur, Parameterzahl bzw. die typen sich unterscheiden.",
          "id": "14",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Es bedeutet, dass die Signatur und Parameterzahl (bzw. die Typen) sich unterscheiden.",
          "aspects": [
            {
              "text": "Es bedeutet, dass die Signatur und Parameterzahl (bzw. die Typen) sich unterscheiden",
              "elements": [
                [
                  0,
                  84
                ]
              ],
              "referenceAspects": [
                2
              ],
              "label": 1
            }
          ]
        },
        {
          "text": "-",
          "id": "15",
          "answerCategory": "none",
          "correctionOrComment": "-",
          "aspects": []
        },
        {
          "text": "-",
          "id": "16",
          "answerCategory": "none",
          "correctionOrComment": "-",
          "aspects": []
        },
        {
          "text": "eine überladene Methode hat denselben Namen wie eine andere Methode, jedoch andere Parameter. Z.B. bei Konstruktoren: Klasse(){} Klasse(Obj o){} Klasse(Person p, int alter){} durch die Überladung kann sich der \"\"User\"\" aussuchen, welche Methode er nutzen will (z.B. Klasse k = new Klasse(); oder Klasse k2 = new Klasse(anton);",
          "id": "17",
          "answerCategory": "correct",
          "correctionOrComment": "Eine überladene Methode hat denselben Namen wie eine andere Methode, jedoch andere Parameter. Durch die Überladung kann sich der 'User' aussuchen, welche Methode er nutzen will.",
          "aspects": [
            {
              "text": "Eine überladene Methode hat denselben Namen wie eine andere Methode",
              "elements": [
                [
                  0,
                  67
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            },
            {
              "text": "jedoch andere Parameter",
              "elements": [
                [
                  69,
                  92
                ]
              ],
              "referenceAspects": [
                2
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Eine Methode die zu viele Methoden implementiert hat und unübersichtlich ist.",
          "id": "18",
          "answerCategory": "guessing",
          "correctionOrComment": "Das ist eine Methode, die zu viele Methoden implementiert hat und unübersichtlich ist.",
          "aspects": []
        },
        {
          "text": "Eine überladene Methode ist wenn 2 Methoen den selben namen haben, sie müsen sich durch Parammeter-leiste und Signatur unerscheiden",
          "id": "19",
          "answerCategory": "binary_correct",
          "correctionOrComment": "Eine Methode ist überladen, wenn 2 Methoden den selben Namen haben. Sie müssen sich durch Parameterliste und Signatur unerscheiden.",
          "aspects": [
            {
              "text": "Eine Methode ist überladen, wenn 2 Methoden den selben Namen haben",
              "elements": [
                [
                  0,
                  66
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            },
            {
              "text": "Sie müssen sich durch Parameterliste und Signatur unerscheiden",
              "elements": [
                [
                  68,
                  130
                ]
              ],
              "referenceAspects": [
                2
              ],
              "label": 1
            }
          ]
        },
        {
          "text": "Eine überladene Methode ist eine definierte Methode, die durch eine neue Implementation der selben Methode eine neue Bedeutung bekommt. z.B. die vom Object definierte Methode toString(). Wird sie in einer Klasse neu geschrieben gilt sie als überladen.",
          "id": "20",
          "answerCategory": "concept_mix-up",
          "correctionOrComment": "Eine überladene Methode ist eine definierte Methode, die durch eine neue Implementation derselben Methode eine neue Bedeutung bekommt. Wird sie in einer Klasse neu geschrieben gilt sie als überladen.",
          "aspects": []
        },
        {
          "text": "Eine überladene Methode ist eine Methode die sowohl in der Basisklasse als auch in der abgeleitenden Klasse initialisiert wird, dies bedeutet die Methode wird 2 x mit dem gleichen namen initialisiert kann aber einen anderen Inhalt besitzen. Man erkennt erst welche Methode man benutzt beim auslesen.",
          "id": "21",
          "answerCategory": "concept_mix-up",
          "correctionOrComment": "Eine überladene Methode ist eine Methode, die sowohl in der Basisklasse als auch in der abgeleitenden Klasse initialisiert wird. Dies bedeutet, die Methode wird 2 mal mit dem gleichen Namen initialisiert, kann aber einen anderen Inhalt besitzen. Man erkennt erst beim Auslesen, welche Methode man benutzt.",
          "aspects": [
            {
              "text": "Eine überladene Methode ist eine Methode, die sowohl in der Basisklasse als auch in der abgeleitenden Klasse initialisiert wird",
              "elements": [
                [
                  0,
                  127
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 2
            },
            {
              "text": "Dies bedeutet, die Methode wird 2 mal mit dem gleichen Namen initialisiert",
              "elements": [
                [
                  129,
                  203
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Eine überladene Methode ist eine Methoe die eine Methode mit dem selben Namen an der momentanen Stelle ändert allerdings nicht die Methode mit dem selben Namen an der ursprünglichen Stelle.",
          "id": "22",
          "answerCategory": "concept_mix-up",
          "correctionOrComment": "Eine überladene Methode ist eine Methode, die eine Methode mit demselben Namen an der momentanen Stelle ändert, allerdings nicht die Methode mit dem selben Namen an der ursprünglichen Stelle.",
          "aspects": []
        },
        {
          "text": "Wenn eine Methode sehr häufig wiederholt geschrieben wird.",
          "id": "23",
          "answerCategory": "guessing",
          "correctionOrComment": "Das ist, wenn eine Methode sehr häufig wiederholt geschrieben wird.",
          "aspects": []
        },
        {
          "text": "wenn 2 methoden den selben Namen haben sind sie überladen. die methoden müssen sich jedoch durch die Parameter, typ undsignatur unterscheiden um zu funktionieren.",
          "id": "24",
          "answerCategory": "correct",
          "correctionOrComment": "Wenn 2 Methoden denselben Namen haben, sind sie überladen. Die Methoden müssen sich jedoch durch die Parameter (Typ und Signatur) unterscheiden um zu funktionieren.",
          "aspects": [
            {
              "text": "Wenn 2 Methoden denselben Namen haben, sind sie überladen",
              "elements": [
                [
                  0,
                  57
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            },
            {
              "text": "Die Methoden müssen sich jedoch durch die Parameter (Typ und Signatur) unterscheiden um zu funktionieren",
              "elements": [
                [
                  59,
                  163
                ]
              ],
              "referenceAspects": [
                2
              ],
              "label": 1
            }
          ]
        },
        {
          "text": "Eine Methode die einen zu großen Wert aufnehmen muss für den sie nicht festgelegt ist.",
          "id": "25",
          "answerCategory": "guessing",
          "correctionOrComment": "Das ist eine Methode, die einen zu großen Wert aufnehmen muss, für den sie nicht festgelegt ist.",
          "aspects": []
        },
        {
          "text": "Wenn zwei Methoden den selben Namen haben, aber unterschiedliche Parameter",
          "id": "26",
          "answerCategory": "correct",
          "correctionOrComment": "Das ist, wenn zwei Methoden denselben Namen haben, aber unterschiedliche Parameter.",
          "aspects": [
            {
              "text": "Das ist, wenn zwei Methoden denselben Namen haben",
              "elements": [
                [
                  0,
                  49
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            },
            {
              "text": "zwei Methoden ;; haben, aber unterschiedliche Parameter",
              "elements": [
                [
                  14,
                  27
                ],
                [
                  44,
                  82
                ]
              ],
              "referenceAspects": [
                2
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Eine überladene Methode ist eine Methode, der beim Aufruf Parameter übergeben werden.",
          "id": "27",
          "answerCategory": "guessing",
          "correctionOrComment": "Eine überladene Methode ist eine Methode, der beim Aufruf Parameter übergeben werden.",
          "aspects": []
        },
        {
          "text": "Eine uberladene methode ist eine Methode, die den Name von eine bereits existierende methode trägt",
          "id": "28",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Eine überladene Methode ist eine Methode, die den Name von einer bereits existierenden Methode trägt.",
          "aspects": [
            {
              "text": "Eine überladene Methode ist eine Methode, die den Name von einer bereits existierenden Methode trägt",
              "elements": [
                [
                  0,
                  100
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Eine überladene Methode ist wenn man z.B. eine abgeleitete Klasse einer Basisklasse hat, diese Methode der Basisklasse aber nicht für die Ableitung \"\"passt\"\", kann man eine weitere Methode schreiben, oder mehrere wenn man möchte!",
          "id": "29",
          "answerCategory": "concept_mix-up",
          "correctionOrComment": "Eine Methode ist überladen, wenn man beispielsweise eine abgeleitete Klasse einer Basisklasse hat. Wenn eine Methode der Basisklasse nicht für die Ableitung passt, kann man eine oder mehrere weitere Methode schreiben, wenn man möchte!",
          "aspects": []
        },
        {
          "text": "to string methode",
          "id": "30",
          "answerCategory": "none",
          "correctionOrComment": "to string methode",
          "aspects": []
        },
        {
          "text": "eine überladene Methode ist eine Methode die in einer anderen Klasse überschriben werden kann.",
          "id": "31",
          "answerCategory": "concept_mix-up",
          "correctionOrComment": "Eine überladene Methode ist eine Methode, die in einer anderen Klasse überschrieben werden kann.",
          "aspects": []
        },
        {
          "text": "Ein Methode, die es mehrmals gibt.(Gleicher Name)",
          "id": "32",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Ein Methode, die es mehrmals gibt (gleicher Name).",
          "aspects": [
            {
              "text": "Ein Methode, die es mehrmals gibt (gleicher Name)",
              "elements": [
                [
                  0,
                  49
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "eine Methode wo der Standart Konstruktur durch einen/mehrere eigenen Konstruktor ersetzt wurde",
          "id": "33",
          "answerCategory": "concept_mix-up",
          "correctionOrComment": "Das ist eine Methode, in der der Standartkonstruktur durch einen oder mehrere eigene Konstruktoren ersetzt wurde.",
          "aspects": []
        },
        {
          "text": "Eine Methode, die mehrmals verwende/aufgerufen wird, mit jeweils anderem Inhalt.",
          "id": "34",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Das ist eine Methode, die mehrmals verwendet oder aufgerufen wird, mit jeweils anderem Inhalt.",
          "aspects": []
        },
        {
          "text": "Überladene methoden sind zwei verschiedene methoden,, die aber mit verschiedenen Parameter und Typen defineirt sind. (2 verschiedene Methoden, aber verschiedene Parameter und Typen)",
          "id": "35",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Überladene Methoden sind zwei verschiedene Methoden, die aber mit verschiedenen Parametern und Typen definiert sind.",
          "aspects": [
            {
              "text": "Überladene Methoden sind ;; aber mit verschiedenen Parametern und Typen definiert sind",
              "elements": [
                [
                  0,
                  24
                ],
                [
                  57,
                  115
                ]
              ],
              "referenceAspects": [
                2
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Wenn zwei verschiedene Methoden den selben Namen haben, heißen sie überladen. Sie müssen sich durch Parameterliste und - Typen) unterscheiden.",
          "id": "36",
          "answerCategory": "correct",
          "correctionOrComment": "Wenn zwei verschiedene Methoden den selben Namen haben, heißen sie überladen. Sie müssen sich durch die Parameterliste und -typen unterscheiden.",
          "aspects": [
            {
              "text": "Wenn zwei verschiedene Methoden den selben Namen haben, heißen sie überladen",
              "elements": [
                [
                  0,
                  76
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            },
            {
              "text": "Sie müssen sich durch die Parameterliste und -typen unterscheiden",
              "elements": [
                [
                  78,
                  143
                ]
              ],
              "referenceAspects": [
                2
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "das die selbe Methode mehrfach in einer Klasse funktioniert, nur wenn die Parameterliste (Typen) sich unterscheiden.",
          "id": "37",
          "answerCategory": "binary_correct",
          "correctionOrComment": "Es bedeutet, dass dieselbe Methode nur dann mehrfach in einer Klasse funktioniert, wenn die Parameterliste und -typen sich unterscheiden.",
          "aspects": [
            {
              "text": "Es bedeutet, dass dieselbe Methode nur dann mehrfach in einer Klasse funktioniert",
              "elements": [
                [
                  0,
                  81
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "wenn die Parameterliste und -typen sich unterscheiden",
              "elements": [
                [
                  83,
                  136
                ]
              ],
              "referenceAspects": [
                2
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Eine überladene Methode ist eine bereits vorhandene Methode die vom Ersteller an das aktuelle Projekt angepasst wird.",
          "id": "38",
          "answerCategory": "concept_mix-up",
          "correctionOrComment": "Eine überladene Methode ist eine bereits vorhandene Methode, die vom Ersteller an das aktuelle Projekt angepasst wird.",
          "aspects": []
        },
        {
          "text": "Eine Methode, welche mehrere verschiedene Werte übergeben kann",
          "id": "39",
          "answerCategory": "missconception",
          "correctionOrComment": "Das ist eine Methode, welche mehrere verschiedene Werte übergeben kann.",
          "aspects": []
        },
        {
          "text": "Eine überladene Methode ist eine selbsterstellte Supermethode. Wie zum beispiel ein selbstgeschriebener Konstruktor der den Standart Konstruktor erstetzt.",
          "id": "40",
          "answerCategory": "concept_mix-up",
          "correctionOrComment": "Eine überladene Methode ist eine selbsterstellte Supermethode beispielsweise ein selbstgeschriebener Konstruktor, der den Standartkonstruktor erstetzt.",
          "aspects": []
        },
        {
          "text": "Als überladen bezeichnet man eine Methode, die den selben Namen hat, wie eine andere, aber andere Parameter erwartet.",
          "id": "41",
          "answerCategory": "correct",
          "correctionOrComment": "Als überladen bezeichnet man eine Methode, die den selben Namen hat, wie eine andere, aber andere Parameter erwartet.",
          "aspects": [
            {
              "text": "Als überladen bezeichnet man eine Methode, die den selben Namen hat, wie eine andere",
              "elements": [
                [
                  0,
                  84
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            },
            {
              "text": "eine Methode, die ;; aber andere Parameter erwartet",
              "elements": [
                [
                  29,
                  46
                ],
                [
                  86,
                  116
                ]
              ],
              "referenceAspects": [
                2
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Das sind mehrere Methoden mit dem gleichen Namen der benutzt wird. Allerdings besitzen sie andere Ausgaben.",
          "id": "42",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Das sind mehrere Methoden mit dem gleichen Namen, der benutzt wird. Allerdings besitzen sie andere Ausgaben.",
          "aspects": [
            {
              "text": "Das sind mehrere Methoden mit dem gleichen Namen",
              "elements": [
                [
                  0,
                  48
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "ist eine Methode, den selben namen und die selbe funktion hat",
          "id": "43",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Das ist eine Methode, die den selben Namen und die selbe Funktion hat.",
          "aspects": [
            {
              "text": "Das ist eine Methode, die den selben Namen ;; hat",
              "elements": [
                [
                  0,
                  42
                ],
                [
                  66,
                  69
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Eine Methode die nichts zurückgeben kann.",
          "id": "44",
          "answerCategory": "guessing",
          "correctionOrComment": "Das ist eine Methode, die nichts zurückgeben kann.",
          "aspects": []
        },
        {
          "text": "Haben zwei verschiedene Methoden denselben Namen heißen Sie überladen. Sie unterscheiden sich durch ihre Parameter. Sie sorgen für Benutzerfreundlichkeit.",
          "id": "45",
          "answerCategory": "correct",
          "correctionOrComment": "Haben zwei verschiedene Methoden denselben Namen, heißen sie überladen. Sie unterscheiden sich durch ihre Parameter. Sie sorgen für Benutzerfreundlichkeit.",
          "aspects": [
            {
              "text": "Haben zwei verschiedene Methoden denselben Namen, heißen sie überladen",
              "elements": [
                [
                  0,
                  70
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            },
            {
              "text": "Sie unterscheiden sich durch ihre Parameter",
              "elements": [
                [
                  72,
                  115
                ]
              ],
              "referenceAspects": [
                2
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Eine Methode, die sich nur ihrer Signatur (Parameterleiste und -typen) von einer anderen Methode unterscheidet, z.B. kann der Konstruktor einer Klasse überladen werden, indem er jeweils eine unterschiedliche Anzahl an Variablen und/oder verschiedene Typen entgegennimmt.",
          "id": "46",
          "answerCategory": "binary_correct",
          "correctionOrComment": "Das ist eine Methode, die sich nur anhand ihrer Signatur (Parameterliste und -typen) von einer anderen Methode unterscheidet. Beispielsweise kann der Konstruktor einer Klasse überladen werden, indem er jeweils eine unterschiedliche Anzahl an Variablen oder verschiedene Typen entgegennimmt.",
          "aspects": [
            {
              "text": "Das ist eine Methode, die sich nur anhand ihrer Signatur (Parameterliste und -typen) von einer anderen Methode unterscheidet",
              "elements": [
                [
                  0,
                  124
                ]
              ],
              "referenceAspects": [
                2
              ],
              "label": 1
            }
          ]
        },
        {
          "text": "Eine überladene Methode ist eine Methode die den selben Namen hat wie eine oder mehrere Methoden und die je nach EIngabewert aufgerufen wird. So kann es sein das bei einer Eingabe eine andere Methode des selben Namens wie bei einer anderen Eingabe aufgerufen wird. So ist es möglich mit \"\"derselben\"\" Methode verschiedene EIngabetypen anzusprechen.",
          "id": "47",
          "answerCategory": "binary_correct",
          "correctionOrComment": "Eine überladene Methode ist eine Methode, die den selben Namen hat, wie eine oder mehrere Methoden und die je nach Eingabewert aufgerufen wird. So kann es sein, dass bei einer Eingabe eine andere Methode des selben Namens, wie bei einer anderen Eingabe aufgerufen wird. So ist es möglich mit derselben Methode verschiedene Eingabetypen anzusprechen.",
          "aspects": [
            {
              "text": "Eine überladene Methode ist eine Methode, die den selben Namen hat",
              "elements": [
                [
                  0,
                  66
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            },
            {
              "text": "eine Methode ;; die je nach Eingabewert aufgerufen wird",
              "elements": [
                [
                  28,
                  40
                ],
                [
                  103,
                  142
                ]
              ],
              "referenceAspects": [
                2
              ],
              "label": 1
            }
          ]
        },
        {
          "text": "Eine Methode ist überladen, wenn mindestens eine weitere Methode mit dem selben Namen aber einer anderen Signatur vorliegt.",
          "id": "48",
          "answerCategory": "correct",
          "correctionOrComment": "Eine Methode ist überladen, wenn mindestens eine weitere Methode mit dem selben Namen aber einer anderen Signatur vorliegt.",
          "aspects": [
            {
              "text": "Eine Methode ist überladen, wenn mindestens eine weitere Methode mit dem selben Namen ;; vorliegt",
              "elements": [
                [
                  0,
                  85
                ],
                [
                  114,
                  122
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            },
            {
              "text": "wenn mindestens eine weitere Methode mit ;; einer anderen Signatur vorliegt",
              "elements": [
                [
                  28,
                  68
                ],
                [
                  91,
                  122
                ]
              ],
              "referenceAspects": [
                2
              ],
              "label": 1
            }
          ]
        },
        {
          "text": "Eine überladene Methode ist eine Methode die andere Methoden aufruft.",
          "id": "49",
          "answerCategory": "guessing",
          "correctionOrComment": "Eine überladene Methode ist eine Methode, die andere Methoden aufruft.",
          "aspects": []
        },
        {
          "text": "-",
          "id": "50",
          "answerCategory": "none",
          "correctionOrComment": "-",
          "aspects": []
        },
        {
          "text": "Überlade Methoden sind Methoden die einander überschreiben können z.B. \"\"+\"\".",
          "id": "51",
          "answerCategory": "concept_mix-up",
          "correctionOrComment": "Überlade Methoden sind Methoden, die einander überschreiben können.",
          "aspects": []
        },
        {
          "text": "Eine Methode die es schonmal gibt. Also mit dem gleichen Namen. Mit der Methode kann man dann mehrere Sachen machen (sie überschreiben sich nicht).",
          "id": "52",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Das ist eine Methode, die es schonmal gibt, also mit dem gleichen Namen. Mit der Methode kann man dann mehrere Sachen machen. Sie überschreiben sich nicht.",
          "aspects": [
            {
              "text": "Das ist eine Methode, die es schonmal gibt, also mit dem gleichen Namen",
              "elements": [
                [
                  0,
                  71
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "eine überladene methode ist eine methode die aus einer basisklasse abgeleitet ist und in der der abgeleitetetn klasse überschrieben wird beispiellsweise hat jede klasse die methode toString(), da alle klassen von Object abgeleitet sind, um eine lesbare ausgabe zu erhalten muss die methode toString in der abgeleiteten Klasse überschrieben werden und ist dann überladen",
          "id": "53",
          "answerCategory": "concept_mix-up",
          "correctionOrComment": "Eine überladene Methode ist eine Methode, die aus einer Basisklasse abgeleitet ist und in der abgeleiteten Klasse überschrieben wird. Beispielsweise hat jede Klasse die Methode 'toString()', da alle Klassen von 'Object' abgeleitet sind. Um eine lesbare Ausgabe zu erhalten muss die Methode 'toString' in der abgeleiteten Klasse überschrieben werden und ist dann überladen.",
          "aspects": []
        },
        {
          "text": "Eine Methode, die das gleiche Schutzattribut, den gleichen Rückgabetyp und den gleichen Methodenname hat. Sie unterscheidet sich nur in den Übergabeparametern.",
          "id": "54",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Das ist eine Methode, die das gleiche Schutzattribut, den gleichen Rückgabetyp und den gleichen Methodenname hat. Sie unterscheidet sich nur in den Übergabeparametern.",
          "aspects": [
            {
              "text": "Das ist eine Methode, die ;; den gleichen Methodenname hat",
              "elements": [
                [
                  0,
                  25
                ],
                [
                  83,
                  112
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            },
            {
              "text": "Sie unterscheidet sich nur in den Übergabeparametern",
              "elements": [
                [
                  114,
                  166
                ]
              ],
              "referenceAspects": [
                2
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Haben zwei verschieden Methoden derselben Namen heißen sie überladen. Überladen Methoiden müssen sich durch die Signatur(Parameterliste und -typen) unterscheiden, der Rückgabewert ist egal.",
          "id": "55",
          "answerCategory": "binary_correct",
          "correctionOrComment": "Haben zwei verschieden Methoden denselben Namen, heißen sie überladen. Überladene Methoden müssen sich durch die Signatur (Parameterliste und -typen) unterscheiden. Der Rückgabewert ist egal.",
          "aspects": [
            {
              "text": "Haben zwei verschieden Methoden denselben Namen, heißen sie überladen",
              "elements": [
                [
                  0,
                  69
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            },
            {
              "text": "Überladene Methoden müssen sich durch die Signatur (Parameterliste und -typen) unterscheiden",
              "elements": [
                [
                  71,
                  163
                ]
              ],
              "referenceAspects": [
                2
              ],
              "label": 1
            }
          ]
        },
        {
          "text": "wenn zwei verschiedene methoden denselben namen haben, heißen sie überladen. sie müssen sich durch die Signatur (Parameterliste und typen) unterscheiden,der Rrückgabe wert ist egal.",
          "id": "56",
          "answerCategory": "binary_correct",
          "correctionOrComment": "Wenn zwei verschiedene Methoden denselben Namen haben, heißen sie überladen. Sie müssen sich durch die Signatur (Parameterliste und -typen) unterscheiden. Der Rrückgabewert ist egal.",
          "aspects": [
            {
              "text": "Wenn zwei verschiedene Methoden denselben Namen haben, heißen sie überladen",
              "elements": [
                [
                  0,
                  75
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            },
            {
              "text": "Sie müssen sich durch die Signatur (Parameterliste und -typen) unterscheiden",
              "elements": [
                [
                  77,
                  153
                ]
              ],
              "referenceAspects": [
                2
              ],
              "label": 1
            }
          ]
        },
        {
          "text": "eine Methode die",
          "id": "57",
          "answerCategory": "none",
          "correctionOrComment": "eine Methode die",
          "aspects": []
        },
        {
          "text": "wenn zwei Methoden denselben namen haben dann sind sie überladen sie müssen sich durch die signatur unterscheiden der rückgabewert ist egal",
          "id": "58",
          "answerCategory": "correct",
          "correctionOrComment": "Wenn zwei Methoden denselben Namen haben, dann sind sie überladen. Sie müssen sich durch die Signatur unterscheiden. Der Rückgabewert ist egal.",
          "aspects": [
            {
              "text": "Wenn zwei Methoden denselben Namen haben, dann sind sie überladen",
              "elements": [
                [
                  0,
                  65
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            },
            {
              "text": "Sie müssen sich durch die Signatur unterscheiden",
              "elements": [
                [
                  67,
                  115
                ]
              ],
              "referenceAspects": [
                2
              ],
              "label": 1
            }
          ]
        },
        {
          "text": "Wenn zwei verschiedene Methoden denselben Namen haben, dann heißen sie überladen. Überladene Methoden müssen sich durch die Parameterliste und -typen unterscheiden.",
          "id": "59",
          "answerCategory": "correct",
          "correctionOrComment": "Wenn zwei verschiedene Methoden denselben Namen haben, dann heißen sie überladen. Überladene Methoden müssen sich durch die Parameterliste und -typen unterscheiden.",
          "aspects": [
            {
              "text": "Wenn zwei verschiedene Methoden denselben Namen haben, dann heißen sie überladen",
              "elements": [
                [
                  0,
                  80
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            },
            {
              "text": "Überladene Methoden müssen sich durch die Parameterliste und -typen unterscheiden",
              "elements": [
                [
                  82,
                  163
                ]
              ],
              "referenceAspects": [
                2
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "-",
          "id": "60",
          "answerCategory": "none",
          "correctionOrComment": "-",
          "aspects": []
        },
        {
          "text": "Mehrere Methoden haben dieselben Namen, man kann sie durch ihre Eigenschaften entscheiden. Der Aufruf ist dabei egal.",
          "id": "61",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Mehrere Methoden haben dieselben Namen. Man kann sie durch ihre Eigenschaften unterscheiden. Der Aufruf ist dabei egal.",
          "aspects": [
            {
              "text": "Mehrere Methoden haben dieselben Namen",
              "elements": [
                [
                  0,
                  38
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            },
            {
              "text": "Man kann sie durch ihre Eigenschaften unterscheiden",
              "elements": [
                [
                  40,
                  91
                ]
              ],
              "referenceAspects": [
                2
              ],
              "label": 1
            }
          ]
        },
        {
          "text": "Wenn zwei verschiedene Methoden den selben Namen haben nennt man sie Überladen. Sie müssen sich durch die Signatur unterscheiden. Der Rückgabewert ist egal.",
          "id": "62",
          "answerCategory": "correct",
          "correctionOrComment": "Wenn zwei verschiedene Methoden denselben Namen haben, nennt man sie überladen. Sie müssen sich durch die Signatur unterscheiden. Der Rückgabewert ist egal.",
          "aspects": [
            {
              "text": "Wenn zwei verschiedene Methoden denselben Namen haben, nennt man sie überladen",
              "elements": [
                [
                  0,
                  78
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            },
            {
              "text": "Sie müssen sich durch die Signatur unterscheiden",
              "elements": [
                [
                  80,
                  128
                ]
              ],
              "referenceAspects": [
                2
              ],
              "label": 1
            }
          ]
        },
        {
          "text": "Vererbte Methode/Konstruktor die mit Override überschrieben wurde. Beispiel: Überschreibung des Standartkonstruktors.",
          "id": "63",
          "answerCategory": "concept_mix-up",
          "correctionOrComment": "Das sind vererbte Methoden oder Konstruktoren, die mit 'Override' überschrieben wurde.",
          "aspects": []
        },
        {
          "text": "Sind Methoden mit den selben Methodennamen, der unterschied besteht aber da drin, dass die Parameteranzahl bzw. Typen sich unterscheiden.",
          "id": "64",
          "answerCategory": "correct",
          "correctionOrComment": "Das sind Methoden mit den selben Methodennamen. Der Unterschied besteht aber darin, dass die Parameteranzahl oder -typen sich unterscheiden.",
          "aspects": [
            {
              "text": "Das sind Methoden mit den selben Methodennamen",
              "elements": [
                [
                  0,
                  46
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            },
            {
              "text": "Der Unterschied besteht aber darin, dass die Parameteranzahl oder -typen sich unterscheiden",
              "elements": [
                [
                  48,
                  139
                ]
              ],
              "referenceAspects": [
                2
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Haben zwei verschiedene Methoden denselben Namen heißen sie Überladen Überladene Methoden müssen sich durch die Signatur (Parameterliste und typen) unterscheiden.",
          "id": "65",
          "answerCategory": "correct",
          "correctionOrComment": "Haben zwei verschiedene Methoden denselben Namen, heißen sie überladen. Überladene Methoden müssen sich durch die Signatur (Parameterliste und -typen) unterscheiden.",
          "aspects": [
            {
              "text": "Haben zwei verschiedene Methoden denselben Namen, heißen sie überladen",
              "elements": [
                [
                  0,
                  70
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            },
            {
              "text": "Überladene Methoden müssen sich durch die Signatur (Parameterliste und -typen) unterscheiden",
              "elements": [
                [
                  72,
                  164
                ]
              ],
              "referenceAspects": [
                2
              ],
              "label": 1
            }
          ]
        },
        {
          "text": "Eine Methode ist überladen, wenn sie z.B. einen String erbt und diesen dann innerhalb der Methode mit einem neuen \"\"Wert\"\" überschreibt.",
          "id": "66",
          "answerCategory": "concept_mix-up",
          "correctionOrComment": "Eine Methode ist überladen, wenn sie beispielsweise einen String erbt und diesen dann innerhalb der Methode mit einem neuen Wert überschreibt.",
          "aspects": []
        },
        {
          "text": "überladen ist eine Methode, wenn sie doppelt implementiert wurde, mit den gleichen Parametern. Die Variable wurde gleichnamig definiert.",
          "id": "67",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Überladen ist eine Methode, wenn sie doppelt implementiert wurde, mit den gleichen Parametern. Die Variable wurde gleichnamig definiert.",
          "aspects": []
        },
        {
          "text": "Eine Methode in der zu viel Quellcode steht.",
          "id": "68",
          "answerCategory": "guessing",
          "correctionOrComment": "Eine Methode in der zu viel Quellcode steht.",
          "aspects": []
        },
        {
          "text": "Haben zwei verschiedene Methoden denselben Namen heißen sie überladen. Überladene Methoden müssen sich durch die Signatur (Parameterliste und -typen) unterscheiden den, der Rückgabewert ist egal.",
          "id": "69",
          "answerCategory": "correct",
          "correctionOrComment": "Haben zwei verschiedene Methoden denselben Namen, heißen sie überladen. Überladene Methoden müssen sich durch die Signatur (Parameterliste und -typen) unterscheiden. Der Rückgabewert ist egal.",
          "aspects": [
            {
              "text": "Haben zwei verschiedene Methoden denselben Namen, heißen sie überladen",
              "elements": [
                [
                  0,
                  70
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            },
            {
              "text": "Überladene Methoden müssen sich durch die Signatur (Parameterliste und -typen) unterscheiden",
              "elements": [
                [
                  72,
                  164
                ]
              ],
              "referenceAspects": [
                2
              ],
              "label": 1
            }
          ]
        },
        {
          "text": "Überladene Methoden haben zwei verschiedene Methoden den selben Namen heißen sie Überladen. Überladene Methoden müssen sich durch die Signatur (Parameterliste und -typen) unterscheiden.",
          "id": "70",
          "answerCategory": "correct",
          "correctionOrComment": "Haben zwei verschiedene Methoden denselben Namen, heißen sie überladen. Überladene Methoden müssen sich durch die Signatur (Parameterliste und -typen) unterscheiden.",
          "aspects": [
            {
              "text": "Haben zwei verschiedene Methoden denselben Namen, heißen sie überladen",
              "elements": [
                [
                  0,
                  70
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            },
            {
              "text": "Überladene Methoden müssen sich durch die Signatur (Parameterliste und -typen) unterscheiden",
              "elements": [
                [
                  72,
                  164
                ]
              ],
              "referenceAspects": [
                2
              ],
              "label": 1
            }
          ]
        },
        {
          "text": "Bedeutet dass derselbe Methodenname mehrfach in einer Klasse verwendet werden kann. Die Anzahl der Übergabeparameter ist unterschiedlich.",
          "id": "71",
          "answerCategory": "binary_correct",
          "correctionOrComment": "Es bedeutet, dass derselbe Methodenname mehrfach in einer Klasse verwendet werden kann. Die Anzahl der Übergabeparameter ist unterschiedlich.",
          "aspects": [
            {
              "text": "Es bedeutet, dass derselbe Methodenname mehrfach in einer Klasse verwendet werden kann",
              "elements": [
                [
                  0,
                  86
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            },
            {
              "text": "Die Anzahl der Übergabeparameter ist unterschiedlich",
              "elements": [
                [
                  88,
                  140
                ]
              ],
              "referenceAspects": [
                2
              ],
              "label": 1
            }
          ]
        },
        {
          "text": "Eine vererbte Methode die überschrieben wird damit diese verändert werden kann für die Kindklasse. Diese werden konventionell mit @Override gekennzeichnet.",
          "id": "72",
          "answerCategory": "concept_mix-up",
          "correctionOrComment": "Das ist eine vererbte Methode, die überschrieben wird damit diese verändert werden kann für die Kindklasse. Diese werden konventionell mit '@Override' gekennzeichnet.",
          "aspects": []
        },
        {
          "text": "Eine überladene Methode ist wenn die maximale Kapazität an methoden überladen wurde.",
          "id": "73",
          "answerCategory": "guessing",
          "correctionOrComment": "Eine Methode ist überladen, wenn die maximale Kapazität an Methoden überladen wurde.",
          "aspects": []
        }
      ]
    },
    {
      "id": "4",
      "title": "Klassenattribute schätzen",
      "text": "Sie schreiben eine Klasse Beispielklasse mit einem Feld 'wert'. Wie erreichen Sie, dass 'wert' nur innerhalb von Beispielklasse schreibbar, aber von überall aus lesbar ist?",
      "type": "procedure",
      "referenceAnswer": {
        "text": "Das Feld `wert` muss mit dem Schutzattribute `private` deklariert werden. Zusätzlich muss die Klasse eine Methode bereitstellen, die das Auslesen dieses Feldes ermöglicht.",
        "aspects": [
          {
            "text": "Das Feld `wert` muss mit dem Schutzattribute `private` deklariert werden",
            "elements": [
              [
                0,
                72
              ]
            ]
          },
          {
            "text": "Zusätzlich muss die Klasse eine Methode bereitstellen, die das Auslesen dieses Feldes ermöglicht",
            "elements": [
              [
                74,
                170
              ]
            ]
          }
        ]
      },
      "answersAnnotation": [
        {
          "text": "Ich setze \"\"Wert\"\" auf private und schreibe in der Beispielklasse einen Getter. So kann \"\"Wert\"\" gelesen von überall gelesen werden udn bleibt schreibgeschützt.",
          "id": "1",
          "answerCategory": "correct",
          "correctionOrComment": "Ich setze 'wert' auf 'private' und schreibe in der Beispielklasse einen 'Getter'. So kann 'wert' von überall gelesen werden und bleibt schreibgeschützt.",
          "aspects": [
            {
              "text": "Ich setze 'wert' auf 'private'",
              "elements": [
                [
                  0,
                  30
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "Ich ;; schreibe in der Beispielklasse einen 'Getter'",
              "elements": [
                [
                  0,
                  3
                ],
                [
                  35,
                  80
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "indem man mit der sogenanneten Kapselung arbeitet: wert als Private definieren und mithilfe von Getter- und Setter-methoden den Zugrif ermöglichen.",
          "id": "2",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Indem man mit der sogenanneten Kapselung arbeitet. Man muss 'wert' als 'private' definieren und mithilfe von Getter- und Settermethoden den Zugriff ermöglichen.",
          "aspects": [
            {
              "text": "Man muss 'wert' als 'private' definieren ",
              "elements": [
                [
                  51,
                  91
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "Man muss ;; mithilfe von Getter- und Settermethoden den Zugriff ermöglichen",
              "elements": [
                [
                  51,
                  59
                ],
                [
                  96,
                  159
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 1
            }
          ]
        },
        {
          "text": "Mit protect. Wemm man in der Beispielsklasse\"\" protect double wert\"\" schreibt ist sie für andere Klassen sichtbar aber nicht veränderbar.",
          "id": "3",
          "answerCategory": "missconception",
          "correctionOrComment": "Wenn man in der Beispielsklasse 'protected double wert' schreibt, ist sie für andere Klassen sichtbar aber nicht veränderbar.",
          "aspects": [
            {
              "text": "Wenn man in der Beispielsklasse 'protected double wert' schreibt",
              "elements": [
                [
                  0,
                  64
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 2
            }
          ]
        },
        {
          "text": "privat int wert und dann durch getter und setter aufrufen.",
          "id": "4",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Es muss als 'private int wert' initialisiert werden und kann dann durch 'Getter' und 'Setter' aufrufen werden.",
          "aspects": [
            {
              "text": "Es muss als 'private int wert' initialisiert werden",
              "elements": [
                [
                  0,
                  51
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "Es muss ;; dann durch 'Getter' und 'Setter' aufrufen werden",
              "elements": [
                [
                  0,
                  7
                ],
                [
                  61,
                  109
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 1
            }
          ]
        },
        {
          "text": "man benutzt die protected um es schützen aber lesbar zu halten",
          "id": "5",
          "answerCategory": "missconception",
          "correctionOrComment": "Man benutzt 'protected' um es zu schützen aber lesbar zu halten.",
          "aspects": [
            {
              "text": "Man benutzt 'protected'",
              "elements": [
                [
                  0,
                  23
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 2
            }
          ]
        },
        {
          "text": "ich lege das schutzattribut von \"\"wert\"\" auf private fest und implementiere eine getter-methode sodass von überall auf den im Feld \"\"wert\"\" hinterlegten Wert über diese methode zugegriffen werden kann.",
          "id": "6",
          "answerCategory": "correct",
          "correctionOrComment": "Ich lege das Schutzattribut von 'wert' auf 'private' fest und implementiere eine Gettermethode, sodass von überall auf den im Feld 'wert' hinterlegten Wert über diese Methode zugegriffen werden kann.",
          "aspects": [
            {
              "text": "Ich lege das Schutzattribut von 'wert' auf 'private' fest",
              "elements": [
                [
                  0,
                  57
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "Ich ;; implementiere eine Gettermethode",
              "elements": [
                [
                  0,
                  3
                ],
                [
                  62,
                  94
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "durch eine vererbung. mit extends können dann die anderen klassen die werte übernehmen",
          "id": "7",
          "answerCategory": "concept_mix-up",
          "correctionOrComment": "Das geht durch eine Vererbung. Mit 'extends' können dann die anderen Klassen die Werte übernehmen.",
          "aspects": []
        },
        {
          "text": "Indem man innerhalb der \"\"Beispielklasse\"\" nur einen Getter für \"\"wert\"\", aber keinen Setter verwendet.",
          "id": "8",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Das geht, indem man innerhalb der Beispielklasse nur einen 'Getter' für 'wert' aber keinen 'Setter' verwendet.",
          "aspects": [
            {
              "text": "Das geht, indem man innerhalb der Beispielklasse nur einen 'Getter' für 'wert' ;; verwendet",
              "elements": [
                [
                  0,
                  78
                ],
                [
                  100,
                  109
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "ich benutze vor wert den zustazt protected",
          "id": "9",
          "answerCategory": "missconception",
          "correctionOrComment": "Ich benutze vor 'wert' den Zusatz 'protected'.",
          "aspects": [
            {
              "text": "Ich benutze vor 'wert' den Zusatz 'protected'",
              "elements": [
                [
                  0,
                  45
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 2
            }
          ]
        },
        {
          "text": "protected int wert;",
          "id": "10",
          "answerCategory": "missconception",
          "correctionOrComment": "Das geht mit 'protected int wert'.",
          "aspects": [
            {
              "text": "Das geht mit 'protected int wert'",
              "elements": [
                [
                  0,
                  33
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 2
            }
          ]
        },
        {
          "text": "private Beispielklasse",
          "id": "11",
          "answerCategory": "missconception",
          "correctionOrComment": "Das geht mit 'private Beispielklasse'.",
          "aspects": [
            {
              "text": "Das geht mit 'private Beispielklasse'",
              "elements": [
                [
                  0,
                  37
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 2
            }
          ]
        },
        {
          "text": "private Typ wert; (Variable als private deklarieren, um direkten Zugriff zu vermeiden) public getWert(){return wert;} (auslesen, von überall möglich) private void setWert(Typ wert){this.wert = wert;} (schreiben, nur innerhalb der eigenen Klasse möglich)",
          "id": "12",
          "answerCategory": "correct",
          "correctionOrComment": "Man muss die Variable als 'private' deklarieren, um direkten Zugriff zu vermeiden. Ein 'public' Getter macht das  Auslesen, von überall möglich. Ein 'private'  'Setter' macht das Schreiben, nur innerhalb der eigenen Klasse möglich.",
          "aspects": [
            {
              "text": "Man muss die Variable als 'private' deklarieren",
              "elements": [
                [
                  0,
                  47
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "Ein 'public' Getter macht das Auslesen, von überall möglich",
              "elements": [],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "public static final string wert...",
          "id": "13",
          "answerCategory": "missconception",
          "correctionOrComment": "Das geht mit 'public static final string wert'.",
          "aspects": [
            {
              "text": "Das geht mit 'public static final string wert'",
              "elements": [
                [
                  0,
                  46
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 2
            }
          ]
        },
        {
          "text": "man muss Proteced benützen damit sie von übeall lesbar ist aber nur innerhalb von Beispielklasse schreibbar ist",
          "id": "14",
          "answerCategory": "missconception",
          "correctionOrComment": "Man muss 'proteced' benutzen, damit sie von übeall lesbar, aber nur innerhalb von Beispielklasse schreibbar ist",
          "aspects": [
            {
              "text": "Man muss 'proteced' benutzen",
              "elements": [
                [
                  0,
                  28
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 2
            }
          ]
        },
        {
          "text": "Zuerst muss die Variable wert als private deklariert werden. So ist sie von außen schreibgeschützt. Um nun wert von außen lesbar zu machen muss ein Getter implementiert werden. Durch den Methodenaufruf getWert() kann nun wert ausgelesen werden aber nicht verändert werden.",
          "id": "15",
          "answerCategory": "correct",
          "correctionOrComment": "Zuerst muss die Variable 'wert' als 'private' deklariert werden. So ist sie von außen schreibgeschützt. Um nun 'wert' von außen lesbar zu machen muss ein 'Getter' implementiert werden. Durch den Methodenaufruf 'getWert()' kann nun 'wert' ausgelesen werden aber nicht verändert werden.",
          "aspects": [
            {
              "text": "Zuerst muss die Variable 'wert' als 'private' deklariert werden",
              "elements": [
                [
                  0,
                  63
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "Um nun 'wert' von außen lesbar zu machen muss ein 'Getter' implementiert werden",
              "elements": [
                [
                  104,
                  183
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Durch das Atrribut private, schützt man Datenfelder davor das sie nur innerhalb ihrer Klasse schreibbar und sichtbar sind. Durch eine getter Methode können alle Klassen, die private geschriebene Variable lesen.",
          "id": "16",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Durch das Attribut 'private', schützt man Datenfelder davor, dass sie nur innerhalb ihrer Klasse schreibbar und sichtbar sind. Durch eine 'Getter' Methode können alle Klassen, die 'private' geschriebene Variable lesen.",
          "aspects": [
            {
              "text": "Durch das Attribut 'private', schützt man Datenfelder",
              "elements": [
                [
                  0,
                  53
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "Durch eine 'Getter' Methode können alle Klassen, die 'private' geschriebene Variable lesen",
              "elements": [
                [
                  127,
                  217
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "ich erreichr es in dem ich den wert auf private setze und demendsprechende getter mache also ptivate int wert ; public int getWert(){ return wert; }",
          "id": "17",
          "answerCategory": "correct",
          "correctionOrComment": "Ich erreiche es, indem ich 'wert' auf 'private' setze und demendsprechende 'Getter' mache.",
          "aspects": [
            {
              "text": "Ich erreiche es, indem ich 'wert' auf 'private' setze",
              "elements": [
                [
                  0,
                  53
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "Ich erreiche es, indem ich ;; demendsprechende 'Getter' mache",
              "elements": [
                [
                  0,
                  26
                ],
                [
                  58,
                  89
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Ich setze das Feld \"\"wert\"\" auf Private und benutze von den anderen Klassen aus Getter um den Wert des Feldes wert zu lesen.",
          "id": "18",
          "answerCategory": "correct",
          "correctionOrComment": "Ich setze das Feld 'wert' auf 'private' und benutze von den anderen Klassen aus 'Getter' um den Wert des Feldes 'wert' zu lesen.",
          "aspects": [
            {
              "text": "Ich setze das Feld 'wert' auf 'private'",
              "elements": [
                [
                  0,
                  39
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "Ich ;; benutze von den anderen Klassen aus 'Getter'",
              "elements": [
                [
                  0,
                  3
                ],
                [
                  44,
                  88
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "protected",
          "id": "19",
          "answerCategory": "missconception",
          "correctionOrComment": "Das geht mit 'protected'.",
          "aspects": [
            {
              "text": "Das geht mit 'protected'.",
              "elements": [
                [
                  0,
                  25
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 2
            }
          ]
        },
        {
          "text": "Damit sie nur schreibbar innerhalbder Klasse ist deklariert man sie mit private. Lesbar machen Kann man die Variable indem man sie in eine get-methode steckt und diese Methode public macht.",
          "id": "20",
          "answerCategory": "correct",
          "correctionOrComment": "Damit sie nur schreibbar innerhalb der Klasse ist, deklariert man sie mit 'private'. Lesbar machen kann man die Variable, indem man sie in eine Gettermethode steckt und diese Methode 'public' macht.",
          "aspects": [
            {
              "text": "deklariert man sie mit 'private'",
              "elements": [
                [
                  51,
                  83
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "Lesbar machen kann man die Variable, indem man sie in eine Gettermethode steckt",
              "elements": [
                [
                  85,
                  164
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Diese feld soll mit Attribut private deklarieren werden und mit eine methode überall lesbar wird",
          "id": "21",
          "answerCategory": "correct",
          "correctionOrComment": "Dieses Feld sollte mit dem Attribut 'private' deklariert werden und mit einer Gettermethode von überall lesbar gemacht werden.",
          "aspects": [
            {
              "text": "Dieses Feld sollte mit dem Attribut 'private' deklariert werden ",
              "elements": [
                [
                  0,
                  63
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "Dieses Feld sollte ;; mit einer Gettermethode von überall lesbar gemacht werden",
              "elements": [
                [
                  0,
                  18
                ],
                [
                  68,
                  125
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "private (z.B. int) wert; Und erstelle dann eine Getter Methode. public int getWert() { return wert; }",
          "id": "22",
          "answerCategory": "correct",
          "correctionOrComment": "Das geht mit 'private int wert'. Man erstelle dann eine 'public' Gettermethode.",
          "aspects": [
            {
              "text": "Das geht mit 'private int wert'",
              "elements": [
                [
                  0,
                  31
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "Man erstelle dann eine 'public' Gettermethode",
              "elements": [
                [
                  33,
                  78
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "public class zahl; private int wert; public int getWert(){ return wert; mit private ermöglichen wir das man nur in der eigenen klasse zugriff hat und mit getter machen wir sie aber in den anderen klassen sichtbar.",
          "id": "23",
          "answerCategory": "correct",
          "correctionOrComment": "Mit 'private' ermöglichen wir, dass man nur in der eigenen Klasse Zugriff hat und mit einem 'Getter' machen wir sie aber in den anderen Klassen sichtbar.",
          "aspects": [
            {
              "text": "Mit 'private' ermöglichen wir, dass man nur in der eigenen Klasse Zugriff hat",
              "elements": [
                [
                  0,
                  77
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "mit einem 'Getter' machen wir sie aber in den anderen Klassen sichtbar",
              "elements": [
                [
                  82,
                  152
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "public class Beispielklasse protected int wert; public String getWert(){ return this.wert;} Dadurch dass man nur mit dem Setter wert überschreiben kann es bzw scheibbar machen kann, benutz man hier nur einen getter.",
          "id": "24",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Das geht mit 'protected int wert'. Dadurch dass man nur mit dem 'Setter' 'wert' überschreiben kann, benutz man hier nur einen 'Getter'.",
          "aspects": [
            {
              "text": "Das geht mit 'protected int wert'",
              "elements": [
                [
                  0,
                  33
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 2
            },
            {
              "text": "benutz man hier nur einen 'Getter'",
              "elements": [
                [
                  100,
                  134
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "mit dem Präfix protected zb: protected int wert;",
          "id": "25",
          "answerCategory": "missconception",
          "correctionOrComment": "Das geht mit dem Präfix 'protected', also 'protected int wert'.",
          "aspects": [
            {
              "text": "Das geht mit dem Präfix 'protected', also 'protected int wert'",
              "elements": [
                [
                  0,
                  62
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 2
            }
          ]
        },
        {
          "text": "public final wert",
          "id": "26",
          "answerCategory": "missconception",
          "correctionOrComment": "Das geht mit 'public final wert'.",
          "aspects": [
            {
              "text": "Das geht mit 'public final wert'",
              "elements": [
                [
                  0,
                  32
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 2
            }
          ]
        },
        {
          "text": "Wir definiert die Variable \"\"wert\"\" mit dem Zugriffatributt protected. - (protected int wert)",
          "id": "27",
          "answerCategory": "missconception",
          "correctionOrComment": "Wir definieren die Variable 'wert' mit dem Zugriffsattribut protected ('protected int wert').",
          "aspects": [
            {
              "text": "Wir definieren die Variable 'wert' mit dem Zugriffsattribut protected ('protected int wert')",
              "elements": [
                [
                  0,
                  92
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 2
            }
          ]
        },
        {
          "text": "public class Beispielklasse private int wert; Durch eine getter Methode! und der wert muss private gesetzt sein!",
          "id": "28",
          "answerCategory": "correct",
          "correctionOrComment": "Durch eine Gettermethode und der Wert muss 'private' gesetzt sein!",
          "aspects": [
            {
              "text": "der Wert muss 'private' gesetzt sein",
              "elements": [
                [
                  29,
                  65
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "Durch eine Gettermethode",
              "elements": [
                [
                  0,
                  24
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "indem ich die Klasse ableite mit extends",
          "id": "29",
          "answerCategory": "missconception",
          "correctionOrComment": "Das geht, indem ich die Klasse ableite mit extends.",
          "aspects": []
        },
        {
          "text": "protected wert;",
          "id": "30",
          "answerCategory": "missconception",
          "correctionOrComment": "Das geht mit 'protected wert'.",
          "aspects": [
            {
              "text": "Das geht mit 'protected wert'",
              "elements": [
                [
                  0,
                  29
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 2
            }
          ]
        },
        {
          "text": "indem man den \"\"wert\"\" auf private setzt und ihn danach mit getter/setter aufruft. Dadurch kann man nur innerhalb der Beispielklasse den \"\"wert\"\" verändern.",
          "id": "31",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Das geht, indem man den Wert auf 'private' setzt und ihn danach mit 'Getter' und 'Setter' aufruft. Dadurch kann man nur innerhalb der Beispielklasse den Wert verändern.",
          "aspects": [
            {
              "text": "Das geht, indem man den Wert auf 'private' setzt",
              "elements": [
                [
                  0,
                  48
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "Das geht, indem man ;; ihn danach mit ;; Setter' aufruft",
              "elements": [
                [
                  0,
                  19
                ],
                [
                  53,
                  67
                ],
                [
                  82,
                  97
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 2
            },
            {
              "text": "Das geht, indem man ;; ihn danach mit 'Getter' ;; aufruft",
              "elements": [
                [
                  0,
                  19
                ],
                [
                  53,
                  76
                ],
                [
                  90,
                  97
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "indem man das Feld \"\"wert\"\" als private deglariert. man kann es dann über die getterMethode aufrufen!",
          "id": "32",
          "answerCategory": "correct",
          "correctionOrComment": "Das geht, indem man das Feld 'wert' als 'private' deklariert. Man kann es dann über die Gettermethode aufrufen!",
          "aspects": [
            {
              "text": "Das geht, indem man das Feld 'wert' als 'private' deklariert",
              "elements": [
                [
                  0,
                  60
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "Man kann es dann über die Gettermethode aufrufen",
              "elements": [
                [
                  62,
                  110
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Das Feld wert ist auf private zu setzen. Durch einen getter für wert kann die Variable von außen ausgelesen werden. Das private verhindert jeden Schreibzugriff außer aus der eigenen Klasse.",
          "id": "33",
          "answerCategory": "correct",
          "correctionOrComment": "Das Feld 'wert' ist auf 'private' zu setzen. Durch einen 'Getter' für 'wert' kann die Variable von außen ausgelesen werden. Das 'private' verhindert jeden Schreibzugriff außer aus der eigenen Klasse.",
          "aspects": [
            {
              "text": "Das Feld 'wert' ist auf 'private' zu setzen",
              "elements": [
                [
                  0,
                  43
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "Durch einen 'Getter' für 'wert' kann die Variable von außen ausgelesen werden",
              "elements": [
                [
                  45,
                  122
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Man nimmt sogenannte Schutzattribute zu Hilfe. In dem Beispiel nimmt man nicht public sondern private und protected.",
          "id": "34",
          "answerCategory": "missconception",
          "correctionOrComment": "Man nimmt sogenannte Schutzattribute zur Hilfe. In dem Beispiel nimmt man nicht 'public' sondern 'private' und 'protected'.",
          "aspects": [
            {
              "text": "In dem Beispiel nimmt man nicht 'public' sondern 'private' und 'protected'",
              "elements": [
                [
                  48,
                  122
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 2
            }
          ]
        },
        {
          "text": "mit der get Methode. Beispielklasse ist auf private gesezt kann aber von außerhalb mit der get Methode gelesen werden",
          "id": "35",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Das geht mit der Gettermethode. Die Beispielklasse ist auf 'private' gesezt, kann aber von außerhalb mit der Gettermethode gelesen werden.",
          "aspects": [
            {
              "text": "Die Beispielklasse ist auf 'private' gesezt",
              "elements": [
                [
                  32,
                  75
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 2
            },
            {
              "text": "Das geht mit der Gettermethode",
              "elements": [
                [
                  0,
                  30
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            },
            {
              "text": "Die Beispielklasse ;; kann aber von außerhalb mit der Gettermethode gelesen werden",
              "elements": [
                [
                  32,
                  50
                ],
                [
                  77,
                  137
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 2
            }
          ]
        },
        {
          "text": "Indem man den dazugehörigen getter definiert aber nicht den setter, der das schreiben erlauben würde.",
          "id": "36",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Indem man den dazugehörigen 'Getter' definiert aber nicht den 'Setter', der das schreiben erlauben würde.",
          "aspects": [
            {
              "text": "Indem man den dazugehörigen 'Getter' definiert",
              "elements": [
                [
                  0,
                  46
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "class Beispielklasse { private int wert; public Beispielklasse (int wert) { this.wert = wert; } public int getWert () { return wert; } private void setWert (int i) { this.wert = i; } } Wennn nur eine private set-Methode für die private Variable wert definiert wird, kann der Wert von wert nicht von außen geändert werden, sondern nur innerhalb der Klasse. Eine public get-Methode ermöglicht jedoch, dass der Wert von überall aus gelesen werden kann.",
          "id": "37",
          "answerCategory": "correct",
          "correctionOrComment": "Der Wert wird mit 'private int wert' deklariert. Wenn nur eine 'private' set-Methode für die 'private' Variable 'wert' definiert wird, kann der Wert von 'wert' nicht von außen geändert werden, sondern nur innerhalb der Klasse. Eine 'public' get-Methode ermöglicht jedoch, dass der Wert von überall aus gelesen werden kann.",
          "aspects": [
            {
              "text": "Der Wert wird mit 'private int wert' deklariert",
              "elements": [
                [
                  0,
                  47
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 1
            },
            {
              "text": "Eine 'public' get-Methode ermöglicht jedoch, dass der Wert von überall aus gelesen werden kann",
              "elements": [
                [
                  227,
                  321
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Es wird nur eine getter- und keine setter-Methode eingefügt. So kann zwar auf die getter-Methode zurückgegriffen und der Wert ausgelesen werden, jedoch kann nicht mithilfe der setter-Methode der Wert verändert werden.",
          "id": "38",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Es wird nur eine getter- und keine setter-Methode eingefügt. So kann zwar auf die getter-Methode zurückgegriffen und der Wert ausgelesen werden, jedoch kann nicht mithilfe der setter-Methode der Wert verändert werden.",
          "aspects": [
            {
              "text": "Es wird nur eine getter- und keine setter-Methode eingefügt",
              "elements": [
                [
                  0,
                  59
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Das Feld wert muss private und darf nicht final sein, es muss eine get-Methode und es darf keine set-Methode vorliegen.",
          "id": "39",
          "answerCategory": "correct",
          "correctionOrComment": "Das Feld 'wert' muss 'private' und darf nicht 'final' sein. Ss muss eine get-Methode und es darf keine set-Methode vorliegen.",
          "aspects": [
            {
              "text": "Das Feld 'wert' muss 'private' ;; sein",
              "elements": [
                [
                  0,
                  30
                ],
                [
                  54,
                  58
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "Ss muss eine get-Methode und es darf keine set-Methode vorliegen",
              "elements": [
                [
                  60,
                  124
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "wert wird als \"\"private\"\" deklariert. danach wird ein getter gesetzt um wert von überall aus lesbar zu machen.",
          "id": "40",
          "answerCategory": "correct",
          "correctionOrComment": "'wert' wird als 'private' deklariert. Danach wird ein Getter gesetzt um 'wert' von überall aus lesbar zu machen.",
          "aspects": [
            {
              "text": "'wert' wird als 'private' deklariert",
              "elements": [
                [
                  0,
                  36
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "Danach wird ein Getter gesetzt um 'wert' von überall aus lesbar zu machen",
              "elements": [
                [
                  38,
                  111
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "-",
          "id": "41",
          "answerCategory": "none",
          "correctionOrComment": "-",
          "aspects": []
        },
        {
          "text": "Falls Wert z.B.: als int. private int wert; public int getWert() { return wert; } //Methode zum Lesen kann von überall aufgerufen werden. private int setWert(int wert) { this.wert = wert;} //methode zum Schreiben kann nur innerhalb der Klasse verwendet werden.",
          "id": "42",
          "answerCategory": "correct",
          "correctionOrComment": "Das Feld wird als 'private int wert' deklariert. Eine 'public' getter-Methode zum Lesen kann von überall aufgerufen werden. Eine private setter-Methode zum Schreiben kann nur innerhalb der Klasse verwendet werden.",
          "aspects": [
            {
              "text": "Das Feld wird als 'private int wert' deklariert",
              "elements": [
                [
                  0,
                  47
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 1
            },
            {
              "text": "Eine 'public' getter-Methode zum Lesen kann von überall aufgerufen werden",
              "elements": [
                [
                  49,
                  122
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "mit getter und setter",
          "id": "43",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Das geht mit Getter und Setter.",
          "aspects": [
            {
              "text": "Das geht mit  ;; Setter",
              "elements": [
                [
                  0,
                  12
                ],
                [
                  24,
                  30
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 2
            },
            {
              "text": "Das geht mit Getter",
              "elements": [
                [
                  0,
                  19
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Feld wert wird mit private deklariert, so ist es nur innerhalb von Beispielklasse lesbar und schreibbar. um es von überall lesen zu können benötigt man noch einer getter methode : public getWert(){ return this.wert; }",
          "id": "44",
          "answerCategory": "correct",
          "correctionOrComment": "Das Feld 'wert' wird mit 'private' deklariert. So ist es nur innerhalb der Beispielklasse lesbar und schreibbar. Um es von überall lesen zu können benötigt man noch eine getter-Methode.",
          "aspects": [
            {
              "text": "Das Feld 'wert' wird mit 'private' deklariert",
              "elements": [
                [
                  0,
                  45
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "Um es von überall lesen zu können benötigt man noch eine getter-Methode",
              "elements": [
                [
                  113,
                  184
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "In der Beispielklasse die Getter-Methode mit Schutzattribut private schreiben. Die Setter-Methode in der gleichen Klasse mit public schreiben.",
          "id": "45",
          "answerCategory": "missconception",
          "correctionOrComment": "In der Beispielklasse die getter-Methode mit dem Schutzattribut 'private' schreiben. Die setter-Methode in der gleichen Klasse mit 'public' schreiben.",
          "aspects": [
            {
              "text": "Die setter-Methode in der gleichen Klasse mit 'public' schreiben",
              "elements": [
                [
                  85,
                  149
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 2
            },
            {
              "text": "In der Beispielklasse die getter-Methode mit dem Schutzattribut 'private' schreiben",
              "elements": [
                [
                  0,
                  83
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 2
            }
          ]
        },
        {
          "text": "wert ist schreibgeschutz d.h privarte. wir konnen eine getWert methode machen und dann diese methode von außen aufrufen.",
          "id": "46",
          "answerCategory": "correct",
          "correctionOrComment": "Das Feld 'wert' ist schreibgeschutz mittels 'private'. Wir konnen eine 'getWert' Methode machen und dann diese Methode von außen aufrufen.",
          "aspects": [
            {
              "text": "Das Feld 'wert' ist schreibgeschutz mittels 'private'",
              "elements": [
                [
                  0,
                  53
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 1
            },
            {
              "text": "Wir konnen eine 'getWert' Methode machen und dann diese Methode von außen aufrufen",
              "elements": [
                [
                  55,
                  137
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "private int wert --> dadurch ist sie nicht von außen zu ändern. public int getWert(){ return wert; die methode ist public, sodass man den wert von außen lesen kann",
          "id": "47",
          "answerCategory": "correct",
          "correctionOrComment": "Durch 'private int wert' ist die Variable nicht von außen zu ändern. Man braucht eine 'public' 'getWert' Methode, sodass man den Wert von außen lesen kann.",
          "aspects": [
            {
              "text": "Durch 'private int wert' ist die Variable nicht von außen zu ändern",
              "elements": [
                [
                  0,
                  67
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 1
            },
            {
              "text": "Man braucht eine 'public' 'getWert' Methode, sodass man den Wert von außen lesen kann",
              "elements": [
                [
                  69,
                  154
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "den Feld wert muss protected sein.",
          "id": "48",
          "answerCategory": "missconception",
          "correctionOrComment": "Das Feld 'wert' muss protected sein.",
          "aspects": [
            {
              "text": "Das Feld 'wert' muss protected sein",
              "elements": [
                [
                  0,
                  35
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 2
            }
          ]
        },
        {
          "text": "wert final setzen und mit public getWert() für andere lesbar machen",
          "id": "49",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Man muss 'wert' 'final' setzen und mit 'public' 'getWert()' für andere lesbar machen.",
          "aspects": [
            {
              "text": "Man muss 'wert' 'final' setzen",
              "elements": [
                [
                  0,
                  30
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 2
            },
            {
              "text": "Man muss 'wert' ;; mit 'public' 'getWert()' für andere lesbar machen",
              "elements": [
                [
                  0,
                  15
                ],
                [
                  35,
                  84
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Zu erst muss das Schutzatribut \"\"private\"\" sein. Dannach kann man mit setter die Variable innerhalb der Klasse schreiben und mit getter überall zu lesen.",
          "id": "50",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Zuerst muss das Schutzattribut 'private' sein. Danach kann man mit einem Setter die Variable innerhalb der Klasse schreiben und mit einem Getter überall lesen.",
          "aspects": [
            {
              "text": "Zuerst muss das Schutzattribut 'private' sein",
              "elements": [
                [
                  0,
                  45
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 1
            },
            {
              "text": "Danach kann man mit einem Setter die Variable innerhalb der Klasse schreiben",
              "elements": [
                [
                  47,
                  123
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 2
            },
            {
              "text": "Danach kann man ;; die Variable ;; mit einem Getter überall lesen",
              "elements": [
                [
                  47,
                  62
                ],
                [
                  80,
                  92
                ],
                [
                  128,
                  158
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "mit einem Getter und keinem Setter",
          "id": "51",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Das geht mit einem Getter und keinem Setter.",
          "aspects": [
            {
              "text": "Das geht mit einem Getter und keinem Setter",
              "elements": [
                [
                  0,
                  43
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Man will, dass \"\"wert\"\" schreibgeschütz auf andere abgeleitete Klassen ist. Deswegen macht man einen Konstruktoir, womit man in der Basisklasse diese Variable benutzen kann. Außerdem braucht man eine getter-methode, damit sie in anderen Klassen lesbar ist. Da privat vor \"\"wert\"\" gesetzt wird, ist es nun nur lesbar aber abgeleitet Klassen können es nicht überscxhreiben. Esa ist das Prinzip der Kapselung/ Schutz vor Überschreibung.",
          "id": "52",
          "answerCategory": "binary_correct",
          "correctionOrComment": "Man will, dass 'wert' schreibgeschütz auf andere abgeleitete Klassen ist. Deswegen macht man einen Konstruktoir, womit man in der Basisklasse diese Variable benutzen kann. Außerdem braucht man eine getter-Methode, damit sie in anderen Klassen lesbar ist. Da 'private' vor 'wert' gesetzt wird, ist es nun nur lesbar aber abgeleitet Klassen können es nicht überschreiben. Es ist das Prinzip der Kapselung und dem Schutz vor Überschreibung.",
          "aspects": [
            {
              "text": "Da 'private' vor 'wert' gesetzt wird",
              "elements": [
                [
                  255,
                  291
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "Außerdem braucht man eine getter-Methode, damit sie in anderen Klassen lesbar ist",
              "elements": [
                [
                  172,
                  253
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Ich setzen \"\"wert\"\" private, dadurch ist es nur für die Klassse Beispielklasse schreibbar. Durch eine Getter Methode ist es überall lesbar.",
          "id": "53",
          "answerCategory": "correct",
          "correctionOrComment": "Ich setze 'wert' 'private'. Dadurch ist es nur für die Klassse Beispielklasse schreibbar. Durch eine getter-Methode ist es überall lesbar.",
          "aspects": [
            {
              "text": "Ich setze 'wert' 'private'",
              "elements": [
                [
                  0,
                  26
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "Durch eine getter-Methode ist es überall lesbar",
              "elements": [
                [
                  90,
                  137
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Mit dem Schutzattribut protected",
          "id": "54",
          "answerCategory": "missconception",
          "correctionOrComment": "Das geht mit dem Schutzattribut 'protected'.",
          "aspects": [
            {
              "text": "Das geht mit dem Schutzattribut 'protected'",
              "elements": [
                [
                  0,
                  43
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 2
            }
          ]
        },
        {
          "text": "protected",
          "id": "55",
          "answerCategory": "missconception",
          "correctionOrComment": "Das geht mit 'protected'.",
          "aspects": [
            {
              "text": "Das geht mit 'protected'",
              "elements": [
                [
                  0,
                  24
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 2
            }
          ]
        },
        {
          "text": "Indem ich wert auf die Sichtbarkeit private lese, aber zusätzlich eine Methode getWert() implementiere (welche public ist). getWert() gibt dann die variable wert zurück (mit return) damit jeder sie auslesen kann.",
          "id": "56",
          "answerCategory": "correct",
          "correctionOrComment": "Das geht, indem ich 'wert' auf die Sichtbarkeit 'private' setze, aber zusätzlich eine Methode 'getWert()' implementiere, welche 'public' ist. 'getWert()' gibt dann die Variable 'wert' zurück, damit jeder sie auslesen kann.",
          "aspects": [
            {
              "text": "Das geht, indem ich 'wert' auf die Sichtbarkeit 'private' setze",
              "elements": [
                [
                  0,
                  63
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "Das geht, indem ich ;; aber zusätzlich eine Methode 'getWert()' implementiere, welche 'public' ist",
              "elements": [
                [
                  0,
                  19
                ],
                [
                  65,
                  140
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        }
      ]
    },
    {
      "id": "5",
      "title": "Vererbung - Schnittstellen und abstrakte Klassen",
      "text": "Sie möchten eine als 'private' deklarierte Variable und mehrere implementierte Methoden vererben. Verwenden Sie eine Schnittstelle oder eine abstrakte Klasse? Begründen Sie Ihre Antwort.",
      "type": "reason",
      "referenceAnswer": {
        "text": "Man muss eine abstrakte Klasse verwenden, weil Schnittstellen keine implementierten Methoden bereitstellen können.",
        "aspects": [
          {
            "text": "Man muss eine abstrakte Klasse verwenden",
            "elements": [
              [
                0,
                40
              ]
            ]
          },
          {
            "text": "weil Schnittstellen keine implementierten Methoden bereitstellen können",
            "elements": [
              [
                42,
                113
              ]
            ]
          }
        ]
      },
      "answersAnnotation": [
        {
          "text": "Abstrakte Klassen Basisklassen vererben nur implemetierte Mehtoden, Schnittstellen stellen keine implementierten Methoden bereit Abstrakte klassen werden durch abstract class deklariert",
          "id": "1",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Abstrakte Klassen vererben nur implemetierte Mehtoden. Schnittstellen stellen keine implementierten Methoden bereit. Abstrakte klassen werden durch 'abstract class' deklariert.",
          "aspects": [
            {
              "text": "Schnittstellen stellen keine implementierten Methoden bereit",
              "elements": [
                [
                  55,
                  115
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Eine abstrakte Klasse, da Schnittstellen keine implemenierte Methoden bereit stellen.",
          "id": "2",
          "answerCategory": "correct",
          "correctionOrComment": "Man verwendet eine abstrakte Klasse, da Schnittstellen keine implemenierte Methoden bereitstellen.",
          "aspects": [
            {
              "text": "Man verwendet eine abstrakte Klasse",
              "elements": [
                [
                  0,
                  35
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "da Schnittstellen keine implemenierte Methoden bereitstellen",
              "elements": [
                [
                  37,
                  97
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Eine Schnittstelle, da abstrakte Klasse keine Methoden weitergeben.",
          "id": "3",
          "answerCategory": "missconception",
          "correctionOrComment": "Man verwendet eine Schnittstelle, da abstrakte Klassen keine Methoden weitergeben.",
          "aspects": [
            {
              "text": "Man verwendet eine Schnittstelle",
              "elements": [
                [
                  0,
                  32
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 2
            },
            {
              "text": "da abstrakte Klassen keine Methoden weitergeben",
              "elements": [
                [
                  34,
                  81
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 2
            }
          ]
        },
        {
          "text": "Schnittstellen vererben keine implementierten Methoden, doch abstrakte Klassen können, wenn sie vereerbt werden implementierte Methoden vererben. Normalerweise müssen sie immer später implementiert werden.",
          "id": "4",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Schnittstellen vererben keine implementierten Methoden. Abstrakte Klassen können, wenn sie vereerbt werden, implementierte Methoden vererben. Normalerweise müssen sie immer später implementiert werden.",
          "aspects": [
            {
              "text": "Schnittstellen vererben keine implementierten Methoden",
              "elements": [
                [
                  0,
                  54
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Basisklassen vererben nur implementierte Methoden, Schnittstellen stellen keine implementierten Methoden bereit. manche Methoden brauchen eine Implementierung gleichzeitig können manche Methoden in der Basisklasse nicht implementiert sein. eine abstrakte Klasse kann unimplementierte Methoden enthalten markiert durch abstract. dacher würde ich eine abstrakte Kalsse wählen.",
          "id": "5",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Basisklassen vererben nur implementierte Methoden. Schnittstellen stellen keine implementierten Methoden bereit. Manche Methoden brauchen eine Implementierung. Gleichzeitig können manche Methoden in der Basisklasse nicht implementiert sein. Eine abstrakte Klasse kann unimplementierte Methoden enthalten. Sie wird markiert durch 'abstract'. Daher würde ich eine abstrakte Klasse wählen.",
          "aspects": [
            {
              "text": "Daher würde ich eine abstrakte Klasse wählen",
              "elements": [
                [
                  341,
                  385
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "Schnittstellen stellen keine implementierten Methoden bereit",
              "elements": [
                [
                  51,
                  111
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "-",
          "id": "6",
          "answerCategory": "none",
          "correctionOrComment": "-",
          "aspects": []
        },
        {
          "text": "Abstrakte Klasse: da Schnittstellen keine implementierten Methoden bereitstellen.",
          "id": "7",
          "answerCategory": "correct",
          "correctionOrComment": "Man verwendet abstrakte Klassen, da Schnittstellen keine implementierten Methoden bereitstellen.",
          "aspects": [
            {
              "text": "Man verwendet abstrakte Klassen",
              "elements": [
                [
                  0,
                  31
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "a Schnittstellen keine implementierten Methoden bereitstellen",
              "elements": [
                [
                  34,
                  95
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Abstrakte Klasse da Schnittstellen keine Implementierten Methoden bereit stellen.",
          "id": "8",
          "answerCategory": "correct",
          "correctionOrComment": "Man verwendet eine abstrakte Klasse, da Schnittstellen keine implementierten Methoden bereitstellen.",
          "aspects": [
            {
              "text": "Man verwendet eine abstrakte Klasse",
              "elements": [
                [
                  0,
                  35
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "da Schnittstellen keine implementierten Methoden bereitstellen",
              "elements": [
                [
                  37,
                  99
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "ich verwende eine abstrakte Klasse weil aus schnittstelle kann ich keine implementierte Methoden vererben.",
          "id": "9",
          "answerCategory": "correct",
          "correctionOrComment": "Ich verwende eine abstrakte Klasse, weil ich aus Schnittstellen keine implementierte Methoden vererben kann.",
          "aspects": [
            {
              "text": "Ich verwende eine abstrakte Klasse",
              "elements": [
                [
                  0,
                  34
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "weil ich aus Schnittstellen keine implementierte Methoden vererben kann",
              "elements": [
                [
                  36,
                  107
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "eine schnittstelle, weil man die darin enthaltenen methoden vererben kann",
          "id": "10",
          "answerCategory": "missconception",
          "correctionOrComment": "Man verwendet eine Schnittstelle, weil man die darin enthaltenen methoden vererben kann.",
          "aspects": [
            {
              "text": "Man verwendet eine Schnittstelle",
              "elements": [
                [
                  0,
                  32
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 2
            },
            {
              "text": "weil man die darin enthaltenen methoden vererben kann",
              "elements": [
                [
                  34,
                  87
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 2
            }
          ]
        },
        {
          "text": "ich verwende eine abstakte Klasse, weil nur in einer abstrakte klasse darf man Variablen deklarieren.",
          "id": "11",
          "answerCategory": "missconception",
          "correctionOrComment": "Ich verwende eine abstakte Klasse, weil man nur in einer abstrakten Klasse Variablen deklarieren darf.",
          "aspects": [
            {
              "text": "Ich verwende eine abstakte Klasse",
              "elements": [
                [
                  0,
                  33
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "",
          "id": "12",
          "answerCategory": "none",
          "correctionOrComment": "",
          "aspects": []
        },
        {
          "text": "eine abstrakte klasse, da in einer schnittstelle die methoden nicht implementiert sein dürfen",
          "id": "13",
          "answerCategory": "correct",
          "correctionOrComment": "Man verwendet eine abstrakte Klasse, da in einer Schnittstelle die Methoden nicht implementiert sein dürfen.",
          "aspects": [
            {
              "text": "Man verwendet eine abstrakte Klasse",
              "elements": [
                [
                  0,
                  35
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "da in einer Schnittstelle die Methoden nicht implementiert sein dürfen",
              "elements": [
                [
                  37,
                  107
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "abstrakte Klasse. Weil sie private ist und sonst nicht verwendet werden kann.",
          "id": "14",
          "answerCategory": "missconception",
          "correctionOrComment": "Man verwendet eine abstrakte Klasse, weil sie 'private' ist und sonst nicht verwendet werden kann.",
          "aspects": [
            {
              "text": "Man verwendet eine abstrakte Klasse",
              "elements": [
                [
                  0,
                  35
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Bereits implementierte Methoden können nicht mit einer abstrakten Klasse vererbt werden. Daher Schnittstelle.",
          "id": "15",
          "answerCategory": "missconception",
          "correctionOrComment": "Bereits implementierte Methoden können nicht mit einer abstrakten Klasse vererbt werden. Daher verwendet man eine Schnittstelle.",
          "aspects": [
            {
              "text": "Daher verwendet man eine Schnittstelle",
              "elements": [
                [
                  89,
                  127
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 2
            },
            {
              "text": "Bereits implementierte Methoden können nicht mit einer abstrakten Klasse vererbt werden",
              "elements": [
                [
                  0,
                  87
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 2
            }
          ]
        },
        {
          "text": "eine abstrakte Klasse, da Schnittstellen keine Datenfelder zurück geben.",
          "id": "16",
          "answerCategory": "missconception",
          "correctionOrComment": "Man verwendet eine abstrakte Klasse, da Schnittstellen keine Datenfelder zurückgeben.",
          "aspects": [
            {
              "text": "Man verwendet eine abstrakte Klasse",
              "elements": [
                [
                  0,
                  35
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Da Schnittstellen keine Methoden implementieren und deren private deklarierte Variablen nicht vererbt werden, verwende man eine abstrakte Klasse.",
          "id": "17",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Da Schnittstellen keine Methoden implementieren und deren private deklarierte Variablen nicht vererbt werden, verwendet man eine abstrakte Klasse.",
          "aspects": [
            {
              "text": "verwendet man eine abstrakte Klasse",
              "elements": [
                [
                  110,
                  145
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "Da Schnittstellen keine Methoden implementieren",
              "elements": [
                [
                  0,
                  47
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Man verwendet eine abstrakte Klasse, da die Schnittstellen nur Konstanten bereitstellen können und die Methoden bei abstrakten Klassen sowohl implementiert, als auch unimplementiert sein können.",
          "id": "18",
          "answerCategory": "correct",
          "correctionOrComment": "Man verwendet eine abstrakte Klasse, da die Schnittstellen nur Konstanten bereitstellen können und die Methoden bei abstrakten Klassen sowohl implementiert, als auch unimplementiert sein können.",
          "aspects": [
            {
              "text": "Man verwendet eine abstrakte Klasse",
              "elements": [
                [
                  0,
                  35
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Eine abstrakte Klasse, da nur diese Datenfelder vererben kann.",
          "id": "19",
          "answerCategory": "missconception",
          "correctionOrComment": "Man verwendet eine abstrakte Klasse, da nur diese Datenfelder vererben kann.",
          "aspects": [
            {
              "text": "Man verwendet eine abstrakte Klasse",
              "elements": [
                [
                  0,
                  35
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Es sollte eine abstrakte Klasse verwendet werden. Die abstrakte Klasse füllt die Lücke zwischen der Basisklasse und der Schnittstelle. Mit einer Schnittstelle lassen sich außerdem keine Variablen und auch keine implementierte Methoden vererben.",
          "id": "20",
          "answerCategory": "binary_correct",
          "correctionOrComment": "Es sollte eine abstrakte Klasse verwendet werden. Die abstrakte Klasse füllt die Lücke zwischen der Basisklasse und der Schnittstelle. Mit einer Schnittstelle lassen sich außerdem keine Variablen und auch keine implementierte Methoden vererben.",
          "aspects": [
            {
              "text": "Es sollte eine abstrakte Klasse verwendet werden",
              "elements": [
                [
                  0,
                  48
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "Mit einer Schnittstelle lassen sich außerdem ;; keine implementierte Methoden vererben",
              "elements": [
                [
                  135,
                  179
                ],
                [
                  205,
                  243
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Schnittstelle",
          "id": "21",
          "answerCategory": "missconception",
          "correctionOrComment": "Man verwendet ein Schnittstelle.",
          "aspects": [
            {
              "text": "Man verwendet ein Schnittstelle",
              "elements": [
                [
                  0,
                  31
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 2
            }
          ]
        },
        {
          "text": "Man verwendet eine Schnittstelle da abstrakte Klassen unimplementierte methoden enthalten können.",
          "id": "22",
          "answerCategory": "missconception",
          "correctionOrComment": "Man verwendet eine Schnittstelle, da abstrakte Klassen unimplementierte Methoden enthalten können.",
          "aspects": [
            {
              "text": "Man verwendet eine Schnittstelle",
              "elements": [
                [
                  0,
                  32
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 2
            }
          ]
        },
        {
          "text": "Die Verwendung einer abstrakten Klasse ist hier sinnvoller, da die bereits implementierten Methoden erhalten bleiben sollten, was bei einer Schnittstelle nicht möglich ist.",
          "id": "23",
          "answerCategory": "correct",
          "correctionOrComment": "Die Verwendung einer abstrakten Klasse ist hier sinnvoller, da die bereits implementierten Methoden erhalten bleiben, was bei einer Schnittstelle nicht möglich ist.",
          "aspects": [
            {
              "text": "Die Verwendung einer abstrakten Klasse ist hier sinnvoller",
              "elements": [
                [
                  0,
                  58
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "da die bereits implementierten Methoden erhalten bleiben, was bei einer Schnittstelle nicht möglich ist",
              "elements": [
                [
                  60,
                  163
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 1
            }
          ]
        },
        {
          "text": "Ich verwende eine abstrakte Klasse, da man in einer Schnittstelle Methoden nur deklarieren kann und noch nicht implementieren. Außerdem kann man in einer Schnittstelle nur Konstanten verwenden.",
          "id": "24",
          "answerCategory": "correct",
          "correctionOrComment": "Ich verwende eine abstrakte Klasse, da man in einer Schnittstelle Methoden nur deklarieren kann und noch nicht implementieren. Außerdem kann man in einer Schnittstelle nur Konstanten verwenden.",
          "aspects": [
            {
              "text": "Ich verwende eine abstrakte Klasse",
              "elements": [
                [
                  0,
                  34
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "da man in einer Schnittstelle Methoden nur deklarieren kann und noch nicht implementieren",
              "elements": [
                [
                  36,
                  125
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "eine abstrakte Klasse, da in einer Schnittstelle nur die Methoden deklariert werden und keine variablen.",
          "id": "25",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Man verwendet eine abstrakte Klasse, da in einer Schnittstelle nur die Methoden deklariert werden und keine Variablen.",
          "aspects": [
            {
              "text": "Man verwendet eine abstrakte Klasse",
              "elements": [
                [
                  0,
                  35
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Ich verwende eine abstrakte Klasse, da mit dieser problemlos Datenfelder vererbt werden können die nicht konstant sind.",
          "id": "26",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Ich verwende eine abstrakte Klasse, da mit dieser problemlos Datenfelder vererbt werden können, die nicht konstant sind.",
          "aspects": [
            {
              "text": "Ich verwende eine abstrakte Klasse",
              "elements": [
                [
                  0,
                  34
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "ich verwende eine abstrakte Klasse, da die abstrakte Klasse Datenfelder bereitstellen kann und Schnittstellen nur konstante. Die Abstrakte Klasse veerbt implementierte Methoden. Schnittstellen stellen keine implementierte Methoden bereit.",
          "id": "27",
          "answerCategory": "correct",
          "correctionOrComment": "Ich verwende eine abstrakte Klasse, da die abstrakte Klasse Datenfelder bereitstellen kann und Schnittstellen nur Konstanten. Die Abstrakte Klasse vererbt implementierte Methoden. Schnittstellen stellen keine implementierten Methoden bereit.",
          "aspects": [
            {
              "text": "Ich verwende eine abstrakte Klasse",
              "elements": [
                [
                  0,
                  34
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "Schnittstellen stellen keine implementierten Methoden bereit",
              "elements": [
                [
                  180,
                  240
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Abstrakte Klassen. Diese Klassen sind spezielle Klassen die viele abstrakte Methoden beinhalten. Entweder abgeleitete Klassen müssen abstract sein oder die abstrakte Methoden sind in dem Fall implementiert.",
          "id": "28",
          "answerCategory": "binary_correct",
          "correctionOrComment": "Man verwendet abstrakte Klassen. Diese Klassen sind spezielle Klassen, die viele abstrakte Methoden beinhalten. Entweder müssen abgeleitete Klassen 'abstract' sein oder die abstrakte Methoden sind in dem Fall implementiert.",
          "aspects": [
            {
              "text": "Man verwendet abstrakte Klassen",
              "elements": [
                [
                  0,
                  31
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "abstrakte Klasse",
          "id": "29",
          "answerCategory": "guessing",
          "correctionOrComment": "Man verwendet eine abstrakte Klasse.",
          "aspects": [
            {
              "text": "Man verwendet eine abstrakte Klasse",
              "elements": [
                [
                  0,
                  35
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Man ver wendet eine abstrakte Klasse, weil Schnittstellen nur Konstanten breitstellen.",
          "id": "30",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Man verwendet eine abstrakte Klasse, weil Schnittstellen nur Konstanten breitstellen.",
          "aspects": [
            {
              "text": "Man verwendet eine abstrakte Klasse",
              "elements": [
                [
                  0,
                  35
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Eine Klasse kann nur eine Basisklasse haben, aber beliebige Schnittsctellen implementieren. Deshalb Schnittstelle.",
          "id": "31",
          "answerCategory": "missconception",
          "correctionOrComment": "Eine Klasse kann nur eine Basisklasse haben, aber beliebige Schnittstellen implementieren. Deshalb verwendet man eine Schnittstelle.",
          "aspects": [
            {
              "text": "Deshalb verwendet man eine Schnittstelle",
              "elements": [
                [
                  91,
                  131
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 2
            }
          ]
        },
        {
          "text": "eine anstrakte Klassse denn abtrakte Klassen können implementiere Methoden enthalten und wenn eine abtrakte Klasse abgeleitet wird, müssen die abtrakt markierten Methoden implementiert werden. um eine private deklarierte Variable zu vererben braucht man auf jeden fall getter und setter. Deshalb verwendet man eine abtrakte Klasse",
          "id": "32",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Man verwendet eine anstrakte Klassse, denn abtrakte Klassen können implementiere Methoden enthalten und wenn eine abtrakte Klasse abgeleitet wird, müssen die abtrakt markierten Methoden implementiert werden. Um eine 'private' deklarierte Variable zu vererben braucht man auf jeden fall Getter und Setter. Deshalb verwendet man eine abtrakte Klasse.",
          "aspects": [
            {
              "text": "Man verwendet eine anstrakte Klassse",
              "elements": [
                [
                  0,
                  36
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "denn abtrakte Klassen können implementiere Methoden enthalten",
              "elements": [
                [
                  38,
                  99
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 1
            }
          ]
        },
        {
          "text": "eine abstrakte weil die basis klassen können datenfelder bereitstellen aber die schnittstellen nur konstanten Baisklassen vererben nur implementierte methoden. PS man kann keine konkrete objekte erzeugen.",
          "id": "33",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Man verwendet eine abstrakte Klasse, weil die Basisklassen Datenfelder bereitstellen können Schnittstellen aber  nur Konstanten. Baisklassen vererben nur implementierte Methoden.",
          "aspects": [
            {
              "text": "Man verwendet eine abstrakte Klasse",
              "elements": [
                [
                  0,
                  35
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Ich verwende eine abstrakte Klasse: Impl. Methoden können verwendet werden. Bei Schnittstellen können Methoden nicht Impl.",
          "id": "34",
          "answerCategory": "correct",
          "correctionOrComment": "Ich verwende eine abstrakte Klasse, weil dort implementierte Methoden verwendet werden können. Bei Schnittstellen können Methoden nicht implementiert vererbt werden.",
          "aspects": [
            {
              "text": "Ich verwende eine abstrakte Klasse",
              "elements": [
                [
                  0,
                  34
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "Bei Schnittstellen können Methoden nicht implementiert vererbt werden",
              "elements": [
                [
                  95,
                  164
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "mit Schnittstelle werden wir \"\"Implement\"\"benutzen ,weil die schnittstelle alle benötige Informationen beihaltet. Mit Abstrakte Klassen auf grund der kapselung von Intanzen.",
          "id": "35",
          "answerCategory": "missconception",
          "correctionOrComment": "Wir werden Schnittstellen mit 'implements' benutzen, weil die Schnittstelle alle benötigten Informationen beinhaltet.",
          "aspects": [
            {
              "text": "Wir werden Schnittstellen mit 'implements' benutzen",
              "elements": [
                [
                  0,
                  51
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 2
            },
            {
              "text": "weil die Schnittstelle alle benötigten Informationen beinhaltet",
              "elements": [
                [
                  53,
                  116
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 2
            }
          ]
        },
        {
          "text": "Ich verwende eine abstrakte Klasse, da diese implementierte Methoden enthalten darf und private Variablen erlaubt sind. Selbst wenn manche Methoden mit abstract gekennzeichnet sind, ist es erlaubt, die abstrakte Klasse zu vererben, wenn alle mit abstact gekennzeichneten Methoden implementiert sind. Wenn es eine abstrakte Methode gibt, die nicht implementiert ist, muss die abgeleitete Klasse auch abstract sein, was in diesem Fall aber nicht so ist.",
          "id": "36",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Ich verwende eine abstrakte Klasse, da diese implementierte Methoden enthalten darf und 'private' Variablen erlaubt sind. Selbst wenn manche Methoden mit 'abstract' gekennzeichnet sind, ist es erlaubt die abstrakte Klasse zu vererben, wenn alle mit 'abstract' gekennzeichneten Methoden implementiert sind. Wenn es eine abstrakte Methode gibt, die nicht implementiert ist, muss die abgeleitete Klasse auch 'abstract' sein, was in diesem Fall aber nicht so ist.",
          "aspects": [
            {
              "text": "Ich verwende eine abstrakte Klasse",
              "elements": [
                [
                  0,
                  34
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "da diese implementierte Methoden enthalten darf",
              "elements": [
                [
                  36,
                  83
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 1
            }
          ]
        },
        {
          "text": "ich verwende eine Abstrakte klasse, da ich ich Methoden Implementieren will und eine schnittstelle keine Implementierung erlaubt und die private variable ist auch ein hinweis darauf, da man auf sie mit einem Getter zugreifen muss",
          "id": "37",
          "answerCategory": "correct",
          "correctionOrComment": "Ich verwende eine abstrakte Klasse, da ich Methoden implementieren will und eine Schnittstelle keine Implementierung erlaubt. Die 'private' Variable ist auch ein Hinweis darauf, dass man auf sie mit einem Getter zugreifen muss.",
          "aspects": [
            {
              "text": "Ich verwende eine abstrakte Klasse",
              "elements": [
                [
                  0,
                  34
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "da ;; eine Schnittstelle keine Implementierung erlaubt",
              "elements": [
                [
                  36,
                  38
                ],
                [
                  76,
                  124
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Man verwendet dafür eine abstrakte Klasse. Da abstrakte Klassen nicht nur Mehtoden implementiern können sondern auch Datenfelder.",
          "id": "38",
          "answerCategory": "binary_correct",
          "correctionOrComment": "Man verwendet dafür eine abstrakte Klasse, da abstrakte Klassen nicht nur Mehtoden implementiern können sondern auch Datenfelder.",
          "aspects": [
            {
              "text": "Man verwendet dafür eine abstrakte Klasse",
              "elements": [
                [
                  0,
                  41
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Man verwendet eine abstrakte Klasse, da Schnittstellen keine implementierte Methoden bereitstellen.",
          "id": "39",
          "answerCategory": "correct",
          "correctionOrComment": "Man verwendet eine abstrakte Klasse, da Schnittstellen keine implementierten Methoden bereitstellen.",
          "aspects": [
            {
              "text": "Man verwendet eine abstrakte Klasse",
              "elements": [
                [
                  0,
                  35
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "da Schnittstellen keine implementierten Methoden bereitstellen",
              "elements": [
                [
                  37,
                  99
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "eine abstrakte Klasse da Schnittstellen eher für das implementieren für Methoden zuständig sind.",
          "id": "40",
          "answerCategory": "missconception",
          "correctionOrComment": "Man verwendet eine abstrakte Klasse, da Schnittstellen eher für das implementieren von Methoden zuständig sind.",
          "aspects": [
            {
              "text": "Man verwendet eine abstrakte Klasse",
              "elements": [
                [
                  0,
                  35
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "da Schnittstellen eher für das implementieren von Methoden zuständig sind",
              "elements": [
                [
                  37,
                  110
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 2
            }
          ]
        },
        {
          "text": "Man nimmt eine abstrakte Klasse, da Schnittstellen nur Konstanten vererben können.",
          "id": "41",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Man nimmt eine abstrakte Klasse, da Schnittstellen nur Konstanten vererben können.",
          "aspects": [
            {
              "text": "Man nimmt eine abstrakte Klasse",
              "elements": [
                [
                  0,
                  31
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Eine Schnittstelle, bei einer abstrakten Klasse darf man nicht inistanzieieren.",
          "id": "42",
          "answerCategory": "missconception",
          "correctionOrComment": "Man verwendet eine Schnittstelle, weil man bei einer abstrakten Klasse nicht instanziieren darf.",
          "aspects": [
            {
              "text": "Man verwendet eine Schnittstelle",
              "elements": [
                [
                  0,
                  32
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 2
            }
          ]
        },
        {
          "text": "Eine abstrakte Klasse, da Methoden in einer Schnittstelle nicht implementiert sein dürfen.",
          "id": "43",
          "answerCategory": "correct",
          "correctionOrComment": "Man nimmt eine abstrakte Klasse, da Methoden in einer Schnittstelle nicht implementiert sein dürfen.",
          "aspects": [
            {
              "text": "Man nimmt eine abstrakte Klasse",
              "elements": [
                [
                  0,
                  31
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "da Methoden in einer Schnittstelle nicht implementiert sein dürfen",
              "elements": [
                [
                  33,
                  99
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Abstrakte Klassen, denn sie können bereits implementierte Methoden beinhalten, Schnittstellen sind nicht implementiert.",
          "id": "44",
          "answerCategory": "correct",
          "correctionOrComment": "Man verwendet abstrakte Klassen, denn sie können bereits implementierte Methoden beinhalten. Methoden in Schnittstellen sind nicht implementiert.",
          "aspects": [
            {
              "text": "Man verwendet abstrakte Klassen",
              "elements": [
                [
                  0,
                  31
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "Methoden in Schnittstellen sind nicht implementiert",
              "elements": [
                [
                  93,
                  144
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "-",
          "id": "45",
          "answerCategory": "none",
          "correctionOrComment": "-",
          "aspects": []
        },
        {
          "text": "-",
          "id": "46",
          "answerCategory": "none",
          "correctionOrComment": "-",
          "aspects": []
        },
        {
          "text": "eine abstrakte klasse weil es um merere methoden geht die private seien sollen",
          "id": "47",
          "answerCategory": "missconception",
          "correctionOrComment": "Man nimmt eine abstrakte Klasse, weil es um mehrere Methoden geht die 'private' seien sollen.",
          "aspects": [
            {
              "text": "Man nimmt eine abstrakte Klasse",
              "elements": [
                [
                  0,
                  31
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Schnittstelle",
          "id": "48",
          "answerCategory": "guessing",
          "correctionOrComment": "Man nimmt eine Schnittstelle.",
          "aspects": [
            {
              "text": "Man nimmt eine Schnittstelle",
              "elements": [
                [
                  0,
                  28
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 2
            }
          ]
        },
        {
          "text": "Eine Abstrakte Klasse, weil diese auch auf private deklarierte Variable und Methoden zugreifen kann.",
          "id": "49",
          "answerCategory": "missconception",
          "correctionOrComment": "Man nimmt eine abstrakte Klasse, weil diese auch auf 'private' deklarierte Variablen und Methoden zugreifen kann.",
          "aspects": [
            {
              "text": "Man nimmt eine abstrakte Klasse",
              "elements": [
                [
                  0,
                  31
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Man verwendet eine abstrakte Klasse, da Schnittstellen keine implementierte Methoden zur Verfügung stellen.",
          "id": "50",
          "answerCategory": "correct",
          "correctionOrComment": "Man verwendet eine abstrakte Klasse, da Schnittstellen keine implementierten Methoden zur Verfügung stellen.",
          "aspects": [
            {
              "text": "Man verwendet eine abstrakte Klasse",
              "elements": [
                [
                  0,
                  35
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "da Schnittstellen keine implementierten Methoden zur Verfügung stellen",
              "elements": [
                [
                  37,
                  107
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "-",
          "id": "51",
          "answerCategory": "none",
          "correctionOrComment": "-",
          "aspects": []
        },
        {
          "text": "eine abstrakte Klasse weil die Unterklassen von ihr erben.",
          "id": "52",
          "answerCategory": "missconception",
          "correctionOrComment": "Man nimmt eine abstrakte Klasse, weil die Unterklassen von ihr erben.",
          "aspects": [
            {
              "text": "Man nimmt eine abstrakte Klasse",
              "elements": [
                [
                  0,
                  31
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Ich würde eine Schnittstelle benutzen.",
          "id": "53",
          "answerCategory": "guessing",
          "correctionOrComment": "Ich würde eine Schnittstelle benutzen.",
          "aspects": [
            {
              "text": "Ich würde eine Schnittstelle benutzen",
              "elements": [
                [
                  0,
                  37
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 2
            }
          ]
        },
        {
          "text": "eine Abstrakte, da bei der Schnittstelle man ,nach der Vererbung, die Methoden noch implementieren muss.",
          "id": "54",
          "answerCategory": "correct",
          "correctionOrComment": "Man nimmt eine abstrakte Klasse, da man bei der Schnittstelle die Methoden nach der Vererbung noch implementieren muss.",
          "aspects": [
            {
              "text": "Man nimmt eine abstrakte Klasse",
              "elements": [
                [
                  0,
                  31
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "da man bei der Schnittstelle die Methoden nach der Vererbung noch implementieren muss",
              "elements": [
                [
                  33,
                  118
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Eine abstrake Klasse da die Methoden implementiert sein sollen.",
          "id": "55",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Eine abstrake Klasse, da die Methoden implementiert sein sollen.",
          "aspects": [
            {
              "text": "Eine abstrake Klasse",
              "elements": [
                [
                  0,
                  20
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Abstrakte Klasse: die privat deklarierte Variable ist nur in einer Klasse sichtbar.",
          "id": "56",
          "answerCategory": "missconception",
          "correctionOrComment": "Man nimmt eine abstrakte Klasse, da die privat deklarierte Variable nur in einer Klasse sichtbar ist.",
          "aspects": [
            {
              "text": "Man nimmt eine abstrakte Klasse",
              "elements": [
                [
                  0,
                  31
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            }
          ]
        }
      ]
    },
    {
      "id": "13",
      "text": "Erklären Sie den Zusammenhang zwischen Klassen und Objekten.",
      "title": "Zusammenhang zwischen Klassen und Objekten",
      "type": "reason",
      "referenceAnswer": {
        "text": "Eine Klasse ist der Bauplan für ein Objekt. Ein Objekt ist eine konkrete Instanz einer Klasse.",
        "aspects": [
          {
            "text": "Eine Klasse ist der Bauplan für ein Objekt",
            "elements": [
              [
                0,
                42
              ]
            ]
          },
          {
            "text": "Ein Objekt ist eine konkrete Instanz einer Klasse",
            "elements": [
              [
                44,
                93
              ]
            ]
          }
        ]
      },
      "answersAnnotation": [
        {
          "text": "Alle Objekte haben einen Bauplan und dieser Bauplan des Objektes ist die klasse. Objekte haben den Typ ihrer Klasse. Die Klasse eines Objekte ist wie bei uns Menschen die DNA. Die Klasse bestimmt Aussehen und Eigenschaften. Aber ist selber nicht das Objekt.",
          "id": "61",
          "answerCategory": "binary_correct",
          "correctionOrComment": "Alle Objekte haben einen Bauplan und dieser Bauplan des Objektes ist die Klasse. Objekte haben den Typ ihrer Klasse. Die Klasse eines Objekte ist wie bei uns Menschen die DNA. Die Klasse bestimmt Aussehen und Eigenschaften, aber ist selber nicht das Objekt.",
          "aspects": [
            {
              "text": "Alle Objekte haben einen Bauplan und dieser Bauplan des Objektes ist die Klasse",
              "elements": [
                [
                  0,
                  79
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "Objekte haben den Typ ihrer Klasse",
              "elements": [
                [
                  81,
                  115
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 1
            }
          ]
        },
        {
          "text": "alle objekte entstehen durch einen Bauplan. Dieser Bauplan ist die Klasse des Objektes, das Objekt ist eine Instanz der Klasse. Objekte haben ihren typ in der klasse. Die Klasseeines objektes ist für das objekt ca das selbe wie die DNA für den menschen. -sie bestimmt aussehen und eigenschaft. ist aber selbst nicht das Objekt.",
          "id": "62",
          "answerCategory": "correct",
          "correctionOrComment": "Alle Objekte entstehen durch einen Bauplan. Dieser Bauplan ist die Klasse des Objektes. Das Objekt ist eine Instanz der Klasse. Objekte haben ihren Typ in der Klasse. Die Klasse eines Objektes ist für das Objekt ungefähr dasselbe, wie die DNA für den Menschen. Sie bestimmt Aussehen und Eigenschaften sind aber nicht selbst das Objekt.",
          "aspects": [
            {
              "text": "Alle Objekte entstehen durch einen Bauplan. Dieser Bauplan ist die Klasse des Objektes",
              "elements": [
                [
                  0,
                  86
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "Das Objekt ist eine Instanz der Klasse",
              "elements": [
                [
                  88,
                  126
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "objekt ist zum bsp ein bauplan und der Bauplan wäre in dem fall eine Klasse. Klassen sind bestimmte themen berreiche bsp auch Autos und objekt wäre in dem fall ein",
          "id": "63",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Ein Objekt ist zum Beispiel ein Bauplan und der Bauplan wäre in dem Fall eine Klasse. Klassen sind bestimmte Themenbereiche.",
          "aspects": [
            {
              "text": "Ein Objekt ist zum Beispiel ein Bauplan und der Bauplan wäre in dem Fall eine Klasse",
              "elements": [
                [
                  0,
                  84
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 2
            }
          ]
        },
        {
          "text": "Die Klassen sind der Bauplan von Objekten. Objekte kann man sich selber zulegen indem man sie mit \"\"new\"\" neu definiert.",
          "id": "64",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Die Klassen sind der Bauplan von Objekten. Objekte kann man sich selber zulegen, indem man sie mit 'new' neu definiert.",
          "aspects": [
            {
              "text": "Die Klassen sind der Bauplan von Objekten",
              "elements": [
                [
                  0,
                  41
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Die Klasse ist der Bauplan für das Objekt, heißt das Objekt ist eine Instanz der Klasse. In der Klasse wird das Gerüst aufgebaut auf das sich das Objekt bezieht und hier die Fähigkeiten definiert werden bzw. Objekte haben den Typ ihrer Klasse",
          "id": "65",
          "answerCategory": "correct",
          "correctionOrComment": "Die Klasse ist der Bauplan für das Objekt. Das heißt, das Objekt ist eine Instanz der Klasse. In der Klasse wird das Gerüst aufgebaut auf das sich das Objekt bezieht und die Fähigkeiten werden definiert. Objekte haben den Typ ihrer Klasse.",
          "aspects": [
            {
              "text": "Die Klasse ist der Bauplan für das Objekt",
              "elements": [
                [
                  0,
                  41
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "Das heißt, das Objekt ist eine Instanz der Klasse",
              "elements": [
                [
                  43,
                  92
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Objekt wird durch seine Klasse definiert. Die Klasse ist der Bauplan für das Objekt. Bauplan = Klasse des Objektes und Objekt = Instanz der Klasse. Objekte haben die Typen der Klasse Code der klasse legt die Eigenschaften der Objekte fest",
          "id": "66",
          "answerCategory": "correct",
          "correctionOrComment": "Ein Objekt wird durch seine Klasse definiert. Die Klasse ist der Bauplan für das Objekt. Der Bauplan ist die Klasse des Objektes und das Objekt ist die Instanz der Klasse. Objekte haben die Typen der Klasse. Der Code der Klasse legt die Eigenschaften der Objekte fest.",
          "aspects": [
            {
              "text": "Ein Objekt wird durch seine Klasse definiert. Die Klasse ist der Bauplan für das Objekt",
              "elements": [
                [
                  0,
                  87
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "das Objekt ist die Instanz der Klasse",
              "elements": [
                [
                  133,
                  170
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Die Klasse eines Objektes ist für das Objekt wie die DNA für den Menschen: Klasse bestimmt aussehen und Eigenschaften aber ist nicht selbst das Objekt. Objekte entstehen durch eine Art Bauplan. Der Bauplan ist die Klasse eines Objekts",
          "id": "67",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Die Klasse eines Objektes ist für das Objekt wie die DNA für den Menschen. Die Klasse bestimmt Aussehen und Eigenschaften aber ist nicht selbst das Objekt. Objekte entstehen durch eine Art Bauplan. Der Bauplan ist die Klasse eines Objekts.",
          "aspects": [
            {
              "text": "Der Bauplan ist die Klasse eines Objekts",
              "elements": [
                [
                  198,
                  238
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Klassen sind der Bauplan von Objekten. Objekte entstehen mit new.",
          "id": "68",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Klassen sind der Bauplan von Objekten. Objekte entstehen mit 'new'.",
          "aspects": [
            {
              "text": "Klassen sind der Bauplan von Objekten",
              "elements": [
                [
                  0,
                  37
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Die Klasse des Objektes ist für das Objekt in etwa wie die DNA beim Menschen. Sie bestimmt Aussehen und Eigenschaften des Objekts, aber die Klasse ist nicht das Objekt selbst, von jeder Klasse kann auch ein Objekt erstellt werden.",
          "id": "69",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Die Klasse des Objektes ist für das Objekt in etwa wie die DNA beim Menschen. Sie bestimmt Aussehen und Eigenschaften des Objekts, aber die Klasse ist nicht das Objekt selbst. Von jeder Klasse kann auch ein Objekt erstellt werden.",
          "aspects": [
            {
              "text": "Die Klasse des Objektes ist für das Objekt in etwa wie die DNA beim Menschen. Sie bestimmt Aussehen und Eigenschaften des Objekts",
              "elements": [
                [
                  0,
                  129
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 1
            }
          ]
        },
        {
          "text": "Eine Klasse ist wie eine Art Bauplan für den Objekt . Ein Objekt ist ein Instanz der Klasse und enthält die Element wie in der Klasse",
          "id": "70",
          "answerCategory": "correct",
          "correctionOrComment": "Eine Klasse ist wie eine Art Bauplan für ein Objekt . Ein Objekt ist eine Instanz der Klasse und enthält die Elemente wie in der Klasse.",
          "aspects": [
            {
              "text": "Eine Klasse ist wie eine Art Bauplan für ein Objekt",
              "elements": [
                [
                  0,
                  51
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "Ein Objekt ist eine Instanz der Klasse",
              "elements": [
                [
                  54,
                  92
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "eine klasee ist wie baustein fuer die objektealle Faehigkeiten des objektes werden durch die Klasse definiert.",
          "id": "71",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Eine Klasse ist wie ein Baustein für die Objekte. Alle Fähigkeiten des Objektes werden durch die Klasse definiert.",
          "aspects": [
            {
              "text": "Eine Klasse ist wie ein Baustein für die Objekte",
              "elements": [
                [
                  0,
                  48
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 1
            },
            {
              "text": "Alle Fähigkeiten des Objektes werden durch die Klasse definiert",
              "elements": [
                [
                  50,
                  113
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 1
            }
          ]
        },
        {
          "text": "Alle Objekte entstehen durch einen Bauplan Dieser Bauplan ist die Klasse des Objektes, das Objekt ist eine Instanz der Klasse. Objekte haben den Typ ihrer Klasse Die Klasse eines Objektes ist für das Objekt in etwa dasselbe wie die DNA für den Menschen Sie besto,,t aussehen und eigenschaften ABER SIE selbst ist nicht das objekt",
          "id": "72",
          "answerCategory": "correct",
          "correctionOrComment": "Alle Objekte entstehen durch einen Bauplan. Dieser Bauplan ist die Klasse des Objektes. Das Objekt ist eine Instanz der Klasse. Objekte haben den Typ ihrer Klasse. Die Klasse eines Objektes ist für das Objekt in etwa dasselbe wie die DNA für den Menschen. Sie bestimmt aussehen und Eigenschaften, aber sie selbst ist nicht das Objekt.",
          "aspects": [
            {
              "text": "Alle Objekte entstehen durch einen Bauplan. Dieser Bauplan ist die Klasse des Objektes",
              "elements": [
                [
                  0,
                  86
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "Das Objekt ist eine Instanz der Klasse",
              "elements": [
                [
                  88,
                  126
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Die Klasse ist übergeordnet. zum beispiel ist ein objekt eine instanz 7 eine eigenschaft der klasse.",
          "id": "73",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Die Klasse ist übergeordnet. Ein Objekt ist zum Beispiel eine Instanz. 7 ist eine Eigenschaft der Klasse.",
          "aspects": []
        },
        {
          "text": "In der Klasse wird der Code generiert und koppelt die Daten und die Funktion im Objekt. Somit ist die Klasse der Bauplan vom Objekt.",
          "id": "74",
          "answerCategory": "partially_correct",
          "correctionOrComment": "In der Klasse wird der Code generiert und koppelt die Daten und die Funktionen im Objekt. Somit ist die Klasse der Bauplan vom Objekt.",
          "aspects": [
            {
              "text": "Somit ist die Klasse der Bauplan vom Objekt",
              "elements": [
                [
                  90,
                  133
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Eine Klasse ist ein Bauplan für dessen Objekte. Über den Klassennamen wird das Objekt instanziiert, z.B. Auto auto = new Auto() SEMICOLON Innerhalb der runden Klammern kann man nun, sofern im Konstruktor der Klasse Auto angelegt, schon Attribute übergeben, z.B. Auto auto = new Auto(\"\"Ferrari\"\") SEMICOLON Die Klasse legt also die Eigenschaften eines Objektes fest. (Bei Frage 2 wusste ich nicht ob auf oder absteigend, da die Zeilennummern anders herum da stehen. Ich habe in Zeile 3 den ersten Schritt geschrieben, Zeile 2 den zweiten und Zeile 1 den letzten)",
          "id": "75",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Eine Klasse ist ein Bauplan für dessen Objekte. Über den Klassennamen wird das Objekt instanziiert. Innerhalb der runden Klammern kann man nun sofern im Konstruktor der Klasse angelegt, schon Attribute übergeben. Die Klasse legt also die Eigenschaften eines Objektes fest.",
          "aspects": [
            {
              "text": "Eine Klasse ist ein Bauplan für dessen Objekte",
              "elements": [
                [
                  0,
                  46
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "Über den Klassennamen wird das Objekt instanziiert",
              "elements": [
                [
                  48,
                  98
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 1
            }
          ]
        },
        {
          "text": "Klasse ist der Bauplan für ein Objekt. Das Objekt ist eine Instanz. Die Klasse enthält die wichtigsten \"\"Oberbegriffe\"\" für ein Objekt. Damit kann man viele Klassen anlegen und diese in einer Main-Methode zusammenfügen.",
          "id": "76",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Die Klasse ist der Bauplan für ein Objekt. Das Objekt ist eine Instanz. Die Klasse enthält die wichtigsten Oberbegriffe für ein Objekt. Damit kann man viele Klassen anlegen und diese in einer 'main' Methode zusammenfügen.",
          "aspects": [
            {
              "text": "Die Klasse ist der Bauplan für ein Objekt",
              "elements": [
                [
                  0,
                  41
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "Das Objekt ist eine Instanz",
              "elements": [
                [
                  43,
                  70
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 1
            }
          ]
        },
        {
          "text": "Die Klasse ist der Bauplan des Objektes. Sie enthält die Attribute/Eigenschaften des Objektes. Ein Beispiel in der realen Welt für eine Klasse wäre die DNA des Objektes Mensch.",
          "id": "77",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Die Klasse ist der Bauplan des Objektes. Sie enthält die Attribute und Eigenschaften des Objektes. Ein Beispiel in der realen Welt für eine Klasse wäre die DNA des Objektes Mensch.",
          "aspects": [
            {
              "text": "Die Klasse ist der Bauplan des Objektes",
              "elements": [
                [
                  0,
                  39
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Eine Klasse kann in mehreren Objekten sein, andersrum jedoch nicht.Verschiedene Klassen ergeben/definieren ein Objekt.",
          "id": "78",
          "answerCategory": "missconception",
          "correctionOrComment": "Eine Klasse kann in mehreren Objekten sein, andersrum jedoch nicht. Verschiedene Klassen ergeben und definieren ein Objekt.",
          "aspects": []
        },
        {
          "text": "Klassen bilden eine Anleitung für Objekte. Ein Objekt ist eine Instanz einer Klasse. Eine Klasse beschreibt die Methoden die auf ein Objekt angewendet werden können.",
          "id": "79",
          "answerCategory": "correct",
          "correctionOrComment": "Klassen bilden eine Anleitung für Objekte. Ein Objekt ist eine Instanz einer Klasse. Eine Klasse beschreibt die Methoden, die auf ein Objekt angewendet werden können.",
          "aspects": [
            {
              "text": "Klassen bilden eine Anleitung für Objekte",
              "elements": [
                [
                  0,
                  41
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "Ein Objekt ist eine Instanz einer Klasse.",
              "elements": [
                [
                  43,
                  84
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Die Klasse eines Objektes ist wie die DNA eines Menschen.",
          "id": "80",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Die Klasse eines Objektes ist wie die DNA eines Menschen.",
          "aspects": []
        },
        {
          "text": "Der Code einer Klasse legt die Eigenschaft der Objekte fest",
          "id": "81",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Der Code einer Klasse legt die Eigenschaft der Objekte fest.",
          "aspects": []
        },
        {
          "text": "Klassen sind der Bauplan von Objekten. In Klassen werden die Attribute von Objekten beschrieben",
          "id": "82",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Klassen sind der Bauplan von Objekten. In Klassen werden die Attribute von Objekten beschrieben.",
          "aspects": [
            {
              "text": "Klassen sind der Bauplan von Objekten",
              "elements": [
                [
                  0,
                  37
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Die Objekte sind Baupläne für das Programm. Die Klassen beinhalten diese Objekte und verwenden sie.",
          "id": "83",
          "answerCategory": "missconception",
          "correctionOrComment": "Die Objekte sind Baupläne für das Programm. Die Klassen beinhalten diese Objekte und verwenden sie.",
          "aspects": []
        },
        {
          "text": "Die Klasse ist der \"\"Plan\"\" für das Projekt, dort steht was mit den erstellten Projekten \"\"gemacht\"\" wird. Das heißt Sie beinhalten die Objekte und verwenden sie. Die Objekte werden erzeugt, um für eine Art mehrere Eigenschaften zu speichern, die dann in der Klasse aufgerufen werden können.",
          "id": "84",
          "answerCategory": "missconception",
          "correctionOrComment": "Die Klasse ist der Plan für das Projekt. Dort steht was mit den erstellten Projekten gemacht wird. Das heißt, sie beinhalten die Objekte und verwenden sie. Die Objekte werden erzeugt, um für eine Art mehrere Eigenschaften zu speichern, die dann in der Klasse aufgerufen werden können.",
          "aspects": []
        },
        {
          "text": "Objekte sind Baupläne für das Programm. Die Klassen sind deren Inhalte und werden von Objekten verwendet",
          "id": "85",
          "answerCategory": "missconception",
          "correctionOrComment": "Objekte sind Baupläne für das Programm. Die Klassen sind deren Inhalte und werden von Objekten verwendet.",
          "aspects": []
        },
        {
          "text": "Klassen sind vordefinierte Objekte",
          "id": "86",
          "answerCategory": "missconception",
          "correctionOrComment": "Klassen sind vordefinierte Objekte.",
          "aspects": []
        },
        {
          "text": "Objekte haben den typ ihrer klasse alle Objekte haben einen Bauplan dieser Bauplan ist die klasse des objektes das objekt ist das Instanz einer klasse",
          "id": "87",
          "answerCategory": "correct",
          "correctionOrComment": "Objekte haben den Typ ihrer Klasse. Alle Objekte haben einen Bauplan. Dieser Bauplan ist die Klasse des Objektes. Das Objekt ist die Instanz einer Klasse.",
          "aspects": [
            {
              "text": "Alle Objekte haben einen Bauplan. Dieser Bauplan ist die Klasse des Objektes",
              "elements": [
                [
                  36,
                  112
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "Das Objekt ist die Instanz einer Klasse",
              "elements": [
                [
                  114,
                  153
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Die Klasse ist das Bauplan für das Objekt. Objekt ist das instanz der Klasse . Klasse bestimmt Eigenschaften des Objekts aber sie ist nicht das Objekt.",
          "id": "88",
          "answerCategory": "correct",
          "correctionOrComment": "Die Klasse ist der Bauplan für das Objekt. Das Objekt ist die Instanz der Klasse. Eine Klasse bestimmt die Eigenschaften des Objekts, aber sie ist nicht das Objekt.",
          "aspects": [
            {
              "text": "Die Klasse ist der Bauplan für das Objekt",
              "elements": [
                [
                  0,
                  41
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "Das Objekt ist die Instanz der Klasse",
              "elements": [
                [
                  43,
                  80
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Klasse ist ein Bauplan für Objekt Klasse definiert den Typ des Objektes Objekt ist ein Ausprägung",
          "id": "89",
          "answerCategory": "binary_correct",
          "correctionOrComment": "Die Klasse ist ein Bauplan für das Objekt. Eine Klasse definiert den Typ des Objektes. Das Objekt ist ein Ausprägung.",
          "aspects": [
            {
              "text": "Die Klasse ist ein Bauplan für das Objekt",
              "elements": [
                [
                  0,
                  41
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "Das Objekt ist ein Ausprägung",
              "elements": [
                [
                  87,
                  116
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Objekte werden von Klassen definiert. Eine Klasse beschreibt die Variablen, Eigenschaften .... eines Objekts. Objekte sind Instanzen von Klassen. Die klasse wird zu Verwendung von Objekten erstellt, daher sind Objekten Plätzchen.",
          "id": "90",
          "answerCategory": "correct",
          "correctionOrComment": "Objekte werden von Klassen definiert. Eine Klasse beschreibt die Variablen und Eigenschaften eines Objekts. Objekte sind Instanzen von Klassen. Die Klasse wird zur Verwendung von Objekten erstellt.",
          "aspects": [
            {
              "text": "Objekte werden von Klassen definiert. Eine Klasse beschreibt die Variablen und Eigenschaften eines Objekts",
              "elements": [
                [
                  0,
                  106
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "Objekte sind Instanzen von Klassen",
              "elements": [
                [
                  108,
                  142
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Die Klasse ist der \"\"Bauplan\"\" für das Objekt, sie definiert u.a. die Fähigkeiten des Objekts und regelt den Zugriff auf das Objekt",
          "id": "91",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Die Klasse ist der Bauplan für das Objekt. Sie definiert unter anderem die Fähigkeiten des Objekts und regelt den Zugriff auf das Objekt.",
          "aspects": [
            {
              "text": "Die Klasse ist der Bauplan für das Objekt",
              "elements": [
                [
                  0,
                  41
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "-",
          "id": "92",
          "answerCategory": "none",
          "correctionOrComment": "-",
          "aspects": []
        }
      ]
    },
    {
      "id": "14",
      "text": "Was unterscheidet in JAVA Klassenvariablen von Instanzvariablen?",
      "title": "Klassen- und Instanzvariable",
      "type": "comparison",
      "referenceAnswer": {
        "text": "Klassenvariablen existieren einmal pro Klasse, auch ohne eine konkrete Instanz. Instanzvariable existiert einmal pro Objekt.",
        "aspects": [
          {
            "text": "Klassenvariablen existieren einmal pro Klasse",
            "elements": [
              [
                0,
                45
              ]
            ]
          },
          {
            "text": "Klassenvariablen existieren ;; auch ohne eine konkrete Instanz",
            "elements": [
              [
                0,
                37
              ],
              [
                47,
                78
              ]
            ]
          },
          {
            "text": "Instanzvariable existiert einmal pro Objekt",
            "elements": [
              [
                80,
                123
              ]
            ]
          }
        ]
      },
      "answersAnnotation": [
        {
          "text": "Klassenvariable ist für die ganze klasse bestimmte variable und die Instanzvariable ist für den jeweiligen Bereich.",
          "id": "93",
          "answerCategory": "missconception",
          "correctionOrComment": "Eine Klassenvariable ist eine für die ganze Klasse bestimmte Variable und die Instanzvariable ist für den jeweiligen Bereich gedacht.",
          "aspects": [
            {
              "text": "Eine Klassenvariable ist eine für die ganze Klasse bestimmte Variable",
              "elements": [
                [
                  0,
                  69
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "klassenvariablen sind in der klasse sichtbar und Instanzvariablen sind in dem Konstruktor in Parameterleiste",
          "id": "94",
          "answerCategory": "missconception",
          "correctionOrComment": "Klassenvariablen sind in der Klasse sichtbar und Instanzvariablen sind in dem Konstruktor in der Parameterliste.",
          "aspects": []
        },
        {
          "text": "-",
          "id": "95",
          "answerCategory": "none",
          "correctionOrComment": "-",
          "aspects": []
        },
        {
          "text": "öffentlich",
          "id": "96",
          "answerCategory": "none",
          "correctionOrComment": "öffentlich",
          "aspects": []
        },
        {
          "text": "Klassenvariable ist mit static und eine instanzvariable ist ohne static",
          "id": "97",
          "answerCategory": "concept_mix-up",
          "correctionOrComment": "Eine Klassenvariable wird mit 'static' definiert und eine instanzvariable ohne 'static'.",
          "aspects": []
        },
        {
          "text": "Klassenvariablen sind für die gesamte Klasse angelegt, Instatzvariablen für das Objekt das welches erzeugt wird",
          "id": "98",
          "answerCategory": "binary_correct",
          "correctionOrComment": "Klassenvariablen sind für die gesamte Klasse angelegt und Instanzvariablen nur für das Objekt, welches erzeugt wird.",
          "aspects": [
            {
              "text": "Klassenvariablen sind für die gesamte Klasse angelegt",
              "elements": [
                [
                  0,
                  53
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "Instanzvariablen nur für das Objekt",
              "elements": [
                [
                  58,
                  93
                ]
              ],
              "referenceAspects": [
                2
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "klassenvariablen sind innerhald einer klasse deklariert und in der ganzen klasse sichtbar und instanzvarialblen sind in einer methode deklariert und nur in dieser methode sichtbar",
          "id": "99",
          "answerCategory": "missconception",
          "correctionOrComment": "Klassenvariablen sind innerhalb einer Klasse deklariert und in der ganzen Klasse sichtbar. Instanzvarialblen sind in einer Methode deklariert und nur in dieser Methode sichtbar.",
          "aspects": [
            {
              "text": "Klassenvariablen sind innerhalb einer Klasse deklariert und in der ganzen Klasse sichtbar",
              "elements": [
                [
                  0,
                  89
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "-",
          "id": "100",
          "answerCategory": "none",
          "correctionOrComment": "-",
          "aspects": []
        },
        {
          "text": "Klassenvariable nur in der Klasse, Instanzvariablen in mehreren Klassen",
          "id": "101",
          "answerCategory": "missconception",
          "correctionOrComment": "Eine Klassenvariable gibt es nur in der Klasse und Instanzvariablen in mehreren Klassen.",
          "aspects": []
        },
        {
          "text": "-",
          "id": "102",
          "answerCategory": "none",
          "correctionOrComment": "-",
          "aspects": []
        },
        {
          "text": "klassenvariablen sind public und instanzvariablen private",
          "id": "103",
          "answerCategory": "missconception",
          "correctionOrComment": "Klassenvariablen sind 'public' und Instanzvariablen 'private'.",
          "aspects": []
        },
        {
          "text": "Klassenvariablen definieren eine Klasse , Instanzvariablen definieren eine Methode",
          "id": "104",
          "answerCategory": "missconception",
          "correctionOrComment": "Klassenvariablen definieren eine Klasse und Instanzvariablen definieren eine Methode.",
          "aspects": []
        },
        {
          "text": "Klassenvariablen werden nur innerhalb der Klasse ohne modifikatoren sichtbar und benutzbar. Instanzvariablen können in mehrere Klassen benutzt werden.",
          "id": "105",
          "answerCategory": "missconception",
          "correctionOrComment": "Klassenvariablen werden nur innerhalb der Klasse ohne Modifikatoren sichtbar und benutzbar. Instanzvariablen können in mehrere Klassen benutzt werden.",
          "aspects": []
        },
        {
          "text": "Instanzvariablen gehören zu den Objekt und statischen Variablen gehören zu der Klasse und nicht zu einzelne Objekt",
          "id": "106",
          "answerCategory": "correct",
          "correctionOrComment": "Instanzvariablen gehören zu den Objekten und statische Variablen gehören zu der Klasse und nicht zum einzelnen Objekt.",
          "aspects": [
            {
              "text": "Instanzvariablen gehören zu den Objekten ",
              "elements": [
                [
                  0,
                  40
                ]
              ],
              "referenceAspects": [
                2
              ],
              "label": 0
            },
            {
              "text": "statische Variablen gehören zu der Klasse und nicht zum einzelnen Objekt",
              "elements": [
                [
                  45,
                  117
                ]
              ],
              "referenceAspects": [
                0,
                1
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "this",
          "id": "107",
          "answerCategory": "none",
          "correctionOrComment": "this",
          "aspects": []
        },
        {
          "text": "instanz variable sind normale strings. klassen variablen haben ein public oder",
          "id": "108",
          "answerCategory": "missconception",
          "correctionOrComment": "Instanzvariablen sind normale 'Strings'. Klassenvariablen haben ein 'public'.",
          "aspects": []
        },
        {
          "text": "die Klassenvariablen sind für die ganze Klasse zugreifbar, instanzvariablen nur für die Objekten.",
          "id": "109",
          "answerCategory": "correct",
          "correctionOrComment": "Die Klassenvariablen sind für die ganze Klasse zugreifbar, Instanzvariablen nur für die Objekte.",
          "aspects": [
            {
              "text": "Die Klassenvariablen sind für die ganze Klasse zugreifbar",
              "elements": [
                [
                  0,
                  57
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "Instanzvariablen nur für die Objekte",
              "elements": [
                [
                  59,
                  95
                ]
              ],
              "referenceAspects": [
                2
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Klassenvariablen sind nur innerhalb der Klasse sichtbar, Instanzvariablen nicht",
          "id": "110",
          "answerCategory": "missconception",
          "correctionOrComment": "Klassenvariablen sind nur innerhalb der Klasse sichtbar, Instanzvariablen nicht.",
          "aspects": []
        },
        {
          "text": "Eine Java Klassen Variable beschreibt eine Variable, welche nur innerhalb einer Klasse gültig ist. DIe Instanzvariable gilt für ein Objekt einer Klasse.",
          "id": "111",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Eine Java Klassenvariable beschreibt eine Variable, welche nur innerhalb einer Klasse gültig ist. DIe Instanzvariable gilt für ein Objekt einer Klasse.",
          "aspects": [
            {
              "text": "DIe Instanzvariable gilt für ein Objekt einer Klasse",
              "elements": [
                [
                  98,
                  150
                ]
              ],
              "referenceAspects": [
                2
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Die Instanzvariable x wird innerhalb des Konstruktors durch den Parameter x verdeckt, daher erfolgt im ersten Konstruktor der Zugriff auf die Instanzvariable durch this.x",
          "id": "112",
          "answerCategory": "missconception",
          "correctionOrComment": "Die Instanzvariable 'x' wird innerhalb des Konstruktors durch den Parameter 'x' verdeckt. Daher erfolgt im ersten Konstruktor der Zugriff auf die Instanzvariable durch 'this.x'.",
          "aspects": []
        },
        {
          "text": "Bei Klassenvariablen ist die definition in einer Klasse mit der schlüsselwort static, aber bei Instanzvariablen ohne der schlüsselwort static",
          "id": "113",
          "answerCategory": "concept_mix-up",
          "correctionOrComment": "Bei Klassenvariablen erfolg die Definition in einer Klasse mit dem Schlüsselwort 'static', aber bei Instanzvariablen ohne das Schlüsselwort 'static'.",
          "aspects": []
        },
        {
          "text": "Klassenvariablen sind in der Klasse sichtbar, während Instanzvariablen Objekte der Klasse sind",
          "id": "114",
          "answerCategory": "missconception",
          "correctionOrComment": "Klassenvariablen sind in der Klasse sichtbar, während Instanzvariablen Objekte der Klasse sind.",
          "aspects": []
        },
        {
          "text": "Instanzen werden immer mit \"\"new Text ()\"\" definiert. Und Klassenvariablen werden mit \"\"Text ()\"\" aufgerufen",
          "id": "115",
          "answerCategory": "missconception",
          "correctionOrComment": "Instanzen werden immer mit 'new' definiert und Klassenvariablen werden mit 'Text ()' aufgerufen.",
          "aspects": []
        },
        {
          "text": "Klassenvariablen definieren eine Klasse und Instanzvariablen sind die in einer Klasse definiert",
          "id": "116",
          "answerCategory": "missconception",
          "correctionOrComment": "Klassenvariablen definieren eine Klasse und Instanzvariablen sind in einer Klasse definiert.",
          "aspects": []
        },
        {
          "text": "Intanzvariablen können für jedes Objekt unterschiedlich sein, Klassenvariablen sind für jedes Objekt gleich.",
          "id": "117",
          "answerCategory": "correct",
          "correctionOrComment": "Intanzvariablen können für jedes Objekt unterschiedlich sein, Klassenvariablen sind für jedes Objekt gleich.",
          "aspects": [
            {
              "text": "Klassenvariablen sind für jedes Objekt gleich",
              "elements": [
                [
                  62,
                  107
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "Intanzvariablen können für jedes Objekt unterschiedlich sein",
              "elements": [
                [
                  0,
                  60
                ]
              ],
              "referenceAspects": [
                2
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Klassenvariablen sind mit static und innerhalb der ganzen Klasse sichtbar. Instanzvariablen nur innerhalb der Methode.",
          "id": "118",
          "answerCategory": "missconception",
          "correctionOrComment": "Klassenvariablen sind mit 'static' und innerhalb der ganzen Klasse sichtbar, Instanzvariablen nur innerhalb der Methode.",
          "aspects": []
        },
        {
          "text": "Klassenvariablen sind nicht initialisert (Bauplan-Variablen). Instanzvariablen sind die Attribute eines Objekts. Klassenvariablen werden somit zu Instanzvariablen",
          "id": "119",
          "answerCategory": "missconception",
          "correctionOrComment": "Klassenvariablen sind nicht initialisert. Instanzvariablen sind die Attribute eines Objekts. Klassenvariablen werden somit zu Instanzvariablen",
          "aspects": []
        },
        {
          "text": "-",
          "id": "120",
          "answerCategory": "none",
          "correctionOrComment": "-",
          "aspects": []
        },
        {
          "text": "klassenvariablen sind public und instanzvariablen sind private",
          "id": "121",
          "answerCategory": "missconception",
          "correctionOrComment": "Klassenvariablen sind 'public' und Instanzvariablen sind 'private'.",
          "aspects": []
        },
        {
          "text": "Instanzvariablen sind auch in anderen Klassen sichtbar. Klassenvariablen nur in der eigenen Klasse.",
          "id": "122",
          "answerCategory": "missconception",
          "correctionOrComment": "Instanzvariablen sind auch in anderen Klassen sichtbar. Klassenvariablen nur in der eigenen Klasse.",
          "aspects": []
        },
        {
          "text": "Instanzvariablen sind bereits initialisiert. Instanzvariablen gehören zu einem spObjekt. Bei Klassenvariablen muss dies nich der Fall sein.",
          "id": "123",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Instanzvariablen sind bereits initialisiert. Instanzvariablen gehören zu einem Objekt. Bei Klassenvariablen muss dies nicht der Fall sein.",
          "aspects": [
            {
              "text": "Instanzvariablen gehören zu einem Objekt",
              "elements": [
                [
                  45,
                  85
                ]
              ],
              "referenceAspects": [
                2
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Die beiden unterscheiden sich durch \"\"this\"\". Insatanzvariablen werden durch \"\"this\"\" definiert.",
          "id": "124",
          "answerCategory": "missconception",
          "correctionOrComment": "Die beiden unterscheiden sich durch 'this'. Insatanzvariablen werden durch 'this' definiert.",
          "aspects": []
        },
        {
          "text": "Klassenvariablen nur in der eigenen Klasse genutzt, Instanzvariable in mehrern Klassen.",
          "id": "125",
          "answerCategory": "missconception",
          "correctionOrComment": "Klassenvariablen werden nur in der eigenen Klasse genutzt, Instanzvariablen in mehreren Klassen.",
          "aspects": []
        },
        {
          "text": "Instanzvariablen werden den Objekten übergeben und gehören den Objekten. Die Klassenvariablen gehören der ganzen Klasse",
          "id": "126",
          "answerCategory": "correct",
          "correctionOrComment": "Instanzvariablen werden den Objekten übergeben und gehören den Objekten. Die Klassenvariablen gehören der ganzen Klasse.",
          "aspects": [
            {
              "text": "Die Klassenvariablen gehören der ganzen Klasse",
              "elements": [
                [
                  73,
                  119
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "Instanzvariablen werden den Objekten übergeben und gehören den Objekten",
              "elements": [
                [
                  0,
                  71
                ]
              ],
              "referenceAspects": [
                2
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Jedes object hat seine eigene Instanzvariable unabhängig von anderen Objekten die von der selben klasse codiert wurden. klassenvariablen sind an die eigenen Klassen gebunden, die Objekte sehen die selben klassenvariablen",
          "id": "127",
          "answerCategory": "correct",
          "correctionOrComment": "Jedes Objekt hat seine eigene Instanzvariable unabhängig von anderen Objekten, die von derselben Klasse codiert wurden. Klassenvariablen sind an die eigenen Klassen gebunden. Die Objekte sehen die selben Klassenvariablen.",
          "aspects": [
            {
              "text": "Jedes Objekt hat seine eigene Instanzvariable unabhängig von anderen Objekten",
              "elements": [
                [
                  0,
                  77
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "Klassenvariablen sind an die eigenen Klassen gebunden",
              "elements": [
                [
                  120,
                  173
                ]
              ],
              "referenceAspects": [
                1
              ],
              "label": 0
            },
            {
              "text": "Die Objekte sehen die selben Klassenvariablen",
              "elements": [
                [
                  175,
                  220
                ]
              ],
              "referenceAspects": [
                2
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Instanzvariablen sind in einer Klasse definiert und man kann durch get und set zugreifen",
          "id": "128",
          "answerCategory": "missconception",
          "correctionOrComment": "Instanzvariablen sind in einer Klasse definiert und man kann durch 'get' und 'set' auf sie zugreifen.",
          "aspects": []
        },
        {
          "text": "Klassenvariablen sind in der Klasse überalle sichtbar. Instanzvariablen sind für die gegebene Instanz aufgerufen und danach werden sie von der garbage collection eingesammelt",
          "id": "129",
          "answerCategory": "missconception",
          "correctionOrComment": "Klassenvariablen sind in der Klasse überall sichtbar. Instanzvariablen sind für die gegebene Instanz aufgerufen und danach werden sie von dem 'garbage collector' eingesammelt.",
          "aspects": []
        },
        {
          "text": "-",
          "id": "130",
          "answerCategory": "none",
          "correctionOrComment": "-",
          "aspects": []
        },
        {
          "text": "-",
          "id": "131",
          "answerCategory": "none",
          "correctionOrComment": "-",
          "aspects": []
        },
        {
          "text": "Instanzvariablen können nur von einzelnen Methoden genutzt werden. Klassenvaroiablen von der ganzen Klasse.",
          "id": "132",
          "answerCategory": "missconception",
          "correctionOrComment": "Instanzvariablen können nur von einzelnen Methoden genutzt werden, Klassenvariablen von der ganzen Klasse.",
          "aspects": []
        },
        {
          "text": "instanzvariablengehören zu den objekten werden objekten übergeben",
          "id": "133",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Instanzvariablen gehören zu den Objekten. Sie werden Objekten übergeben.",
          "aspects": [
            {
              "text": "Instanzvariablen gehören zu den Objekten",
              "elements": [
                [
                  0,
                  40
                ]
              ],
              "referenceAspects": [
                2
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Klassenvariablen sind in der Klasse sichtbar und Instanzvariablen sind",
          "id": "134",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Klassenvariablen sind in der Klasse sichtbar.",
          "aspects": []
        },
        {
          "text": "Insstanzvariblen sind bereits initialisiert.",
          "id": "135",
          "answerCategory": "missconception",
          "correctionOrComment": "Instanzvariablen sind bereits initialisiert.",
          "aspects": []
        },
        {
          "text": "Instanzvariable gehören zu den Objekt und statischen variable Klassen variable",
          "id": "136",
          "answerCategory": "partially_correct",
          "correctionOrComment": "Instanzvariablen gehören zu dem Objekt und statische Variablen sind Klassenvariablen.",
          "aspects": [
            {
              "text": "Instanzvariablen gehören zu dem Objekt",
              "elements": [
                [
                  0,
                  38
                ]
              ],
              "referenceAspects": [
                2
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Instanzvariablen gehören zu den Objekten werden den Objekten übergeben. Klassenvariablen hingegen nicht sie gehrlen einer klase",
          "id": "137",
          "answerCategory": "binary_correct",
          "correctionOrComment": "Instanzvariablen gehören zu den Objekten und werden den Objekten übergeben. Klassenvariablen hingegen nicht, sie gehören einer Klasse.",
          "aspects": [
            {
              "text": "Klassenvariablen ;; gehören einer Klasse",
              "elements": [
                [
                  76,
                  92
                ],
                [
                  113,
                  133
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "Instanzvariablen gehören zu den Objekten und werden den Objekten übergeben",
              "elements": [
                [
                  0,
                  74
                ]
              ],
              "referenceAspects": [
                2
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Klasse definiert in einem Block und Instanzvariable wird in der Klasse definiert",
          "id": "138",
          "answerCategory": "missconception",
          "correctionOrComment": "Eine Klasse definiert in einem Block und eine Instanzvariable wird in der Klasse definiert.",
          "aspects": []
        },
        {
          "text": "Klassenvariablen sind nur in der Klasse sichtbar, Instanzvariablen in mehreren Klassen",
          "id": "139",
          "answerCategory": "missconception",
          "correctionOrComment": "Klassenvariablen sind nur in der Klasse sichtbar, Instanzvariablen in mehreren Klassen.",
          "aspects": []
        },
        {
          "text": "Klassenvariablen werden in der Main Methode deklariert. Instanzvariablen in Konstruktoren.",
          "id": "140",
          "answerCategory": "missconception",
          "correctionOrComment": "Klassenvariablen werden in der 'main' Methode deklariert, Instanzvariablen in Konstruktoren.",
          "aspects": []
        },
        {
          "text": "Klassenvariablen sind in einer Klasse deklarierte und gegebenfalls initialisierte Variablen, dagegen sind Instanzvariablen in einem Objekt deklarierte und ggf Varibalen",
          "id": "141",
          "answerCategory": "binary_correct",
          "correctionOrComment": "Klassenvariablen sind in einer Klasse deklarierte und gegebenfalls initialisierte Variablen. Dagegen sind Instanzvariablen in einem Objekt deklarierte und gegebenenfalls Variablen.",
          "aspects": [
            {
              "text": "Klassenvariablen sind in einer Klasse deklarierte",
              "elements": [
                [
                  0,
                  49
                ]
              ],
              "referenceAspects": [
                0
              ],
              "label": 0
            },
            {
              "text": "Dagegen sind Instanzvariablen in einem Objekt deklarierte",
              "elements": [
                [
                  93,
                  150
                ]
              ],
              "referenceAspects": [
                2
              ],
              "label": 0
            }
          ]
        },
        {
          "text": "Instanzvariablen sind Objekte sozusagen und Klassenvariiable sind Variable die in defr klasse sichtbar sind",
          "id": "142",
          "answerCategory": "missconception",
          "correctionOrComment": "Instanzvariablen sind sozusagen Objekte und Klassenvariablen sind Variablen die in der Klasse sichtbar sind.",
          "aspects": []
        },
        {
          "text": "instanzsvariablen sind zb einfach public String, public int, und klassenvariablen computer (int variable){",
          "id": "143",
          "answerCategory": "missconception",
          "correctionOrComment": "Instanzsvariablen sind zum Beispiel einfach 'public String' oder 'public int', und Klassenvariablen Parameter.",
          "aspects": []
        },
        {
          "text": "this",
          "id": "144",
          "answerCategory": "none",
          "correctionOrComment": "this"
        }
      ]
    }
  ]
}
