{
  "questions": [
    {
      "text": "Was ist der konzeptuelle Unterschied zwischen dem Wert einer String Variablen und dem eines primitiven Datentyps?",
      "id": 50717,
      "title": "Wert von Objecten vs primitiven Datentypen",
      "type": "comparison",
      "aspects": [
        {
          "text": "Die Variable eines primitiven Datentyps speichert den Inhalt an sich"
        },
        {
          "text": "Die Variable eines Strings hat als Wert eine Referenz auf den eigentlichen Inhalt im Speicher"
        }
      ],
      "referenceAnswers": [
        {
          "text": "Die Variable eines primitiven Datentyps speichert den Inhalt an sich. Die Variable eines Strings hat als Wert eine Referenz auf den eigentlichen Inhalt im Speicher.",
          "aspects": [
            {
              "text": "Die Variable eines primitiven Datentyps speichert den Inhalt an sich",
              "aIdx": 0,
              "elements": [
                [
                  0,
                  68
                ]
              ]
            },
            {
              "text": "Die Variable eines Strings hat als Wert eine Referenz auf den eigentlichen Inhalt im Speicher",
              "aIdx": 1,
              "elements": [
                [
                  70,
                  163
                ]
              ]
            }
          ]
        }
      ],
      "studentAnswers": [
        {
          "text": "stringvariablen sind zeichenketten, primitive datentypen sind zifernketten",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Stringvariablen sind Zeichenketten, primitive Datentypen sind Ziffernketten",
          "answerCategory": "missconception",
          "aspects": []
        },
        {
          "text": "primitive Datendypen benötigen mmer gleich viel Speicherplatz. Bei Strings hängt das von der Länge ab, Daher wird ihr Speicher dynamisch reserviert.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Primitive Datentypen benötigen immer gleich viel Speicherplatz. Bei Strings hängt das von der Länge ab, Daher wird ihr Speicher dynamisch reserviert.",
          "answerCategory": "correct",
          "aspects": []
        },
        {
          "text": "Der Wert eines Strings stellt lediglich eine Referenz dar.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Der Wert eines Strings stellt lediglich eine Referenz dar.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Der Wert eines Strings stellt lediglich eine Referenz dar",
              "elements": [
                [
                  0,
                  57
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "k",
          "id": "8a217ea5f39d0f20db42ef9bcb667eacd060a40b50a18655172ec4b8",
          "correctionOrComment": "k",
          "answerCategory": "none",
          "aspects": []
        },
        {
          "text": "Wert eines Strings ist seine Referenz, prim datentyp ist eine Binärzahl",
          "id": "c1b8144ee1a30244a571c3d9b48b2c394a7489065d2565968f521645",
          "correctionOrComment": "Der Wert eines Strings ist seine Referenz, beim primären Datentyp ist es eine Binärzahl",
          "answerCategory": "binary_correct",
          "aspects": [
            {
              "text": "beim primären Datentyp ist es eine Binärzahl",
              "elements": [],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Der Wert eines Strings ist seine Referenz",
              "elements": [],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Auf Objekten können Operationen ausgeführt werden. Auf primitiven Datentypen nicht.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Auf Objekten können Operationen ausgeführt werden. Auf primitiven Datentypen nicht.",
          "answerCategory": "missconception",
          "aspects": []
        },
        {
          "text": "Bei einfachen Datentypen wird direkt der Wert in einer Variable gespeichert, bei Objektvariablen wie Strings wird nur eine Referenz auf den eigentlichen String gespeichert.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Bei einfachen Datentypen wird direkt der Wert in einer Variable gespeichert. Bei Objektvariablen wie Strings wird nur eine Referenz auf den eigentlichen String gespeichert.",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": "Bei einfachen Datentypen wird direkt der Wert in einer Variable gespeichert",
              "elements": [
                [
                  0,
                  75
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Bei Objektvariablen wie Strings wird nur eine Referenz auf den eigentlichen String gespeichert",
              "elements": [],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "primitiver Daten typ = call by value String = call by reference",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "primitiver Daten typ = call by value String = call by reference",
          "answerCategory": "missconception",
          "aspects": []
        },
        {
          "text": "Strings werden durch Referenzen gespeichert.",
          "id": "ea674ab55536a8b603be44d13510e32c7aab02088bf48c2802e4febd",
          "correctionOrComment": "Strings werden durch Referenzen gespeichert.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Strings werden durch Referenzen gespeichert",
              "elements": [
                [
                  0,
                  43
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Werden Strings verwendet, so werden nicht die Daten an sich aufgerufen, sondern deren Referenz. Bei primitiven Datentypen verwendet man die Daten an sich.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Werden Strings verwendet, so werden nicht die Daten an sich aufgerufen, sondern deren Referenz. Bei primitiven Datentypen verwendet man die Daten an sich.",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": "Bei primitiven Datentypen verwendet man die Daten an sich",
              "elements": [
                [
                  96,
                  153
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Werden Strings verwendet, so werden nicht die Daten an sich aufgerufen, sondern deren Referenz",
              "elements": [
                [
                  0,
                  94
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "primitive Datentypen haben eine feste Größe und können deshalb direkt gespeichert werden. String variablen hingegen haben keine festgelegte Größe weshalb unklar ist wie viel Speicher man braucht. Deshalb wird in diesem Fall mit einem extra Speicherplatz gearbeitet, welcher mit einem Identifier versehen wird. In der variable selbst wird die Referenz zu diesem Speicherplatz gespeichert.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Primitive Datentypen haben eine feste Größe und können deshalb direkt gespeichert werden. String variablen hingegen haben keine festgelegte Größe weshalb unklar ist wie viel Speicher man braucht. Deshalb wird in diesem Fall mit einem extra Speicherplatz gearbeitet, welcher mit einem Identifier versehen wird. In der Variable selbst wird die Referenz zu diesem Speicherplatz gespeichert.",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": "Primitive Datentypen haben eine feste Größe und können deshalb direkt gespeichert werden",
              "elements": [],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "In der Variable selbst wird die Referenz zu diesem Speicherplatz gespeichert",
              "elements": [],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Eine String Variable enthält stets nur eine Referenz auf die Speicher, in der sich eine Zeichenkette befindet. Primitive Datentypen wie Integer enthalten deren Wert.",
          "id": "408f0afbe2440a4383a1e75b7d5b0b4202c7f7131a9acf9bd70492f3",
          "correctionOrComment": "Eine String Variable enthält stets nur eine Referenz auf die Adresse im Speicher, in der sich eine Zeichenkette befindet. Primitive Datentypen wie Integer enthalten deren Wert.",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": "Primitive Datentypen wie Integer enthalten deren Wert",
              "elements": [
                [
                  111,
                  164
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Eine String Variable enthält stets nur eine Referenz auf die Adresse im Speicher, in der sich eine Zeichenkette befindet",
              "elements": [],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Ein String stellt immer eine Zeichenkette dar.",
          "id": "0ce8152aa92136af039b687c01c7dccfcb271f3db2d0ddcb3cfdd3e6",
          "correctionOrComment": "Ein String stellt immer eine Zeichenkette dar.",
          "answerCategory": "irrelevant",
          "aspects": []
        },
        {
          "text": "Speicherplatzgröße Referenz",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "",
          "answerCategory": "partially_correct",
          "aspects": []
        },
        {
          "text": "Der String wird als Objekt angelegt, bei primitiven Datentypen ist dies nicht der Fall.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "correctionOrComment": "Der String wird als Objekt angelegt, bei primitiven Datentypen ist dies nicht der Fall.",
          "answerCategory": "partially_correct",
          "aspects": []
        },
        {
          "text": "Der Wert des Strings ist die Zuordnung im Speicher, nicht der Inhalt der Variable selbst.",
          "id": "58b2aaa0bfae7acc021b3260e941117b529b2e69de878fd7d45c61a9",
          "correctionOrComment": "Der Wert des Strings ist die Zuordnung im Speicher, nicht der Inhalt der Variable selbst.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Der Wert des Strings ist die Zuordnung im Speicher, nicht der Inhalt der Variable selbst",
              "elements": [
                [
                  0,
                  88
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Strings werden mit Referenzen aufgerufen und primitive Datentypen mit ihrem Wert",
          "id": "6332531eeafc6e0ede272192be898f549950fb32b209d04f0a98306a",
          "correctionOrComment": "Strings werden mit Referenzen aufgerufen und primitive Datentypen mit ihrem Wert",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": " primitive Datentypen mit ihrem Wert",
              "elements": [
                [
                  45,
                  80
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Strings werden mit Referenzen aufgerufen",
              "elements": [
                [
                  0,
                  40
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "der Unterschied ist dass bei einem String mit Ketten von Zeichen oder Ziffern gearbeitet wird während bei primitiven Datentypen mit einzelnen Zahlen, Ziffern oder Zeichen gearbeitet wird",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Der Unterschied ist, dass bei einem String mit Ketten von Zeichen oder Ziffern gearbeitet wird während bei primitiven Datentypen mit einzelnen Zahlen, Ziffern oder Zeichen gearbeitet wird",
          "answerCategory": "partially_correct",
          "aspects": []
        },
        {
          "text": "Bei einem primitiven Datentypen wird bei der Initialisierung ein fester Speicherbereich dafür angelegt. Bei Strings funktioniert das nicht, da diese keine festgelegte Länge haben. Daher werden Strings mit Referenzen gespeichert. Es wird ein fester Speicherbereich angelegt, der lediglich die Referenz auf ein Stringobjekt speichert, welches allerdings woanders im Speicher liegt.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Bei einem primitiven Datentypen wird bei der Initialisierung ein fester Speicherbereich dafür angelegt. Bei Strings funktioniert das nicht, da diese keine festgelegte Länge haben. Daher werden Strings mit Referenzen gespeichert. Es wird ein fester Speicherbereich angelegt, der lediglich die Referenz auf ein Stringobjekt speichert, welches allerdings woanders im Speicher liegt.",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": "Daher werden Strings mit Referenzen gespeichert",
              "elements": [
                [
                  180,
                  227
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "-",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "-",
          "answerCategory": "none",
          "aspects": []
        },
        {
          "text": "Stings sind Arrays, also Listen von Chars",
          "id": "271f93f45e9b4067327ed5c8cd30a034730aaace4382803c3e1d6c2f",
          "correctionOrComment": "Stings sind Arrays, also Listen von Chars",
          "answerCategory": "irrelevant",
          "aspects": []
        },
        {
          "text": "Die String Variable speichert eine Referenz auf ein Objekt. Ein primitiver Datentyp wird nicht durch eine Referenz, sonder direkt gespeichert.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Die String Variable speichert eine Referenz auf ein Objekt. Ein primitiver Datentyp wird nicht durch eine Referenz, sonder direkt gespeichert.",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": "Die String Variable speichert eine Referenz auf ein Objekt",
              "elements": [
                [
                  0,
                  58
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "Ein primitiver Datentyp wird ;; direkt gespeichert",
              "elements": [
                [
                  60,
                  88
                ],
                [
                  123,
                  141
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "Strings sind, im Gegensatz zu primitiven Datentypen, Objekte. Das heißt, sie speichern einen Wert bzw. Zeichenkette nicht direkt, sondern verweisen auf den Speicherplatz.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6",
          "correctionOrComment": "Strings sind, im Gegensatz zu primitiven Datentypen, Objekte. Das heißt, sie speichern einen Wert bzw. Zeichenkette nicht direkt, sondern verweisen auf den Speicherplatz.",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": "sie speichern einen Wert bzw. Zeichenkette nicht direkt, sondern verweisen auf den Speicherplatz",
              "elements": [
                [
                  73,
                  169
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Eine String Variable ist ein Objekt und speichert nicht die Daten selber sondern die Referenz auf die Daten.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Eine String Variable ist ein Objekt und speichert nicht die Daten selber sondern die Referenz auf die Daten.",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": "Eine String Variable ist ein Objekt und speichert nicht die Daten selber sondern die Referenz auf die Daten",
              "elements": [
                [
                  0,
                  107
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Ein String ist eine eigene Klasse mit Attributen und Methoden und nutzt zum speichern der Informationen selbst primitive datatypes. Ein primitive datatype hat keine Methoden, sondern stellt selbst direkt seinen Wert dar. Zudem ist in Java ein Array kein primitive datatype, da diese in eine wrapper-class mit dessen Länge eingebettet ist - anders als in C++, wo bei einem Array nur die primitive datatypes hintereinander im Speicher abgelegt werden.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6",
          "correctionOrComment": "Ein String ist eine eigene Klasse mit Attributen und Methoden und nutzt zum speichern der Informationen selbst primitive datatypes. Ein primitiver Datatype hat keine Methoden, sondern stellt selbst direkt seinen Wert dar. Zudem ist in Java ein Array kein primitive datatype, da diese in eine wrapper-class mit dessen Länge eingebettet ist - anders als in C++, wo bei einem Array nur die primitive datatypes hintereinander im Speicher abgelegt werden.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Ein primitiver Datatype ;; stellt selbst direkt seinen Wert dar",
              "elements": [
                [
                  183,
                  219
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "ein String wird als Objekt im Speicher gespeichert, es wird nur mit einer referenz auf ihn verwiesen nicht mit dem Inhalt selbst gerechnet",
          "id": "53750c72b7bb26cb6ff7115e383ca150d5a632a909a7f79e2f5274a4",
          "correctionOrComment": "Ein String wird als Objekt im Speicher gespeichert, es wird nur mit einer referenz auf ihn verwiesen nicht mit dem Inhalt selbst gerechnet",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Ein String wird als Objekt im Speicher gespeichert, es wird nur mit einer referenz auf ihn verwiesen",
              "elements": [],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Ein String ist eine Verkettung verschiedener Zeichen, ein primitiver Datentyp hat nur einen Wert",
          "id": "8416c38cc898f1ac7cc9d64e89dab1f70f5ddab002a5b2a1713f93f5",
          "correctionOrComment": "Ein String ist eine Verkettung verschiedener Zeichen, ein primitiver Datentyp hat nur einen Wert",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "ein primitiver Datentyp hat nur einen Wert",
              "elements": [
                [
                  54,
                  96
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "jijijij",
          "id": "192f56eb9bd894a72b30c303247b107be2c4591f310dd69a67927f48",
          "correctionOrComment": "jijijij",
          "answerCategory": "none",
          "aspects": []
        },
        {
          "text": "Strings sind Objekte mit bestimmten Attributen und Operationen.",
          "id": "7ba019a2553e1137a4bbb8d3c779a48e5ceb2ca3a162e6e0a945ef0f",
          "correctionOrComment": "Strings sind Objekte mit bestimmten Attributen und Operationen.",
          "answerCategory": "irrelevant",
          "aspects": []
        },
        {
          "text": "Strings sind objektorientiert.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "correctionOrComment": "Strings sind objektorientiert.",
          "answerCategory": "irrelevant",
          "aspects": []
        },
        {
          "text": "Der Wert einer String variable wird in einem seperaten Speicherplatz verwaltet und der String selbst speichert nur die Referenz auf diesen Speicherplatz",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Der Wert einer String Variable wird in einem seperaten Speicherplatz verwaltet und der String selbst speichert nur die Referenz auf diesen Speicherplatz",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Der Wert einer String Variable wird in einem seperaten Speicherplatz verwaltet und der String selbst speichert nur die Referenz auf diesen Speicherplatz",
              "elements": [],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Der String speichert nur die Referenz auf den Wert, in einem primitiven Datentypen ist der Wert direkt gespeichert.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "correctionOrComment": "Der String speichert nur die Referenz auf den Wert, in einem primitiven Datentypen ist der Wert direkt gespeichert.",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": "in einem primitiven Datentypen ist der Wert direkt gespeichert",
              "elements": [
                [
                  52,
                  114
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Der String speichert nur die Referenz auf den Wert",
              "elements": [
                [
                  0,
                  50
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Bei primitiven Datentypen wird der Wert direkt in dem Datentypen gespeichert. Springs werden in Referenzen gespeichert, die auf den String verweisen.",
          "id": "b51d18b551043c1f145f22dbde6f8531faeaf68c54ed9dd79ce24d17",
          "correctionOrComment": "Bei primitiven Datentypen wird der Wert direkt in dem Datentypen gespeichert. Strings werden in Referenzen gespeichert, die auf den String verweisen.",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": "Bei primitiven Datentypen wird der Wert direkt in dem Datentypen gespeichert",
              "elements": [
                [
                  0,
                  76
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": " Strings werden in Referenzen gespeichert, die auf den String verweisen",
              "elements": [],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Eine String Variable verweist nur auf auf ein Objekt.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Eine String Variable verweist nur auf auf ein Objekt.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Eine String Variable verweist nur auf auf ein Objekt",
              "elements": [
                [
                  0,
                  52
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Werte von Strings werden als Referenzen gespeichert (call-by-reference), Werte von Datentypen als einzelne Werte (call-by-value).",
          "id": "f09265efb456b0336079ad5b238daa1e38a11b1d71cc0e1a4e8edd56",
          "correctionOrComment": "Werte von Strings werden als Referenzen gespeichert (call-by-reference), Werte von Datentypen als einzelne Werte (call-by-value).",
          "answerCategory": "binary_correct",
          "aspects": [
            {
              "text": "Werte von Datentypen als einzelne Werte",
              "elements": [
                [
                  73,
                  112
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Werte von Strings werden als Referenzen gespeichert ",
              "elements": [
                [
                  0,
                  51
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Die String variable ist eine Referenz auf einen im Speicher stehenden Wertes.",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c",
          "correctionOrComment": "Die String Variable ist eine Referenz auf einen im Speicher stehenden Wert.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Die String Variable ist eine Referenz auf einen im Speicher stehenden Wert",
              "elements": [],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "x",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "x",
          "answerCategory": "none",
          "aspects": []
        },
        {
          "text": "Die String Variable speichert eine Referenz auf den Wert, primitive Datentypen speichern den Wert an sich.",
          "id": "b8607e0369fbf3e33bc0e358f840915d8c085d1496097351913c0122",
          "correctionOrComment": "Die String Variable speichert eine Referenz auf den Wert, primitive Datentypen speichern den Wert an sich.",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": "primitive Datentypen speichern den Wert an sich",
              "elements": [
                [
                  58,
                  105
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Die String Variable speichert eine Referenz auf den Wert",
              "elements": [
                [
                  0,
                  56
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Wert zeigt auf die Referenz",
          "id": "ae8820303e493738a211ebb2ae3a2f90b286f20f767609beb77522c0",
          "correctionOrComment": "Der Wert zeigt auf die Referenz",
          "answerCategory": "irrelevant",
          "aspects": [
            {
              "text": "Der Wert zeigt auf die Referenz",
              "elements": [],
              "aIdx": 1,
              "label": 2
            }
          ]
        },
        {
          "text": "Primitive Datentypen speichern den Wert selbst, Strings sind Objekte und enthalten eine Referenz auf das eigentliche Objekt",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Primitive Datentypen speichern den Wert selbst, Strings sind Objekte und enthalten eine Referenz auf das eigentliche Objekt",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": "Primitive Datentypen speichern den Wert selbst",
              "elements": [
                [
                  0,
                  46
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Strings sind Objekte und enthalten eine Referenz auf das eigentliche Objekt",
              "elements": [
                [
                  48,
                  123
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Strings speichern Referenz zu Objekt",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Strings speichern die Referenz zum Objekt",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Strings speichern die Referenz zum Objekt",
              "elements": [],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Bei primitven Datentypen werden die Werte direkt in dem reservierten Speicherplatz gespeichert, beim String wird eine Referenz auf einen Speicherplatz gespeichert, in dem dann wirklich die Daten stehen.",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c",
          "correctionOrComment": "Bei primitven Datentypen werden die Werte direkt in dem reservierten Speicherplatz gespeichert, beim String wird eine Referenz auf einen Speicherplatz gespeichert, in dem dann wirklich die Daten stehen.",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": "Bei primitven Datentypen werden die Werte direkt in dem reservierten Speicherplatz gespeichert",
              "elements": [
                [
                  0,
                  94
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "beim String wird eine Referenz auf einen Speicherplatz gespeichert, in dem dann wirklich die Daten stehen",
              "elements": [
                [
                  96,
                  201
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Speicherplatz",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Speicherplatz",
          "answerCategory": "irrelevant",
          "aspects": []
        }
      ]
    },
    {
      "text": "Was passiert bei der Anweisung new String()?",
      "id": 50721,
      "title": "Keyword 'new'",
      "type": "procedure",
      "aspects": [
        {
          "text": "Das Keyword 'new' erzeugt einen leeren String im Speicher"
        },
        {
          "text": "Eine Referenz auf den erzeugten Sting wird zurückgegeben"
        }
      ],
      "referenceAnswers": [
        {
          "text": "Das Keyword 'new' erzeugt einen leeren String im Speicher und gibt anschließend die Referenz auf diesen String zurück.",
          "aspects": [
            {
              "text": "Das Keyword 'new' erzeugt einen leeren String im Speicher",
              "aIdx": 0,
              "elements": [
                [
                  0,
                  57
                ]
              ]
            },
            {
              "text": "und gibt anschließend die Referenz auf diesen String zurück",
              "aIdx": 1,
              "elements": [
                [
                  58,
                  117
                ]
              ]
            }
          ]
        }
      ],
      "studentAnswers": [
        {
          "text": "Es wird eine neue Referenz erstellt",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Es wird eine neue Referenz erstellt",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Es wird eine neue Referenz erstellt",
              "elements": [
                [
                  0,
                  35
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Mit der Anweisung new String() wird ein neuer Speicherort für einen neuen String angelegt.",
          "id": "8bbd52208353c14f154f1402cebf5829afb1708d06b5dc25064dff23",
          "correctionOrComment": "Mit der Anweisung new String() wird ein neuer Speicherort für einen neuen String angelegt.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Mit der Anweisung new String() wird ein neuer Speicherort für einen neuen String angelegt.",
              "elements": [
                [
                  0,
                  90
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "Ein String wird neu in einer Referenz gespeichert.",
          "id": "4cfc3a1811fe40afa401b25ef7fa0379f1f7c1930a04f8755d678474",
          "correctionOrComment": "Ein String wird neu in einer Referenz gespeichert.",
          "answerCategory": "binary_correct",
          "aspects": [
            {
              "text": "Ein String wird neu in einer Referenz gespeichert",
              "elements": [
                [
                  0,
                  49
                ]
              ],
              "aIdx": 0,
              "label": 2
            }
          ]
        },
        {
          "text": "Es wird ein neuer String (Objekt) mit dem übergebenen Inhalt erzeugt.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Es wird ein neuer String (Objekt) mit dem übergebenen Inhalt erzeugt.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Es wird ein neuer String (Objekt) mit dem übergebenen Inhalt erzeugt",
              "elements": [
                [
                  0,
                  68
                ]
              ],
              "aIdx": 0,
              "label": 1
            }
          ]
        },
        {
          "text": "bei new String() wird ein neuer String erstellt, versehen mit der referenz und einer 0",
          "id": "8a217ea5f39d0f20db42ef9bcb667eacd060a40b50a18655172ec4b8",
          "correctionOrComment": "Bei new String() wird ein neuer String erstellt, versehen mit der referenz und einer 0",
          "answerCategory": "missconception",
          "aspects": [
            {
              "text": "Bei new String() wird ein neuer String erstellt, versehen mit der referenz und einer 0",
              "elements": [],
              "aIdx": 0,
              "label": 2
            }
          ]
        },
        {
          "text": "Es wird ein inhaltsloser String erstellt, also nur eine Referenz für den String. Der Inhalt ist dann null.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Es wird ein inhaltsloser String erstellt, also nur eine Referenz für den String. Der Inhalt ist dann null.",
          "answerCategory": "missconception",
          "aspects": [
            {
              "text": "Der Inhalt ist dann null",
              "elements": [
                [
                  81,
                  105
                ]
              ],
              "aIdx": 0,
              "label": 2
            },
            {
              "text": "Es wird ein inhaltsloser String erstellt, also nur eine Referenz für den String",
              "elements": [
                [
                  0,
                  79
                ]
              ],
              "aIdx": 1,
              "label": 1
            }
          ]
        },
        {
          "text": "Es wird ein neues Objekt erzeugt.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Es wird ein neues Objekt erzeugt.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Es wird ein neues Objekt erzeugt",
              "elements": [
                [
                  0,
                  32
                ]
              ],
              "aIdx": 0,
              "label": 1
            }
          ]
        },
        {
          "text": "Ein neues Objekt der Klasse String wird angelegt.",
          "id": "1e2c3eb4744dbc36de4e827f187dd2a073d91b8790a2ff117694dd7b",
          "correctionOrComment": "Ein neues Objekt der Klasse String wird angelegt.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Ein neues Objekt der Klasse String wird angelegt",
              "elements": [
                [
                  0,
                  48
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "ein neues objekt vom typ string wird instanziert",
          "id": "c1b8144ee1a30244a571c3d9b48b2c394a7489065d2565968f521645",
          "correctionOrComment": "Ein neues Objekt vom Typ String wird instanziert",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Ein neues Objekt vom Typ String wird instanziert",
              "elements": [],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "Es wird ein neues Objekt des Typs String erstellt.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Es wird ein neues Objekt des Typs String erstellt.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Es wird ein neues Objekt des Typs String erstellt",
              "elements": [
                [
                  0,
                  49
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "Eine neue Referenz für einen String wird erstellt und in dieser kann dann ein String zugewiesen werden.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Eine neue Referenz für einen String wird erstellt und dieser kann dann ein String zugewiesen werden.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "dieser kann dann ein String zugewiesen werden",
              "elements": [
                [
                  57,
                  102
                ]
              ],
              "aIdx": 0,
              "label": 2
            },
            {
              "text": "Eine neue Referenz für einen String wird erstellt",
              "elements": [
                [
                  0,
                  49
                ]
              ],
              "aIdx": 1,
              "label": 1
            }
          ]
        },
        {
          "text": "ein neuer leerer String wird erstellt und seine Referenz wird zurück gegeben",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Ein neuer leerer String wird erstellt und seine Referenz wird zurück gegeben",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": "Ein neuer leerer String wird erstellt",
              "elements": [],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "seine Referenz wird zurück gegeben",
              "elements": [
                [
                  42,
                  76
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Es wird eine Referenz angelegt, die momentan auf nichts zeigt. Also null ist.",
          "id": "ea674ab55536a8b603be44d13510e32c7aab02088bf48c2802e4febd",
          "correctionOrComment": "Es wird eine Referenz angelegt, die momentan auf nichts zeigt. Also null ist.",
          "answerCategory": "missconception",
          "aspects": [
            {
              "text": "die momentan auf nichts zeigt. Also null ist",
              "elements": [
                [
                  32,
                  76
                ]
              ],
              "aIdx": 0,
              "label": 2
            },
            {
              "text": "Es wird eine Referenz angelegt",
              "elements": [
                [
                  0,
                  30
                ]
              ],
              "aIdx": 1,
              "label": 1
            }
          ]
        },
        {
          "text": "Es wird ein neues Objekt der Klasse String erstellt. Dieses ist leer.",
          "id": "7ba019a2553e1137a4bbb8d3c779a48e5ceb2ca3a162e6e0a945ef0f",
          "correctionOrComment": "Es wird ein neues Objekt der Klasse String erstellt. Dieses ist leer.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Es wird ein neues Objekt der Klasse String erstellt. Dieses ist leer",
              "elements": [
                [
                  0,
                  68
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "Eine neue Variable für einen String wird angelegt. Sie enthält zunächst die Referenz NUL",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Eine neue Variable für einen String wird angelegt. Sie enthält zunächst die Referenz null",
          "answerCategory": "missconception",
          "aspects": [
            {
              "text": "Sie enthält zunächst die Referenz null",
              "elements": [],
              "aIdx": 1,
              "label": 2
            }
          ]
        },
        {
          "text": "Es wird ein neuer String angelegt",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Es wird ein neuer String angelegt",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Es wird ein neuer String angelegt",
              "elements": [
                [
                  0,
                  33
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "Es wird ein neuer String erschaffen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Es wird ein neuer String erschaffen.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Es wird ein neuer String erschaffen",
              "elements": [
                [
                  0,
                  35
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "Eine neue leere Zeichenkette wird gespeichert und die Variable wird auf sie zeigen,",
          "id": "408f0afbe2440a4383a1e75b7d5b0b4202c7f7131a9acf9bd70492f3",
          "correctionOrComment": "Eine neue leere Zeichenkette wird gespeichert und die Variable wird auf sie zeigen,",
          "answerCategory": "binary_correct",
          "aspects": [
            {
              "text": "Eine neue leere Zeichenkette wird gespeichert ",
              "elements": [
                [
                  0,
                  45
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "die Variable wird auf sie zeigen",
              "elements": [
                [
                  50,
                  82
                ]
              ],
              "aIdx": 1,
              "label": 1
            }
          ]
        },
        {
          "text": "Ein neuer, noch leerer String wird erstellt (und eine neue Referenz).",
          "id": "0ce8152aa92136af039b687c01c7dccfcb271f3db2d0ddcb3cfdd3e6",
          "correctionOrComment": "Ein neuer, noch leerer String wird erstellt und eine neue Referenz.",
          "answerCategory": "binary_correct",
          "aspects": [
            {
              "text": "Ein neuer, noch leerer String wird erstellt",
              "elements": [
                [
                  0,
                  43
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "und eine neue Referenz",
              "elements": [
                [
                  45,
                  67
                ]
              ],
              "aIdx": 1,
              "label": 1
            }
          ]
        },
        {
          "text": "es wird nicht überprüft ob es schon einen string mit dem gleichen inhalt gibt, sondern ein neuer speicher mit einer neuen Referenz für den String erstellt.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Es wird nicht überprüft ob es schon einen String mit dem gleichen inhalt gibt, sondern ein neuer Speicher mit einer neuen Referenz für den String erstellt.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Es wird nicht überprüft ob es schon einen String mit dem gleichen inhalt gibt, sondern ein neuer speicher ;; erstellt",
              "elements": [
                [
                  146,
                  154
                ]
              ],
              "aIdx": 0,
              "label": 1
            },
            {
              "text": "Es wird ;;  ein neuer Speicher mit einer neuen Referenz ;: erstellt",
              "elements": [],
              "aIdx": 1,
              "label": 1
            }
          ]
        },
        {
          "text": "Ein neuer leerer String wird initialisiert.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "correctionOrComment": "Ein neuer leerer String wird initialisiert.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Ein neuer leerer String wird initialisiert",
              "elements": [
                [
                  0,
                  42
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "Ein neues Objekt des Typs String wird erzeugt.",
          "id": "58b2aaa0bfae7acc021b3260e941117b529b2e69de878fd7d45c61a9",
          "correctionOrComment": "Ein neues Objekt des Typs String wird erzeugt.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Ein neues Objekt des Typs String wird erzeugt",
              "elements": [
                [
                  0,
                  45
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "Ein neuer leerer String wird angelegt",
          "id": "6332531eeafc6e0ede272192be898f549950fb32b209d04f0a98306a",
          "correctionOrComment": "Ein neuer leerer String wird angelegt",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Ein neuer leerer String wird angelegt",
              "elements": [
                [
                  0,
                  37
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "neuer speicherplatz wird angelegt und konstruktor von der klasse string wird ausgeführt",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Neuer speicherplatz wird angelegt und  der Konstruktor von der Klasse String wird ausgeführt",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Neuer speicherplatz wird angelegt und  der Konstruktor von der Klasse String wird ausgeführt",
              "elements": [],
              "aIdx": 0,
              "label": 1
            }
          ]
        },
        {
          "text": "es wird ein neuer String angelegt mit der Referenz null da dem String noch kein Wert zugewiesen wurde",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Es wird ein neuer String angelegt mit der Referenz null da dem String noch kein Wert zugewiesen wurde",
          "answerCategory": "missconception",
          "aspects": [
            {
              "text": "Es wird ein neuer String angelegt",
              "elements": [],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "mit der Referenz null da dem String noch kein Wert zugewiesen wurde",
              "elements": [
                [
                  34,
                  101
                ]
              ],
              "aIdx": 1,
              "label": 2
            }
          ]
        },
        {
          "text": "Ein neues Stringobjekt wird angelegt. Wenn nicht direkt ein bestimmter Inhalt zugewiesen wird, existiert nur die Referenz die auf Null zeigt.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Ein neues Stringobjekt wird angelegt. Wenn nicht direkt ein bestimmter Inhalt zugewiesen wird, existiert nur die Referenz die auf Null zeigt.",
          "answerCategory": "missconception",
          "aspects": [
            {
              "text": "Ein neues Stringobjekt wird angelegt",
              "elements": [
                [
                  0,
                  36
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Wenn nicht direkt ein bestimmter Inhalt zugewiesen wird, existiert nur die Referenz die auf Null zeigt",
              "elements": [
                [
                  38,
                  140
                ]
              ],
              "aIdx": 1,
              "label": 2
            }
          ]
        },
        {
          "text": "Ein neuer, leerer String wird initalisiert.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Ein neuer, leerer String wird initalisiert.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Ein neuer, leerer String wird initalisiert",
              "elements": [
                [
                  0,
                  42
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "Neues Objekt erstellt auf das referenziert wird",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Es wird ein neues Objekt erstellt auf das referenziert wird",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Es wird ein neues Objekt erstellt",
              "elements": [],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "auf das referenziert wird",
              "elements": [
                [
                  22,
                  47
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Es wird eine neue String Operation erstellt",
          "id": "271f93f45e9b4067327ed5c8cd30a034730aaace4382803c3e1d6c2f",
          "correctionOrComment": "Es wird eine neue String Operation erstellt",
          "answerCategory": "missconception",
          "aspects": [
            {
              "text": "Es wird eine neue String Operation erstellt",
              "elements": [
                [
                  0,
                  43
                ]
              ],
              "aIdx": 0,
              "label": 1
            }
          ]
        },
        {
          "text": "Es wird ein leerer String erzeugt, dessen Referenz keine von schon vorhandenen Strings ist.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Es wird ein leerer String erzeugt, dessen Referenz keine von schon vorhandenen Strings ist.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Es wird ein leerer String erzeugt",
              "elements": [
                [
                  0,
                  33
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "dessen Referenz keine von schon vorhandenen Strings ist",
              "elements": [
                [
                  35,
                  90
                ]
              ],
              "aIdx": 1,
              "label": 1
            }
          ]
        },
        {
          "text": "Es wird ein neues Objekt vom Typ String erstellt.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6",
          "correctionOrComment": "Es wird ein neues Objekt vom Typ String erstellt.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Es wird ein neues Objekt vom Typ String erstellt",
              "elements": [
                [
                  0,
                  48
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "Es wird im Speicher Platz für einen neuen String erstellt.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Es wird im Speicher Platz für einen neuen String erstellt.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Es wird im Speicher Platz für einen neuen String erstellt",
              "elements": [
                [
                  0,
                  57
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "Es wird intern ein Pointer auf eine neue Instanz der string-class erstellt. In Java wird einfach ein neues Objekt erzeugt.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6",
          "correctionOrComment": "Es wird intern ein Pointer auf eine neue Instanz der String Klasse erstellt. In Java wird einfach ein neues Objekt erzeugt.",
          "answerCategory": "binary_correct",
          "aspects": [
            {
              "text": "Es wird ;; eine neue Instanz der String Klasse erstellt",
              "elements": [
                [
                  0,
                  7
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Es wird intern ein Pointer auf eine neue Instanz der String Klasse erstellt",
              "elements": [],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Es wird eine neue leere Zeichenkette erstellt",
          "id": "53750c72b7bb26cb6ff7115e383ca150d5a632a909a7f79e2f5274a4",
          "correctionOrComment": "Es wird eine neue leere Zeichenkette erstellt",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Es wird eine neue leere Zeichenkette erstellt",
              "elements": [
                [
                  0,
                  45
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "neuer speicherbereich wird angelegt",
          "id": "8416c38cc898f1ac7cc9d64e89dab1f70f5ddab002a5b2a1713f93f5",
          "correctionOrComment": "Ein neuer Speicherbereich wird angelegt",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Ein neuer Speicherbereich wird angelegt",
              "elements": [],
              "aIdx": 0,
              "label": 1
            }
          ]
        },
        {
          "text": "jojiji",
          "id": "192f56eb9bd894a72b30c303247b107be2c4591f310dd69a67927f48",
          "correctionOrComment": "jojiji",
          "answerCategory": "none",
          "aspects": []
        },
        {
          "text": "Es wird eine neue Referenz erzeugt.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "correctionOrComment": "Es wird eine neue Referenz erzeugt.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Es wird eine neue Referenz erzeugt",
              "elements": [
                [
                  0,
                  34
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Dem String wird ein (leerer) Speicherbereich zugewiesen\\/ eine Referenz auf diesen Bereich.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "correctionOrComment": "Dem String wird ein leerer Speicherbereich zugewiesen und eine Referenz auf diesen Bereich wird erstellt.",
          "answerCategory": "binary_correct",
          "aspects": [
            {
              "text": "Dem String wird ein leerer Speicherbereich zugewiesen",
              "elements": [],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "nd eine Referenz auf diesen Bereich wird erstellt",
              "elements": [],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Ein neues Objekt der Klasse string wird erstellt",
          "id": "b51d18b551043c1f145f22dbde6f8531faeaf68c54ed9dd79ce24d17",
          "correctionOrComment": "Ein neues Objekt der Klasse String wird erstellt",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Ein neues Objekt der Klasse String wird erstellt",
              "elements": [],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "Ein neuer String wird initialisiert.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Ein neuer String wird initialisiert.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Ein neuer String wird initialisiert",
              "elements": [
                [
                  0,
                  35
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "Ein neuer String mit neuer Referenz wird angelegt.",
          "id": "f09265efb456b0336079ad5b238daa1e38a11b1d71cc0e1a4e8edd56",
          "correctionOrComment": "Ein neuer String mit neuer Referenz wird angelegt.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Ein neuer String mit neuer Referenz wird angelegt",
              "elements": [
                [
                  0,
                  49
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Ein neuer String mit neuer Referenz wird angelegt",
              "elements": [
                [
                  0,
                  49
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "es wird ein neuer Leerer String erstellt und somit schon mal die Adresse im Speicher reserviert",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c",
          "correctionOrComment": "Es wird ein neuer Leerer String erstellt und somit schon mal die Adresse im Speicher reserviert",
          "answerCategory": "binary_correct",
          "aspects": [
            {
              "text": "Es wird ein neuer Leerer String erstellt",
              "elements": [],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "und somit schon mal die Adresse im Speicher reserviert",
              "elements": [
                [
                  41,
                  95
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "ein neuer String wird erstellt (neue referenz)",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Ein neuer String wird erstellt mit neuer Referenz",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Ein neuer String wird erstellt",
              "elements": [],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Ein neuer String wird erstellt mit neuer Referenz",
              "elements": [],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Es wird ein neuer leerer String im Speicher erstellt. Anschließend zeigt die Variable auf diesen Speicherplatz.",
          "id": "b8607e0369fbf3e33bc0e358f840915d8c085d1496097351913c0122",
          "correctionOrComment": "Es wird ein neuer leerer String im Speicher erstellt. Anschließend zeigt die Variable auf diesen Speicherplatz.",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": "Es wird ein neuer leerer String im Speicher erstellt",
              "elements": [
                [
                  0,
                  52
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Anschließend zeigt die Variable auf diesen Speicherplatz",
              "elements": [
                [
                  54,
                  110
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Es wird ein neuer Speicherplatz angelegt, auf den der String verweist, wessen Referenz gespeichert wird.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Es wird ein neuer Speicherplatz angelegt, auf den der String verweist, wessen Referenz gespeichert wird.",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": "Es wird ein neuer Speicherplatz angelegt, auf den der String verweist",
              "elements": [
                [
                  0,
                  69
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "wessen Referenz gespeichert wird",
              "elements": [
                [
                  71,
                  103
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Ein neuer leerer String wird erstellt und eine Referenz die darauf zeigt wird gespeichert",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Ein neuer leerer String wird erstellt und eine Referenz die darauf zeigt wird gespeichert",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": "Ein neuer leerer String wird erstellt ",
              "elements": [
                [
                  0,
                  37
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "und eine Referenz die darauf zeigt wird gespeichert",
              "elements": [
                [
                  38,
                  89
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Ein neuer String wird angelegt.",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c",
          "correctionOrComment": "Ein neuer String wird angelegt.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Ein neuer String wird angelegt",
              "elements": [
                [
                  0,
                  30
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "ein neuer leerer String wird erstellt, die Referanz zeigt auf Inhalt im Speicher",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Ein neuer leerer String wird erstellt, die Referanz zeigt auf dessen Inhalt im Speicher",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": "Ein neuer leerer String wird erstellt,",
              "elements": [],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "die Referanz zeigt auf dessen Inhalt im Speicher",
              "elements": [],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "eine neue Referenz wird erschaffen",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Eine neue Referenz wird erschaffen",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Eine neue Referenz wird erschaffen",
              "elements": [],
              "aIdx": 1,
              "label": 0
            }
          ]
        }
      ]
    },
    {
      "text": "Was ist ein Array?",
      "id": 50722,
      "title": "Datenstruktur Array",
      "type": "definition",
      "aspects": [
        {
          "text": "eine Datenstruktur fester größe"
        },
        {
          "text": "enhält eine Sequenz von Variablen"
        },
        {
          "text": "alle Variablen müssen den gleichen Typ haben"
        }
      ],
      "referenceAnswers": [
        {
          "text": "Ein Array ist eine Datenstruktur fester größe, die eine Sequenz von Daten gleichen Typs enthält.",
          "aspects": [
            {
              "text": "Ein Array ist eine Datenstruktur fester größe",
              "aIdx": 0,
              "elements": [
                [
                  0,
                  45
                ]
              ]
            },
            {
              "text": "die eine Sequenz von Variablen ;; enthält",
              "aIdx": 1,
              "elements": [
                [
                  47,
                  73
                ],
                [
                  88,
                  95
                ]
              ]
            },
            {
              "text": "die ;; Variablen gleichen Typs enthält",
              "aIdx": 2,
              "elements": [
                [
                  47,
                  50
                ],
                [
                  68,
                  95
                ]
              ]
            }
          ]
        }
      ],
      "studentAnswers": [
        {
          "text": "ein array ist ein Feld in dem Daten gespeichert werden",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Ein Array ist ein Feld in dem Daten gespeichert werden",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Ein Array ist ein Feld in dem Daten gespeichert werden",
              "elements": [],
              "aIdx": 0,
              "label": 1
            }
          ]
        },
        {
          "text": "Ein Array dient zur Speicherung mehrerer Elemente eines bestimmten Datentyps. Seine Länge ist konstant und wird bei seiner Erstellung festgelegt. Arrays können auch andere Arrays enthalten, dabei spricht man von mehrdimensionalen Arrays.",
          "id": "8bbd52208353c14f154f1402cebf5829afb1708d06b5dc25064dff23",
          "correctionOrComment": "Ein Array dient zur Speicherung mehrerer Elemente eines bestimmten Datentyps. Seine Länge ist konstant und wird bei seiner Erstellung festgelegt. Arrays können auch andere Arrays enthalten, dabei spricht man von mehrdimensionalen Arrays.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Seine Länge ist konstant und wird bei seiner Erstellung festgelegt",
              "elements": [
                [
                  78,
                  144
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Ein Array dient zur Speicherung mehrerer Elemente eines bestimmten Datentyps",
              "elements": [
                [
                  0,
                  76
                ]
              ],
              "aIdx": 2,
              "label": 0
            }
          ]
        },
        {
          "text": "Ein Array ist ein Datentyp, der zur Speicherung und Verwendung mehrerer Werte eines Typs dient.",
          "id": "4cfc3a1811fe40afa401b25ef7fa0379f1f7c1930a04f8755d678474",
          "correctionOrComment": "Ein Array ist ein Datentyp, der zur Speicherung und Verwendung mehrerer Werte eines Typs dient.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Ein Array ist ein Datentyp, der zur Speicherung und Verwendung mehrerer Werte eines Typs dient",
              "elements": [
                [
                  0,
                  94
                ]
              ],
              "aIdx": 2,
              "label": 0
            }
          ]
        },
        {
          "text": "Ein Feld von Daten des gleichen Typs. Die Elemente folgen unmittelbar aufeinander und können über einen Index adressiert werden.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Ein Feld von Daten des gleichen Typs. Die Elemente folgen unmittelbar aufeinander und können über einen Index adressiert werden.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": " Die Elemente folgen unmittelbar aufeinander und können über einen Index adressiert werden",
              "elements": [
                [
                  38,
                  127
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "Ein Feld von Daten des gleichen Typs",
              "elements": [
                [
                  0,
                  36
                ]
              ],
              "aIdx": 2,
              "label": 0
            }
          ]
        },
        {
          "text": "In einem array können Werte gespeichert werden er kann auch mehrdemensional sein",
          "id": "8a217ea5f39d0f20db42ef9bcb667eacd060a40b50a18655172ec4b8",
          "correctionOrComment": "In einem array können Werte gespeichert werden er kann auch mehrdemensional sein",
          "answerCategory": "partially_correct",
          "aspects": []
        },
        {
          "text": "Ein Array ist ein Objekt, welches eine Reihe von Elementen beinhalten kann. Bei bestimmten Datentypen-Arrays können nur Elemente dieses Datentyps enthalten sein.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Ein Array ist ein Objekt, welches eine Reihe von Elementen beinhalten kann. Bei bestimmten Datentypen-Arrays können nur Elemente dieses Datentyps enthalten sein.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Ein Array ist ein Objekt, welches eine Reihe von Elementen beinhalten kann",
              "elements": [
                [
                  0,
                  74
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "Bei bestimmten Datentypen-Arrays können nur Elemente dieses Datentyps enthalten sein",
              "elements": [
                [
                  76,
                  160
                ]
              ],
              "aIdx": 2,
              "label": 0
            }
          ]
        },
        {
          "text": "Ein Array kann Daten eines gleichen Typs speichern. Die Länge eines Arrays ist fest. Die Daten können durch einen Index aufgerufen werden.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Ein Array kann Daten eines gleichen Typs speichern. Die Länge eines Arrays ist fest. Die Daten können durch einen Index aufgerufen werden.",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": "Die Länge eines Arrays ist fest",
              "elements": [
                [
                  52,
                  83
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Die Daten können durch einen Index aufgerufen werden",
              "elements": [
                [
                  85,
                  137
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "Ein Array kann Daten eines gleichen Typs speichern",
              "elements": [
                [
                  0,
                  50
                ]
              ],
              "aIdx": 2,
              "label": 0
            }
          ]
        },
        {
          "text": "k",
          "id": "c1b8144ee1a30244a571c3d9b48b2c394a7489065d2565968f521645",
          "correctionOrComment": "k",
          "answerCategory": "none",
          "aspects": []
        },
        {
          "text": "Ist eine Gruppe von Objekten mit denselben Attributen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Ist eine Gruppe von Objekten mit denselben Attributen.",
          "answerCategory": "missconception",
          "aspects": [
            {
              "text": "Ist eine Gruppe von Objekten mit denselben Attributen",
              "elements": [
                [
                  0,
                  53
                ]
              ],
              "aIdx": 2,
              "label": 1
            }
          ]
        },
        {
          "text": "Ein Array ist ein Objekt indem eine Sequenz von Daten gespeichert werden kann, welche dann mit Zahlenindexen referenziert werden.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Ein Array ist ein Objekt indem eine Sequenz von Daten gespeichert werden kann, welche dann mit Zahlenindexen referenziert werden.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Ein Array ist ein Objekt indem eine Sequenz von Daten gespeichert werden kann",
              "elements": [
                [
                  0,
                  77
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Ein Datentyp in welchem eine Art von Daten in einer Reihenfolge gespeichert und durchlaufen werden können. Die größe wird vorher festgelegt.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Ein Datentyp in welchem eine Art von Daten in einer Reihenfolge gespeichert und durchlaufen werden können. Die Größe wird vorher festgelegt.",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": "Ein Datentyp in welchem eine Art von Daten ;; gespeichert ;; werden",
              "elements": [
                [
                  0,
                  42
                ],
                [
                  64,
                  75
                ],
                [
                  92,
                  98
                ]
              ],
              "aIdx": 2,
              "label": 0
            },
            {
              "text": "Ein Datentyp in welchem eine Art von Daten in einer Reihenfolge gespeichert und durchlaufen werden könnenG",
              "elements": [],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "Die Größe wird vorher festgelegt",
              "elements": [],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "Es ähnelt vom Aufbau einem String.",
          "id": "ea674ab55536a8b603be44d13510e32c7aab02088bf48c2802e4febd",
          "correctionOrComment": "Es ähnelt vom Aufbau einem String.",
          "answerCategory": "irrelevant",
          "aspects": []
        },
        {
          "text": "Ein Array ist ein Datentyp, bei dem mehrer Daten aneinandergereiht werden können.",
          "id": "7ba019a2553e1137a4bbb8d3c779a48e5ceb2ca3a162e6e0a945ef0f",
          "correctionOrComment": "Ein Array ist ein Datentyp, bei dem mehrer Daten aneinandergereiht werden können.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Ein Array ist ein Datentyp, bei dem mehrer Daten aneinandergereiht werden können",
              "elements": [
                [
                  0,
                  80
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Ein Array ist eine Anreihung von Daten.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Ein Array ist eine Anreihung von Daten.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Ein Array ist eine Anreihung von Daten",
              "elements": [
                [
                  0,
                  38
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "ein array ist eine datenstruktur die sequenz von variablen gleichen typs enthält. einzelne einträge werden durchnummeriert",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Ein Array ist eine Datenstruktur die eine Sequenz von Variablen gleichen Typs enthält. einzelne einträge werden durchnummeriert",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Ein Array ist eine Datenstruktur die eine Sequenz von Variablen ;; enthält",
              "elements": [
                [
                  73,
                  80
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "Ein Array ist eine Datenstruktur die eine Sequenz von Variablen gleichen Typs enthält",
              "elements": [],
              "aIdx": 2,
              "label": 0
            }
          ]
        },
        {
          "text": "ein Array ist eine KEtte von Zahlen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Ein Array ist eine Kette von Zahlen.",
          "answerCategory": "missconception",
          "aspects": [
            {
              "text": "Ein Array ist eine Kette von Zahlen",
              "elements": [],
              "aIdx": 2,
              "label": 2
            }
          ]
        },
        {
          "text": "Eine Datenstruktur, die eine Menge, die unterschiedlich groß und unterschiedlich strukturiert sein kann, vom gleichen Datentyp (Integer, Char...) speichert.",
          "id": "408f0afbe2440a4383a1e75b7d5b0b4202c7f7131a9acf9bd70492f3",
          "correctionOrComment": "Eine Datenstruktur, die eine Menge, die unterschiedlich groß und unterschiedlich strukturiert sein kann, vom gleichen Datentyp (Integer, Char...) speichert.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "eine Menge, die unterschiedlich groß und unterschiedlich strukturiert sein kann",
              "elements": [
                [
                  24,
                  103
                ]
              ],
              "aIdx": 0,
              "label": 2
            },
            {
              "text": "Eine Datenstruktur, die eine Menge ;; vom gleichen Datentyp (Integer, Char...) speichert",
              "elements": [
                [
                  0,
                  34
                ],
                [
                  105,
                  155
                ]
              ],
              "aIdx": 2,
              "label": 0
            }
          ]
        },
        {
          "text": "Ein Array ist ein Datentyp, der eine Reihe von Werten hintereinander speichern kann.  Man kann seine einzelnen Positionen abfragen, aber nicht mit dem Array an sich z.B. rechnen oder ihn ausgeben.",
          "id": "0ce8152aa92136af039b687c01c7dccfcb271f3db2d0ddcb3cfdd3e6",
          "correctionOrComment": "Ein Array ist ein Datentyp, der eine Reihe von Werten hintereinander speichern kann. Man kann seine einzelnen Positionen abfragen, aber nicht mit dem Array an sich z.B. rechnen oder ihn ausgeben.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Ein Array ist ein Datentyp, der eine Reihe von Werten hintereinander speichern kann",
              "elements": [
                [
                  0,
                  83
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "kann mehrdimensional sein. Speichert einzelne primitive Datentypen in einer Reihenfolge und versieht sie mit Indizes, leichter zugriff. feste größe.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Ein Array kann mehrdimensional sein, speichert einzelne primitive Datentypen in einer Reihenfolge und versieht sie mit Indizes, erlaubt leichten einen Zugriff und hat eine feste größe.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Ein Array ;; hat eine feste größe ",
              "elements": [],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Ein Array ;; speichert ;; Datentypen in einer Reihenfolge",
              "elements": [
                [
                  56,
                  87
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "Ein Array ;; speichert einzelne primitive Datentypen",
              "elements": [],
              "aIdx": 2,
              "label": 2
            }
          ]
        },
        {
          "text": "Ein Array ist eine Liste von beliebigen Daten. Auf diese können via deren Index zugegruffen werden.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "correctionOrComment": "Ein Array ist eine Liste von beliebigen Daten. Auf diese können via deren Index zugegriffen werden.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Ein Array ist eine Liste von beliebigen Daten",
              "elements": [
                [
                  0,
                  45
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "Ein Array ist eine Liste von beliebigen Daten",
              "elements": [
                [
                  0,
                  45
                ]
              ],
              "aIdx": 2,
              "label": 2
            }
          ]
        },
        {
          "text": "Datentyp der eine Sequenz von Werten den gleichen Datentyps speichert",
          "id": "8a1c55283fd2fc15f72ad8c88c9dcc447f528814a41bf2a7ab51950a",
          "correctionOrComment": "Datentyp der eine Sequenz von Werten des gleichen Datentyps speichert",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Datentyp der eine Sequenz von Werten ;; speichert",
              "elements": [
                [
                  0,
                  36
                ],
                [
                  60,
                  69
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "Datentyp der eine Sequenz von Werten des gleichen Datentyps speichert",
              "elements": [],
              "aIdx": 2,
              "label": 0
            }
          ]
        },
        {
          "text": "Ein Array ist eine Datenstruktur, die es ermöglicht iterative auf Datensätze gleichen Types zuzugreifen. Ein Array, kann mehrere Dimensionen besitzen.",
          "id": "58b2aaa0bfae7acc021b3260e941117b529b2e69de878fd7d45c61a9",
          "correctionOrComment": "Ein Array ist eine Datenstruktur, die es ermöglicht iterative auf Datensätze gleichen Types zuzugreifen. Ein Array, kann mehrere Dimensionen besitzen.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Ein Array ist eine Datenstruktur, die es ermöglicht iterative auf Datensätze gleichen Types zuzugreifen",
              "elements": [
                [
                  0,
                  103
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "Ein Array ist eine Datenstruktur, die es ermöglicht iterative auf Datensätze gleichen Types zuzugreifen",
              "elements": [
                [
                  0,
                  103
                ]
              ],
              "aIdx": 2,
              "label": 0
            }
          ]
        },
        {
          "text": "Eine Datenstruktur zur Speicherung von gleichartigen Werten",
          "id": "6332531eeafc6e0ede272192be898f549950fb32b209d04f0a98306a",
          "correctionOrComment": "Eine Datenstruktur zur Speicherung von gleichartigen Werten",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Eine Datenstruktur zur Speicherung von gleichartigen Werten",
              "elements": [
                [
                  0,
                  59
                ]
              ],
              "aIdx": 2,
              "label": 0
            }
          ]
        },
        {
          "text": "ein datentyp",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "ein datentyp",
          "answerCategory": "irrelevant",
          "aspects": []
        },
        {
          "text": "Array ist ein Datentyp in dem Ziffern oder Zeichen gespeichert und worauf mit Hilfe von Indices zugegriffen werden kann",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Array ist ein Datentyp in dem Ziffern oder Zeichen gespeichert und worauf mit Hilfe von Indices zugegriffen werden kann",
          "answerCategory": "missconception",
          "aspects": [
            {
              "text": "Array ist ein Datentyp ;; worauf mit Hilfe von Indices zugegriffen werden kann",
              "elements": [
                [
                  0,
                  22
                ],
                [
                  67,
                  119
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "Array ist ein Datentyp in dem Ziffern oder Zeichen gespeichert ;; werden kann",
              "elements": [
                [
                  0,
                  62
                ],
                [
                  108,
                  119
                ]
              ],
              "aIdx": 2,
              "label": 2
            }
          ]
        },
        {
          "text": "Eine Array ist Objekt, in dem eine Sequenz von Variablen gleichen Typs gespeichert werden.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Eine Array ist ein Objekt, in dem eine Sequenz von Variablen gleichen Typs gespeichert wird.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Eine Array ist ein Objekt, in dem eine Sequenz von Variablen ;; gespeichert wird",
              "elements": [],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "Eine Array ist ein Objekt, in dem eine Sequenz von Variablen gleichen Typs gespeichert wird",
              "elements": [],
              "aIdx": 2,
              "label": 0
            }
          ]
        },
        {
          "text": "Einen Reihung von gleichen Datentypen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Einen Reihung von gleichen Datentypen.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Einen Reihung von gleichen Datentypen",
              "elements": [
                [
                  0,
                  37
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "Einen Reihung von gleichen Datentypen",
              "elements": [
                [
                  0,
                  37
                ]
              ],
              "aIdx": 2,
              "label": 0
            }
          ]
        },
        {
          "text": "Indizierte liste",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Das ist eine Indizierte Liste",
          "answerCategory": "binary_correct",
          "aspects": [
            {
              "text": "Das ist eine Indizierte Liste",
              "elements": [],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Ein Array ist eine Aneinanderreihung von verschiedenen Werten",
          "id": "271f93f45e9b4067327ed5c8cd30a034730aaace4382803c3e1d6c2f",
          "correctionOrComment": "Ein Array ist eine Aneinanderreihung von verschiedenen Werten",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Ein Array ist eine Aneinanderreihung von verschiedenen Werten",
              "elements": [
                [
                  0,
                  61
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "Ein Array ist eine Aneinanderreihung von verschiedenen Werten",
              "elements": [
                [
                  0,
                  61
                ]
              ],
              "aIdx": 2,
              "label": 2
            }
          ]
        },
        {
          "text": "Ein Objekt, dass viele Werte eines einzigen Datentyps speichert.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6",
          "correctionOrComment": "Ein Objekt, dass viele Werte eines einzigen Datentyps speichert.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Ein Objekt, dass viele Werte eines einzigen Datentyps speicher",
              "elements": [
                [
                  0,
                  62
                ]
              ],
              "aIdx": 2,
              "label": 0
            }
          ]
        },
        {
          "text": "Ein Array ist ein Datentyp der mehrere Daten eines Datentypes abspeichert.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Ein Array ist ein Datentyp der mehrere Daten eines Datentypes abspeichert.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Ein Array ist ein Datentyp der mehrere Daten eines Datentypes abspeichert",
              "elements": [
                [
                  0,
                  73
                ]
              ],
              "aIdx": 2,
              "label": 0
            }
          ]
        },
        {
          "text": "Ein Array ist eine Reihe von Variablen gleichen Typs.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Ein Array ist eine Reihe von Variablen gleichen Typs.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Ein Array ist eine Reihe von Variablen gleichen Typs",
              "elements": [
                [
                  0,
                  52
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "Ein Array ist eine Reihe von Variablen gleichen Typs",
              "elements": [
                [
                  0,
                  52
                ]
              ],
              "aIdx": 2,
              "label": 0
            }
          ]
        },
        {
          "text": "Eine lineare Anordnung an Daten im Speicher. Dies können auch Pointer-Arrays sein (Refernzen).",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6",
          "correctionOrComment": "Eine lineare Anordnung an Daten im Speicher. Dies können auch Pointer-Arrays sein (Refernzen).",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Eine lineare Anordnung an Daten im Speicher",
              "elements": [
                [
                  0,
                  43
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Ein Objekt mit Integer Werten, die unter Index gespeichert werden",
          "id": "53750c72b7bb26cb6ff7115e383ca150d5a632a909a7f79e2f5274a4",
          "correctionOrComment": "Ein Objekt mit Integer Werten, die unter Index gespeichert werden",
          "answerCategory": "missconception",
          "aspects": [
            {
              "text": "die unter Index gespeichert werden",
              "elements": [
                [
                  31,
                  65
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "Ein Objekt mit Integer Werten",
              "elements": [
                [
                  0,
                  29
                ]
              ],
              "aIdx": 2,
              "label": 2
            }
          ]
        },
        {
          "text": "Eine Reihe gleicher Datentypen",
          "id": "8416c38cc898f1ac7cc9d64e89dab1f70f5ddab002a5b2a1713f93f5",
          "correctionOrComment": "Das ist eine Reihe gleicher Datentypen",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Das ist eine Reihe gleicher Datentypen",
              "elements": [],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "Das ist eine Reihe gleicher Datentypen",
              "elements": [],
              "aIdx": 2,
              "label": 0
            }
          ]
        },
        {
          "text": "mkmkmk",
          "id": "192f56eb9bd894a72b30c303247b107be2c4591f310dd69a67927f48",
          "correctionOrComment": "mkmkmk",
          "answerCategory": "none",
          "aspects": []
        },
        {
          "text": "Ein Array ist ein statischer Datentyp. Er wird mit einer bestimmten Länge festgelegt und kann Werte eines bestimmten Datentyps speichern.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "correctionOrComment": "Ein Array ist ein statischer Datentyp. Es wird mit einer bestimmten Länge festgelegt und kann Werte eines bestimmten Datentyps speichern.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Es ;; kann Werte eines bestimmten Datentyps speichern",
              "elements": [
                [
                  39,
                  41
                ],
                [
                  89,
                  136
                ]
              ],
              "aIdx": 2,
              "label": 0
            },
            {
              "text": "Es wird mit einer bestimmten Länge festgelegt",
              "elements": [],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "Ein Array ist ein Objekt, dass über die Referenz auf einen Speicherbereich, mehrere Werte eines Datentyps in einer Reihenfolge speichert.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "correctionOrComment": "Ein Array ist ein Objekt, dass über die Referenz auf einen Speicherbereich, mehrere Werte eines Datentyps in einer Reihenfolge speichert.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Ein Array ist ein Objekt, dass ;; mehrere Werte ;; in einer Reihenfolge speichert",
              "elements": [
                [
                  0,
                  30
                ],
                [
                  76,
                  89
                ],
                [
                  106,
                  136
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "Ein Array ist ein Objekt, dass ;; Werte eines Datentyps ;; speichert",
              "elements": [
                [
                  0,
                  30
                ],
                [
                  84,
                  105
                ],
                [
                  127,
                  136
                ]
              ],
              "aIdx": 2,
              "label": 0
            }
          ]
        },
        {
          "text": "Datenstruktur, die eine Sequenz von Variablen gleichen Typs enthält",
          "id": "b51d18b551043c1f145f22dbde6f8531faeaf68c54ed9dd79ce24d17",
          "correctionOrComment": "Das ist ein Datenstruktur, die eine Sequenz von Variablen gleichen Typs enthält",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "die ;; Variablen gleichen Typs enthält",
              "elements": [
                [
                  15,
                  18
                ],
                [
                  36,
                  67
                ]
              ],
              "aIdx": 2,
              "label": 0
            },
            {
              "text": "Das ist ein Datenstruktur, die eine Sequenz von Variablen ;; enthält",
              "elements": [
                [
                  60,
                  67
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Ein Array ist eine Datenstruktur, die eine Sequenz von Variablen des gleichen Typs enthält.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Ein Array ist eine Datenstruktur, die eine Sequenz von Variablen des gleichen Typs enthält.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Ein Array ist eine Datenstruktur, die eine Sequenz von Variablen ;; enthält",
              "elements": [
                [
                  0,
                  64
                ],
                [
                  83,
                  90
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "Ein Array ist eine Datenstruktur, die Variablen des gleichen Typs enthält",
              "elements": [],
              "aIdx": 2,
              "label": 0
            }
          ]
        },
        {
          "text": "Ein Array ist Sammlung von Werten. Jeder Wert hat einen Index, unter dem er im Array gespeichert wird und abgerufen werden kann, ähnlich einer Tabelle.",
          "id": "f09265efb456b0336079ad5b238daa1e38a11b1d71cc0e1a4e8edd56",
          "correctionOrComment": "Ein Array ist Sammlung von Werten. Jeder Wert hat einen Index, unter dem er im Array gespeichert wird und abgerufen werden kann, ähnlich einer Tabelle.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Ein Array ist Sammlung von Werten. Jeder Wert hat einen Index, unter dem er im Array gespeichert wird und abgerufen werden kann",
              "elements": [
                [
                  0,
                  127
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Speichersequenz von gleichen Datentypen",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Es dient zur Speichersequenz von gleichen Datentypen",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Es dient zur Speichersequenz von gleichen Datentypen",
              "elements": [],
              "aIdx": 2,
              "label": 0
            }
          ]
        },
        {
          "text": "Ist eine Anreihung von Werten eines Datentyps ohne für jeden Wert eine neue deklaration zu definieren",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c",
          "correctionOrComment": "Es ist eine Anreihung von Werten eines Datentyps ohne für jeden Wert eine neue deklaration zu definieren",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Es ist eine Anreihung von Werten",
              "elements": [],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "Es ist eine Anreihung von Werten eines Datentyps",
              "elements": [],
              "aIdx": 2,
              "label": 0
            }
          ]
        },
        {
          "text": "Datenstruktur",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Datenstruktur",
          "answerCategory": "none",
          "aspects": []
        },
        {
          "text": "Ein Array ist eine durchnummerierte Ansammlung von Daten eines Typs.",
          "id": "b8607e0369fbf3e33bc0e358f840915d8c085d1496097351913c0122",
          "correctionOrComment": "Ein Array ist eine durchnummerierte Ansammlung von Daten eines Typs.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Ein Array ist eine durchnummerierte Ansammlung von Daten ",
              "elements": [
                [
                  0,
                  56
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "Ein Array ist eine  Ansammlung von Daten eines Typs",
              "elements": [],
              "aIdx": 2,
              "label": 0
            }
          ]
        },
        {
          "text": "Eine Datenstruktur, die eine festbestimmte Größe hat und auf mehrere Objekte durch Referenzen verweisen kann.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Eine Datenstruktur, die eine festbestimmte Größe hat und auf mehrere Objekte durch Referenzen verweisen kann.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Eine Datenstruktur, die eine festbestimmte Größe hat",
              "elements": [
                [
                  0,
                  52
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "In einem Array können mehrere Werte des gleichen Typs gespeichert werden.",
          "id": "0aebf04a018e3de3078a2580a53f660b420bea77865d71caed9f8690",
          "correctionOrComment": "In einem Array können mehrere Werte des gleichen Typs gespeichert werden.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "In einem Array können mehrere Werte des gleichen Typs gespeichert werden",
              "elements": [
                [
                  0,
                  72
                ]
              ],
              "aIdx": 2,
              "label": 0
            }
          ]
        },
        {
          "text": "Im übertragenen Sinn ein Vektor (bei mehrdimensionalen Arrays eine Matrix). Man kann auf jede Position des Array zugreifen.",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c",
          "correctionOrComment": "Im übertragenen Sinn ein Vektor (bei mehrdimensionalen Arrays eine Matrix). Man kann auf jede Position des Array zugreifen.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Im übertragenen Sinn ein Vektor (bei mehrdimensionalen Arrays eine Matrix). Man kann auf jede Position des Array zugreifen",
              "elements": [
                [
                  0,
                  122
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Matrix, die Reihe von Werten des gleichen Datentyps speichert",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Es ist eine Matrix, die eine Reihe von Werten des gleichen Datentyps speichert",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Es ist eine Matrix",
              "elements": [],
              "aIdx": 1,
              "label": 2
            },
            {
              "text": "die eine Reihe von Werten des gleichen Datentyps speich",
              "elements": [],
              "aIdx": 2,
              "label": 0
            }
          ]
        },
        {
          "text": "index zeichenkette",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "index zeichenkette",
          "answerCategory": "missconception",
          "aspects": []
        }
      ]
    },
    {
      "text": "Warum ist die Laufzeit für das Sortieren von Strings im Gegensatz zu Integern nicht allein von der Anzahl der zu sortierenden Elemente abhängig?",
      "id": 50726,
      "title": "Komplexität Sortieren von Strings",
      "type": "reason",
      "aspects": [
        {
          "text": "die Länge eines Strings ist theoretisch nicht beschränkt"
        },
        {
          "text": "Die Laufzeit für den Vergleich von zwei Strings ist nicht konstant wie bei Integern"
        }
      ],
      "referenceAnswers": [
        {
          "text": "Weil die Länge eines Strings theoretisch nicht beschränkt ist. Die Laufzeit für den Vergleich von zwei Strings ist daher nicht konstant wie bei Integern.",
          "aspects": [
            {
              "text": "Weil die Länge eines Strings theoretisch nicht beschränkt ist",
              "aIdx": 0,
              "elements": [
                [
                  0,
                  61
                ]
              ]
            },
            {
              "text": "Die Laufzeit für den Vergleich von zwei Strings ist daher nicht konstant wie bei Integern",
              "aIdx": 1,
              "elements": [
                [
                  63,
                  152
                ]
              ]
            }
          ]
        }
      ],
      "studentAnswers": [
        {
          "text": "strings selber können nochmal unterschiedlich groß sein und damit unterschiedlich viele Rechenschritte brauchen",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Strings selber können nochmal unterschiedlich groß sein und damit unterschiedlich viele Rechenschritte brauchen",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": "Strings selber können nochmal unterschiedlich groß sein ",
              "elements": [],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Strings selber können ;; unterschiedlich viele Rechenschritte brauchen",
              "elements": [
                [
                  66,
                  111
                ]
              ],
              "aIdx": 1,
              "label": 1
            }
          ]
        },
        {
          "text": "Weil Strings einen größeren Speicherbedarf haben.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Weil Strings einen größeren Speicherbedarf haben.",
          "answerCategory": "partially_correct",
          "aspects": []
        },
        {
          "text": "Da Strings mit Referenzen arbeiten.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Da Strings mit Referenzen arbeiten.",
          "answerCategory": "irrelevant",
          "aspects": []
        },
        {
          "text": "Es ist auch von der länge der Strings abhängig",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Es ist auch von der länge der Strings abhängig",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": "Es ist auch von der länge der Strings abhängig",
              "elements": [
                [
                  0,
                  46
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "Wegen Typecasts.",
          "id": "7ba019a2553e1137a4bbb8d3c779a48e5ceb2ca3a162e6e0a945ef0f",
          "correctionOrComment": "Wegen Typecasts.",
          "answerCategory": "missconception",
          "aspects": []
        },
        {
          "text": "we",
          "id": "c1b8144ee1a30244a571c3d9b48b2c394a7489065d2565968f521645",
          "correctionOrComment": "we",
          "answerCategory": "none",
          "aspects": []
        },
        {
          "text": "Ist der String ungünstig sortiert, müssen mehr Tauschaktionen durchgeführt werden, als wenn er zb schon sortiert ist.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Ist der String ungünstig sortiert, müssen mehr Tauschaktionen durchgeführt werden, als wenn er zb schon sortiert ist.",
          "answerCategory": "missconception",
          "aspects": []
        },
        {
          "text": "Weil es auch von den Referenzen der Strings abhängt.",
          "id": "0ce8152aa92136af039b687c01c7dccfcb271f3db2d0ddcb3cfdd3e6",
          "correctionOrComment": "Weil es auch von den Referenzen der Strings abhängt.",
          "answerCategory": "missconception",
          "aspects": []
        },
        {
          "text": "Strings können in ihrer Länge variieren, was bei der Sortierung beachtet werden muss. Integer haben eine feste Größe.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "correctionOrComment": "Strings können in ihrer Länge variieren, was bei der Sortierung beachtet werden muss. Integer haben eine feste Größe.",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": "Strings können in ihrer Länge variieren",
              "elements": [
                [
                  0,
                  39
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "Weil Strings aufwändiger sortiert werden müssen, da sie nicht so einfach zu vergleichen sind.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Weil Strings aufwändiger sortiert werden müssen, da sie nicht so einfach zu vergleichen sind.",
          "answerCategory": "partially_correct",
          "aspects": []
        },
        {
          "text": "Weil Strings Referenzen besitzen. Das heißt zusätzlicher Speicher wird benötigt. Das Sortieren geschieht nicht insitu.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Weil Strings Referenzen besitzen, das heißt zusätzlicher Speicher wird benötigt. Das Sortieren geschieht nicht insitu.",
          "answerCategory": "irrelevant",
          "aspects": []
        },
        {
          "text": "Weil die Strings eine theoretisch unedliche Länge haben können, während die größe von Integer begrenzt ist.",
          "id": "408f0afbe2440a4383a1e75b7d5b0b4202c7f7131a9acf9bd70492f3",
          "correctionOrComment": "Weil die Strings eine theoretisch unendliche Länge haben können, während die größe von Integer begrenzt ist.",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": "Weil die Strings eine theoretisch unendliche Länge haben können",
              "elements": [],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "Weil es auch auf die Länge der einzelnen Strings ankommt",
          "id": "271f93f45e9b4067327ed5c8cd30a034730aaace4382803c3e1d6c2f",
          "correctionOrComment": "Weil es auch auf die Länge der einzelnen Strings ankommt",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": "Weil es auch auf die Länge der einzelnen Strings ankommt",
              "elements": [
                [
                  0,
                  56
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "Es hängt auch noch von der Länge der Strings ab. Außerdem muss ja die Referenz verglichen werden.",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c",
          "correctionOrComment": "Es hängt auch noch von der Länge der Strings ab. Außerdem muss ja die Referenz verglichen werden.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Es hängt auch noch von der Länge der Strings ab",
              "elements": [
                [
                  0,
                  47
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "Die einzelnen Zeichen eines Strings müssen erst in Integer umgewandelt werden, bevor sie sortiert werden können.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6",
          "correctionOrComment": "Die einzelnen Zeichen eines Strings müssen erst in Integer umgewandelt werden, bevor sie sortiert werden können.",
          "answerCategory": "missconception",
          "aspects": []
        },
        {
          "text": "Weil Strings wiederrum verschiedene Längen haben - diese sind wiederrum nichts anderes als Arrays mit chars und einer eigenen Länge.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6",
          "correctionOrComment": "Weil Strings wiederrum verschiedene Längen haben - diese sind wiederrum nichts anderes als Arrays mit chars und einer eigenen Länge.",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": "Weil Strings wiederrum verschiedene Längen haben",
              "elements": [
                [
                  0,
                  48
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "Weil jeder einzelne String aus mehreren chars besteht und Integer keine solche Eigenschaft haben.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Weil jeder einzelne String aus mehreren chars besteht und Integer keine solche Eigenschaft haben.",
          "answerCategory": "binary_correct",
          "aspects": [
            {
              "text": "Weil jeder einzelne String aus mehreren chars besteht",
              "elements": [
                [
                  0,
                  53
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "Weil die größe der zu sortierenden Strings variabel ist",
          "id": "53750c72b7bb26cb6ff7115e383ca150d5a632a909a7f79e2f5274a4",
          "correctionOrComment": "Weil die größe der zu sortierenden Strings variabel ist",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": "Weil die größe der zu sortierenden Strings variabel ist",
              "elements": [
                [
                  0,
                  55
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "In einem Integer muss nur der Wert des Ints vergleichen werden, bei einem String muss der ganze String durchlaufen und jedes Zeichen verglichen werden.",
          "id": "8416c38cc898f1ac7cc9d64e89dab1f70f5ddab002a5b2a1713f93f5",
          "correctionOrComment": "In einem Integer muss nur der Wert des Ints vergleichen werden, bei einem String muss der ganze String durchlaufen und jedes Zeichen verglichen werden.",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": "bei einem String muss der ganze String durchlaufen und jedes Zeichen verglichen werden",
              "elements": [
                [
                  64,
                  150
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "njnjni",
          "id": "192f56eb9bd894a72b30c303247b107be2c4591f310dd69a67927f48",
          "correctionOrComment": "njnjni",
          "answerCategory": "none",
          "aspects": []
        },
        {
          "text": "Bei Strings werden immer die Objekte angesprochen und deswegen ist dies nicht allein von den sortierten Elementen abhängig.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "correctionOrComment": "Bei Strings werden immer die Objekte angesprochen und deswegen ist dies nicht allein von den sortierten Elementen abhängig.",
          "answerCategory": "irrelevant",
          "aspects": []
        },
        {
          "text": "Strings repräsentieren Zeichenkette, haben also auch eine variable Eingabegröße in sich.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "correctionOrComment": "Strings repräsentieren Zeichenkette, haben also auch eine variable Eingabegröße in sich.",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": "Strings repräsentieren Zeichenkette, haben also auch eine variable Eingabegröße in sich",
              "elements": [
                [
                  0,
                  87
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "Ein String hat keine obere schranke für seine länge, die als konstante genommen werden kann (vereinfacht nach oben abgeschätzt), auch von der länge der strings abhängig",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Ein String hat keine obere Schranke für seine länge, die als konstante genommen werden kann (vereinfacht nach oben abgeschätzt), auch von der länge der strings abhängig",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": "Ein String hat keine obere Schranke für seine länge, die als konstante genommen werden kann ",
              "elements": [],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "Weil in Strings der Inhalt der Referenzen verglichen werden muss.",
          "id": "f09265efb456b0336079ad5b238daa1e38a11b1d71cc0e1a4e8edd56",
          "correctionOrComment": "Weil in Strings der Inhalt der Referenzen verglichen werden muss.",
          "answerCategory": "irrelevant",
          "aspects": []
        },
        {
          "text": "x",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "x",
          "answerCategory": "none",
          "aspects": []
        },
        {
          "text": "Anders als Integer können Strings eine unendliche Länge haben.",
          "id": "b8607e0369fbf3e33bc0e358f840915d8c085d1496097351913c0122",
          "correctionOrComment": "Anders als Integer können Strings eine unendliche Länge haben.",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": "Anders als Integer können Strings eine unendliche Länge haben",
              "elements": [
                [
                  0,
                  61
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "Es werden unterschiedlichviele Vergleiche benötigt",
          "id": "ae8820303e493738a211ebb2ae3a2f90b286f20f767609beb77522c0",
          "correctionOrComment": "Es werden unterschiedlich viele Vergleiche benötigt",
          "answerCategory": "binary_correct",
          "aspects": [
            {
              "text": "Es werden unterschiedlich viele Vergleiche benötigt",
              "elements": [],
              "aIdx": 1,
              "label": 1
            }
          ]
        },
        {
          "text": "Da für das Sortieren auch die einzelnen Symbole der Sstrings relevant sind, ist die Laufzeit ebenso davon abhängig, wieviele Zeichen die Strings ausmachen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Da für das Sortieren auch die einzelnen Symbole der Strings relevant sind, ist die Laufzeit ebenso davon abhängig, wieviele Zeichen die Strings ausmachen.",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": "wieviele Zeichen die Strings ausmachen",
              "elements": [
                [
                  116,
                  154
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Da für das Sortieren auch die einzelnen Symbole der Strings relevant sind, ist die Laufzeit ebenso davon abhängig, wieviele Zeichen die Strings ausmachen",
              "elements": [],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Da die Länge eines Strings nicht festgelegt ist, anders als die eines Ints,",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Da die Länge eines Strings nicht festgelegt ist, anders als die eines Ints,",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": "Da die Länge eines Strings nicht festgelegt ist",
              "elements": [
                [
                  0,
                  47
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "Strings sind nicht wirklich nach oben beschränkt, es kommt also auf Inhalt an",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Strings sind nicht wirklich nach oben beschränkt, es kommt also auf den Inhalt an",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": "Strings sind nicht wirklich nach oben beschränkt, es kommt also auf den Inhalt an",
              "elements": [],
              "aIdx": 0,
              "label": 0
            }
          ]
        }
      ]
    },
    {
      "text": "Beschreibe das Vorgehen bei der binären Suche.",
      "id": 50731,
      "title": "Binäre Suche",
      "type": "procedure",
      "aspects": [
        {
          "text": "Es wird immer nur das mittlere Element der Menge mit dem gesuchten Element verglichen"
        },
        {
          "text": "Das Ergebnis des Vergleichs bestimmt die neue noch zu durchsuchende Menge"
        }
      ],
      "referenceAnswers": [
        {
          "text": "Es wird immer nur das mittlere Element der Menge mit dem gesuchten Element verglichen. Das Ergebnis des Vergleichs bestimmt die neue noch zu durchsuchende Menge.",
          "aspects": [
            {
              "text": "Es wird immer nur das mittlere Element der Menge mit dem gesuchten Element verglichen",
              "aIdx": 0,
              "elements": [
                [
                  0,
                  85
                ]
              ]
            },
            {
              "text": "Das Ergebnis des Vergleichs bestimmt die neue noch zu durchsuchende Menge",
              "aIdx": 1,
              "elements": [
                [
                  87,
                  160
                ]
              ]
            }
          ]
        }
      ],
      "studentAnswers": [
        {
          "text": "die elemente müssen vorsortiert sein, es wird immer das mittlere element verglichen und dann in der entsprechenden hälfte weitergesucht",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Die elemente müssen vorsortiert sein. Es wird immer das mittlere Element verglichen und dann in der entsprechenden Hälfte weitergesucht",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": "Es wird immer das mittlere Element verglichen",
              "elements": [],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Es wird ;; in der entsprechenden Hälfte weitergesucht",
              "elements": [],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Da das Array bei der binären Suche sortiert ist, wird dieses in zwei Hälften aufgeteilt und das Array so verkleinert, bis der gesuchte Wert gefunden ist. Hierbei kann natürlich auch der Anfang, das Ende oder die Mitte der gesuchte Wert sein.",
          "id": "4cfc3a1811fe40afa401b25ef7fa0379f1f7c1930a04f8755d678474",
          "correctionOrComment": "Da das Array bei der binären Suche sortiert ist, wird dieses in zwei Hälften aufgeteilt und das Array so verkleinert, bis der gesuchte Wert gefunden ist. Hierbei kann natürlich auch der Anfang, das Ende oder die Mitte der gesuchte Wert sein.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "wird dieses in zwei Hälften aufgeteilt und das Array so verkleinert",
              "elements": [
                [
                  49,
                  116
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Anders als bei der linearen Suche, wird hier das Intervall halbiert, sodass die Chance besteht das gesuchte Element schneller zu finden.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Anders als bei der linearen Suche, wird hier das Intervall halbiert, sodass die Chance besteht das gesuchte Element schneller zu finden.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "wird hier das Intervall halbiert",
              "elements": [
                [
                  35,
                  67
                ]
              ],
              "aIdx": 1,
              "label": 1
            }
          ]
        },
        {
          "text": "Ein vergleich Element wird ungefähr in der Mitte des Arrays bestimmt. Anschließend wird das gesuchte Element mit diesem verglichen und geguckt ob die Elemente gleich sind. Oder das gesuchte Element kleiner oder größer ist. Ist der gesuchte Wert größer wird Start auf vergleich + 1 gesetzt. Ist der gesuchte Wert kleiner wird Ende auf vergeleich - 1 gesetzt. Dies wird so lange wiederholt bis das gesuchte Element gefunden wurde oder Start > Ende.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Ein vergleich Element wird ungefähr in der Mitte des Arrays bestimmt. Anschließend wird das gesuchte Element mit diesem verglichen und geguckt ob die Elemente gleich sind. Oder das gesuchte Element kleiner oder größer ist. Ist der gesuchte Wert größer wird Start auf Vergleich + 1 gesetzt. Ist der gesuchte Wert kleiner wird Ende auf Vergleich - 1 gesetzt. Dies wird so lange wiederholt bis das gesuchte Element gefunden wurde oder Start > Ende.",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": "Ein vergleich Element wird ungefähr in der Mitte des Arrays bestimmt. Anschließend wird das gesuchte Element mit diesem verglichen",
              "elements": [
                [
                  0,
                  130
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Ist der gesuchte Wert größer wird Start auf Vergleich + 1 gesetzt. Ist der gesuchte Wert kleiner wird Ende auf Vergleich - 1 gesetzt",
              "elements": [],
              "aIdx": 1,
              "label": 1
            }
          ]
        },
        {
          "text": "Bei der Binären Suche betrachten wir drei Punkte im Array, Ende, Start und den Vergleichswert. Entspricht der vergleichswert dem gesuchten wird sein index ausgegeben. ist der vergleichswert größer wird er zum neuen Ende, wenn kleicher zum neuen start. so halbieren wir pro Runde die länge der zu durchlaufenden elemente",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Bei der Binären Suche betrachten wir drei Punkte im Array, Ende, Start und den Vergleichswert. Entspricht der Vergleichswert dem gesuchten wird sein index ausgegeben. ist der Vergleichswert größer wird er zum neuen Ende, wenn kleiner zum neuen Start. So halbieren wir pro Runde die länge der zu durchlaufenden Elemente",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": "So halbieren wir pro Runde die länge der zu durchlaufenden Elemente",
              "elements": [],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Es wird immer der mittlere Wert zwischen Start und Ende mit dem gesuchten Wert verglichen. Ist dieser größer, wird der Vergleichswert zum neuen Startwert, sonst zum Endwert.",
          "id": "7ba019a2553e1137a4bbb8d3c779a48e5ceb2ca3a162e6e0a945ef0f",
          "correctionOrComment": "Es wird immer der mittlere Wert zwischen Start und Ende mit dem gesuchten Wert verglichen. Ist dieser größer, wird der Vergleichswert zum neuen Startwert, sonst zum Endwert.",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": "Es wird immer der mittlere Wert zwischen Start und Ende mit dem gesuchten Wert verglichen",
              "elements": [
                [
                  0,
                  89
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "st dieser größer, wird der Vergleichswert zum neuen Startwert, sonst zum Endwert",
              "elements": [
                [
                  92,
                  172
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Bei der binären Suche liegt ein vorsortiertes Array vor. Man arbeitet mit einem Index Start und einem Index Ende. Das Element in der Mitte wird betrachtet. Ist es kleiner als gesucht, wird Ende auf den aktuellen Index gesetzt, ist es größer als gesucht, wird Start auf den aktuellen Index gesetzt.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Bei der binären Suche liegt ein vorsortiertes Array vor. Man arbeitet mit einem Index Start und einem Index Ende. Das Element in der Mitte wird betrachtet. Ist es kleiner als gesucht, wird Ende auf den aktuellen Index gesetzt, ist es größer als gesucht, wird Start auf den aktuellen Index gesetzt.",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": "Das Element in der Mitte wird betrachtet",
              "elements": [
                [
                  114,
                  154
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Ist es kleiner als gesucht, wird Ende auf den aktuellen Index gesetzt, ist es größer als gesucht, wird Start auf den aktuellen Index gesetzt",
              "elements": [
                [
                  156,
                  296
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Es wird ein start, ein ende und ein vergleichselement festgelegt. anschließend wird das gesuchte element mit dem vergleichselement verglichen. ist es das gesuchte element bricht die suche ab und die lösung wird ausgegeben. ist der verglichene wert größer als der gesuchte, wird ende = vergleich-1 gesetzt. ist der verglichene wert kleiner als der gesuchte wird start = x+1 gesetzt.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Es wird ein Start, ein Ende und ein Vergleichselement festgelegt. Anschließend wird das gesuchte Element mit dem vergleichselement verglichen. Ist es das gesuchte Element bricht die Suche ab und die Lösung wird ausgegeben. Ist der verglichene Wert größer als der Gesuchte, wird Ende = Vergleich-1 gesetzt. Ist der verglichene Wert kleiner als der gesuchte wird Start = x+1 gesetzt.",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": "Ist der verglichene Wert größer als der Gesuchte, wird Ende = Vergleich-1 gesetzt. Ist der verglichene Wert kleiner als der gesuchte wird Start = x+1 gesetzt.",
              "elements": [],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Das sortierte Array wird in zwei Teile aufgeteilt. Bei der Mitte wird geguckt, ob das gesuchte Element größer, kleiner oder gleich die Mitte ist. JE nach Antwort wird dann in diesem Teil des Arrays weiter gesucht.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Das sortierte Array wird in zwei Teile aufgeteilt. Bei der Mitte wird geguckt, ob das gesuchte Element größer, kleiner oder gleich die Mitte ist. Je nach Antwort wird dann in diesem Teil des Arrays weiter gesucht.",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": "Bei der Mitte wird geguckt, ob das gesuchte Element größer, kleiner oder gleich die Mitte ist",
              "elements": [
                [
                  51,
                  144
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Je nach Antwort wird dann in diesem Teil des Arrays weiter gesucht",
              "elements": [],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "das gesuchte gibt an, ob man in der hinteren oder vorderen hälfte des arrays sucht und so immer weiter",
          "id": "c1b8144ee1a30244a571c3d9b48b2c394a7489065d2565968f521645",
          "correctionOrComment": "das gesuchte gibt an, ob man in der hinteren oder vorderen hälfte des arrays sucht und so immer weiter",
          "answerCategory": "partially_correct",
          "aspects": []
        },
        {
          "text": "Bei der binären Suche wird der Array mittels der Indizes immer halbiert und das gesuchte Element mit dem Mittelwert verglichen. Ist es größer, sucht man nur in der zweiten Hälfte weiter, ist es kleiner, nur in der ersten.",
          "id": "0ce8152aa92136af039b687c01c7dccfcb271f3db2d0ddcb3cfdd3e6",
          "correctionOrComment": "Bei der binären Suche wird das Array mittels der Indizes immer halbiert und das gesuchte Element mit dem Mittelwert verglichen. Ist es größer, sucht man nur in der zweiten Hälfte weiter, ist es kleiner, nur in der ersten.",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": "Bei der binären Suche wird das Array mittels der Indizes immer halbiert und das gesuchte Element mit dem Mittelwert verglichen",
              "elements": [],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Ist es größer, sucht man nur in der zweiten Hälfte weiter, ist es kleiner, nur in der ersten",
              "elements": [
                [
                  128,
                  220
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Bei der binären Suche halbiert man den Bereich den man durchsucht jeden Schritt. Bei jedem Schritt wird überprüft, ob das aktuelle Element das gesuchte Element ist. Wenn nicht, schaut man ob es kleiner ist als das gesuchte Element. Falls es kleiner ist, setzt man den Suchbereich auf die obere Hälfte des Suchbereich, sonst auf die untere Hälfte.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "correctionOrComment": "Bei der binären Suche halbiert man den Bereich den man durchsucht jeden Schritt. Bei jedem Schritt wird überprüft, ob das aktuelle Element das gesuchte Element ist. Wenn nicht, schaut man ob es kleiner ist als das gesuchte Element. Falls es kleiner ist, setzt man den Suchbereich auf die obere Hälfte des Suchbereich, sonst auf die untere Hälfte.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Falls es kleiner ist, setzt man den Suchbereich auf die obere Hälfte des Suchbereich, sonst auf die untere Hälfte",
              "elements": [
                [
                  232,
                  345
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Die Menge an Zahlen muss sortiert sein, dann wird das mittlere Element betrachtet und mit der gesuchten Zahl verglichen. Wenn die Zahl gleich der gesuchten Zahl ist, ist das Programm fertig. Wenn die gesuchte Zahl größer ist, werden anschließend nur noch die Elemente rechts von der Mitte betrachtet, wenn die gesuchte Zahl kleiner ist nur noch die linke Hälfte. Dann wird das Verfahren für diese Teilarrays wiederholt.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Die Menge an Zahlen muss sortiert sein, dann wird das mittlere Element betrachtet und mit der gesuchten Zahl verglichen. Wenn die Zahl gleich der gesuchten Zahl ist, ist das Programm fertig. Wenn die gesuchte Zahl größer ist, werden anschließend nur noch die Elemente rechts von der Mitte betrachtet, wenn die gesuchte Zahl kleiner ist nur noch die linke Hälfte. Dann wird das Verfahren für diese Teilarrays wiederholt.",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": "dann wird das mittlere Element betrachtet und mit der gesuchten Zahl verglichen",
              "elements": [
                [
                  40,
                  119
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Wenn die gesuchte Zahl größer ist, werden anschließend nur noch die Elemente rechts von der Mitte betrachtet, wenn die gesuchte Zahl kleiner ist nur noch die linke Hälfte",
              "elements": [
                [
                  191,
                  361
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "bei der binären Suche wird das Array zunächst halbiert und das Element in der Mitte mit dem gesuchten verglichen. Ist das gesuchte Element größer als das Element Mitte wird im nächsten Schritt nur die zweite Hälfte des Arrays angeguckt, ist das gesuchte Element kleiner als das Element Mitte wird nur die vordere Hälfte des Arrays auf das gesuchte Element untersucht.  Dann wird das Teilarray wieder halbiert, die Mitte mit dem gesuchten Element verglichen und der Vorgang immer weiter wiederholt.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Bei der binären Suche wird das Array zunächst halbiert und das Element in der Mitte mit dem gesuchten verglichen. Ist das gesuchte Element größer als das Element Mitte wird im nächsten Schritt nur die zweite Hälfte des Arrays angeguckt, ist das gesuchte Element kleiner als das Element Mitte wird nur die vordere Hälfte des Arrays auf das gesuchte Element untersucht. Dann wird das Teilarray wieder halbiert, die Mitte mit dem gesuchten Element verglichen und der Vorgang immer weiter wiederholt.",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": "Bei der binären Suche wird das Array zunächst halbiert und das Element in der Mitte mit dem gesuchten verglichen",
              "elements": [],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Ist das gesuchte Element größer als das Element Mitte wird im nächsten Schritt nur die zweite Hälfte des Arrays angeguckt, ist das gesuchte Element kleiner als das Element Mitte wird nur die vordere Hälfte des Arrays auf das gesuchte Element untersucht.",
              "elements": [
                [
                  114,
                  367
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Bei der binären Suche ist es wichtig, dass die zu durchsuchende Menge vorsortiert ist. Diese wird in zwei Teile geteilt : Start bis Mitte und Mitte+1 bis Ende. Es wird nach und nach verglichen, ob der gesuchte Wert größer oder kleiner als die Mitte ist. Solange er kleiner ist, wird Ende auf Mitte gesetzt, wenn er größer ist wird Start auf Mitte gesetzt. Wenn er gleich dem Wert der Mitte ist, ist der Wert gefunden.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Bei der binären Suche ist es wichtig, dass die zu durchsuchende Menge vorsortiert ist. Diese wird in zwei Teile geteilt : Start bis Mitte und Mitte+1 bis Ende. Es wird nach und nach verglichen, ob der gesuchte Wert größer oder kleiner als die Mitte ist. Solange er kleiner ist, wird Ende auf Mitte gesetzt, wenn er größer ist wird Start auf Mitte gesetzt. Wenn er gleich dem Wert der Mitte ist, ist der Wert gefunden.",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": "Es wird nach und nach verglichen, ob der gesuchte Wert größer oder kleiner als die Mitte ist",
              "elements": [
                [
                  160,
                  252
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Solange er kleiner ist, wird Ende auf Mitte gesetzt, wenn er größer ist wird Start auf Mitte gesetzt",
              "elements": [
                [
                  254,
                  354
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "In einem Sortierten Datensatz grenzen wir nach und nach den Bereich ein in dem das gesuchte element liegen kann. Ein vergleichselement auf der hälfte des infrage kommenden Bereichs wird mit dem dem gesuchten element verglichen. wenn das gesuchte element größer als das vergleichselement ist, liegt es zwischen vergleich und ende, sonst zwischen start und ende!",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "In einem Sortierten Datensatz grenzen wir nach und nach den Bereich ein in dem das gesuchte Element liegen kann. Ein Vergleichselement auf der Hälfte des infrage kommenden Bereichs wird mit dem dem gesuchten Element verglichen. Wenn das gesuchte Element größer als das Vergleichselement ist, liegt es zwischen Vergleich und Ende, sonst zwischen Start und Ende!",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Ein Vergleichselement auf der Hälfte des infrage kommenden Bereichs wird mit dem dem gesuchten Element verglichen",
              "elements": [],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Wenn das gesuchte Element größer als das Vergleichselement ist, liegt es zwischen Vergleich und Ende, sonst zwischen Start und Ende",
              "elements": [],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Es wird in der Mitte begonnen und immer geschaut, ob das gesuchte Element kleiner oder größer ist. Solange bis ende < start oder gesucht gefunden wurde.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Es wird in der Mitte begonnen und immer geschaut, ob das gesuchte Element kleiner oder größer ist. Solange bis ende < start oder gesucht gefunden wurde.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Es wird in der Mitte begonnen und immer geschaut, ob das gesuchte Element kleiner oder größer ist",
              "elements": [
                [
                  0,
                  97
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "Die aufsteigend vorsortierte durchsuchende Menge wird halbiert, das Element in der Mitte wird mit dem gesuchten Wert verglichen, wenn entspricht, dann sind wir fertig, wenn nicht und das gesuchte Element größer ist, suchen wir in der oberen Häfte, sonst in der unteren. Usw. bis wir finden oder nicht finden (die duchsuchende Hälfte ist leer).",
          "id": "408f0afbe2440a4383a1e75b7d5b0b4202c7f7131a9acf9bd70492f3",
          "correctionOrComment": "Die aufsteigend vorsortierte durchsuchende Menge wird halbiert, das Element in der Mitte wird mit dem gesuchten Wert verglichen, wenn entspricht, dann sind wir fertig, wenn nicht und das gesuchte Element größer ist, suchen wir in der oberen Häfte, sonst in der unteren, bis wir finden oder nicht finden (die duchsuchende Hälfte ist leer).",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": "das Element in der Mitte wird mit dem gesuchten Wert verglichen",
              "elements": [
                [
                  64,
                  127
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "wenn nicht und das gesuchte Element größer ist, suchen wir in der oberen Häfte, sonst in der unteren",
              "elements": [
                [
                  168,
                  268
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "immer wieder halbieren des suchbereiches und links und recht davon wird geschaut",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Immer wieder halbieren des Suchbereiches und links und recht davon wird geschaut",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Immer wieder halbieren des Suchbereiches",
              "elements": [],
              "aIdx": 1,
              "label": 1
            }
          ]
        },
        {
          "text": "Es wird zunächst sortiert und anschließend in Abschnitte geteilt, bei denen verglichen wird, ob das gesuchte Element größer oder kleiner als das Vergleichselement ist. Je nachdem geht der Algorithmus links (wenn kleiner) oder rechts (wenn größer) weiter oder beendet, wenn das gesuchte Element gefunden wurde",
          "id": "271f93f45e9b4067327ed5c8cd30a034730aaace4382803c3e1d6c2f",
          "correctionOrComment": "Es wird zunächst sortiert und anschließend in Abschnitte geteilt, bei denen verglichen wird, ob das gesuchte Element größer oder kleiner als das Vergleichselement ist. Je nachdem geht der Algorithmus links (wenn kleiner) oder rechts (wenn größer) weiter oder beendet, wenn das gesuchte Element gefunden wurde",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Je nachdem geht der Algorithmus links (wenn kleiner) oder rechts (wenn größer) weiter oder beendet, wenn das gesuchte Element gefunden wurde",
              "elements": [
                [
                  168,
                  308
                ]
              ],
              "aIdx": 1,
              "label": 1
            }
          ]
        },
        {
          "text": "das zu durchsuchende (sortierte) Array wird in der Mitte geteilt. In jedem Schritt wird entschieden, ob die gesuchte Zahl (wenn die in dem Array enthalten ist) in der rechten oder linken Seite sein muss. So wird das zu durchsuchende Teilstück des Arrays immer halbiert.",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c",
          "correctionOrComment": "Das zu durchsuchende (sortierte) Array wird in der Mitte geteilt. In jedem Schritt wird entschieden, ob die gesuchte Zahl (wenn die in dem Array enthalten ist) in der rechten oder linken Seite sein muss. So wird das zu durchsuchende Teilstück des Arrays immer halbiert.",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": "So wird das zu durchsuchende Teilstück des Arrays immer halbiert",
              "elements": [
                [
                  204,
                  268
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Die binäre Suche funktioniert nur bei einer sortierten Menge an Elementen. Bei jedem Durchgang wird ein Vergleichselement aus der Mitte herausgepickt und mit dem gesuchten Element verglichen.  Es werden drei Fälle unterschieden:  Stimmt das Vergleichselement mit dem gesuchten überein, wird die Schleife beendet. Ist das gesuchte Element kleiner als das Vergleichselement, wird nun der bisherige Vorgang im Bereich links neben dem Vergleichselement durchgeführt. Ist das gesuchte Element größer als das Vergleichselement, wird der bisherige Vorgang im Bereich rechts neben dem Vergleichselement durchgeführt.  Die letzten beiden Fälle werden so oft durchgeführt, bis das gesuchte Element mit dem Vergleichselement übereinstimmt.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6",
          "correctionOrComment": "Die binäre Suche funktioniert nur bei einer sortierten Menge an Elementen. Bei jedem Durchgang wird ein Vergleichselement aus der Mitte herausgepickt und mit dem gesuchten Element verglichen. Es werden drei Fälle unterschieden: Stimmt das Vergleichselement mit dem gesuchten überein, wird die Schleife beendet. Ist das gesuchte Element kleiner als das Vergleichselement, wird nun der bisherige Vorgang im Bereich links neben dem Vergleichselement durchgeführt. Ist das gesuchte Element größer als das Vergleichselement, wird der bisherige Vorgang im Bereich rechts neben dem Vergleichselement durchgeführt. Die letzten beiden Fälle werden so oft durchgeführt, bis das gesuchte Element mit dem Vergleichselement übereinstimmt.",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": "Bei jedem Durchgang wird ein Vergleichselement aus der Mitte herausgepickt und mit dem gesuchten Element verglichen",
              "elements": [
                [
                  75,
                  190
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "st das gesuchte Element kleiner als das Vergleichselement, wird nun der bisherige Vorgang im Bereich links neben dem Vergleichselement durchgeführt. Ist das gesuchte Element größer als das Vergleichselement, wird der bisherige Vorgang im Bereich rechts neben dem Vergleichselement durchgeführt",
              "elements": [
                [
                  312,
                  605
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Ein vorsortierter Array. Mittleres Element wird mit gesuchten Element verglichen. Ist das gesuchte Element größer, wird das Mittlerem Element zu Ende",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Ein vorsortierter Array. Mittleres Element wird mit gesuchten Element verglichen. Ist das gesuchte Element größer, wird das Mittlerem Element zu Ende",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Mittleres Element wird mit gesuchten Element verglichen",
              "elements": [
                [
                  25,
                  80
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "Man teilt die Menge der zu durchsuchenden Menge an Daten in einen Teil, der größer und einen der kleiner als das geuchte Element ist ein. Dann entscheidet man sich in welchen der beiden Teile weitergesucht wird - so lange bis man es gefunden hat, oder man keine zu durchsuchenden Element mehr hat. Dafür muss eben diese Menge bereits vorsortiert sein oder irgendwie gewichtbar sein.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6",
          "correctionOrComment": "Man teilt die Menge der zu durchsuchenden Menge an Daten in einen Teil, der größer und einen der kleiner als das geuchte Element ist ein. Dann entscheidet man sich in welchen der beiden Teile weitergesucht wird - so lange bis man es gefunden hat, oder man keine zu durchsuchenden Element mehr hat. Dafür muss eben diese Menge bereits vorsortiert sein oder irgendwie gewichtbar sein.",
          "answerCategory": "missconception",
          "aspects": []
        },
        {
          "text": "Man schaut sich den mittleren Wert einer sortierten (Teil-)Menge an und prüft, ob das der gesuchte Wert ist. Falls ja hat man ihn gefunden. Falls nicht, dann wiederholt man den Schritt in der Teilmenge mit den kleineren Einträgen, falls der gesuchte Wert kleiner als der geprüfte Wert ist und sonst in der Teilmenge mit den größeren Einträgen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Man schaut sich den mittleren Wert einer sortierten (Teil-)Menge an und prüft, ob das der gesuchte Wert ist. Falls ja hat man ihn gefunden. Falls nicht, dann wiederholt man den Schritt in der Teilmenge mit den kleineren Einträgen, falls der gesuchte Wert kleiner als der geprüfte Wert ist und sonst in der Teilmenge mit den größeren Einträgen.",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": "Man schaut sich den mittleren Wert einer sortierten (Teil-)Menge an und prüft, ob das der gesuchte Wert ist",
              "elements": [
                [
                  0,
                  107
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Falls nicht, dann wiederholt man den Schritt in der Teilmenge mit den kleineren Einträgen, falls der gesuchte Wert kleiner als der geprüfte Wert ist und sonst in der Teilmenge mit den größeren Einträgen",
              "elements": [
                [
                  140,
                  342
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Das Array wird vorsortiert. Das gesuchte Element wird mit dem Mittleren Element verglichen, Suchbereich wird verändert, je nachdem ob gesuchtes Element größer oder kleiner ist als Mitte",
          "id": "53750c72b7bb26cb6ff7115e383ca150d5a632a909a7f79e2f5274a4",
          "correctionOrComment": "Das Array wird vorsortiert. Das gesuchte Element wird mit dem Mittleren Element verglichen, Suchbereich wird verändert, je nachdem ob gesuchtes Element größer oder kleiner ist als Mitte",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": "Das gesuchte Element wird mit dem Mittleren Element verglichen",
              "elements": [
                [
                  28,
                  90
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Suchbereich wird verändert, je nachdem ob gesuchtes Element größer oder kleiner ist als Mitte",
              "elements": [
                [
                  92,
                  185
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Das zu suchende Element wird mit dem mittleren Element des sortierten Datensatzes verglichen. Ist es größer, wird das mittlere Element zur linken, ist es kleiner zur rechten Grenze des neuen zu durchsuchenden Intervalls.",
          "id": "8416c38cc898f1ac7cc9d64e89dab1f70f5ddab002a5b2a1713f93f5",
          "correctionOrComment": "Das zu suchende Element wird mit dem mittleren Element des sortierten Datensatzes verglichen. Ist es größer, wird das mittlere Element zur linken, ist es kleiner zur rechten Grenze des neuen zu durchsuchenden Intervalls.",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": "as zu suchende Element wird mit dem mittleren Element des sortierten Datensatzes verglichen",
              "elements": [
                [
                  1,
                  92
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": " Ist es größer, wird das mittlere Element zur linken, ist es kleiner zur rechten Grenze des neuen zu durchsuchenden Intervalls",
              "elements": [
                [
                  94,
                  219
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "h",
          "id": "192f56eb9bd894a72b30c303247b107be2c4591f310dd69a67927f48",
          "correctionOrComment": "h",
          "answerCategory": "none",
          "aspects": []
        },
        {
          "text": "Bei der Binären Suche wird nicht linear vorgegangen, sondern das Array immer geschickt aufgeteilt, sodass die Laufzeit gegenüber der linearen Suche verbessert werden kann.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "correctionOrComment": "Bei der Binären Suche wird nicht linear vorgegangen, sondern das Array immer geschickt aufgeteilt, sodass die Laufzeit gegenüber der linearen Suche verbessert werden kann.",
          "answerCategory": "partially_correct",
          "aspects": []
        },
        {
          "text": "Die binäre Suche läuft auf einem sortierten Array. Hier wird ein Vergleichswert mit dem gesuchten ELement verglichen. Je nach Resultat, kann das Element als gefunden angesehen, bzw. der Suchbereich verkürzt (meist halbiert) werden. Nach einer Endlichen Zahl von Halbierungen(Ologn) und Vergleichen wird klar, ob das Element enthalten ist, oder nicht.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "correctionOrComment": "Die binäre Suche läuft auf einem sortierten Array. Hier wird ein Vergleichswert mit dem gesuchten ELement verglichen. Je nach Resultat, kann das Element als gefunden angesehen, bzw. der Suchbereich verkürzt (meist halbiert) werden. Nach einer Endlichen Zahl von Halbierungen(Ologn) und Vergleichen wird klar, ob das Element enthalten ist, oder nicht.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Hier wird ein Vergleichswert mit dem gesuchten ELement verglichen. Je nach Resultat, kann das Element als gefunden angesehen, bzw. der Suchbereich verkürzt (meist halbiert) werden",
              "elements": [
                [
                  51,
                  230
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Ich habe ein Element Gesucht. Ich habe Start und Ende des Datensatzes.  Ich halbiere den Datensatz. Ich erhalte das Element Vergleich. Ich Vergleiche Vergleich mit Gesucht, ist das Element gefunden gebe ich es zurück. Je nachdem ob Gesucht größer oder kleiner Vergleich ist, suche ich in der obere oder unteren hälfte des Datensatzes weiter.  Die wiederhole ich, bis gesucht gefunden ist, oder Start > Ende.",
          "id": "b51d18b551043c1f145f22dbde6f8531faeaf68c54ed9dd79ce24d17",
          "correctionOrComment": "Ich habe ein Element Gesucht. Ich habe Start und Ende des Datensatzes. Ich halbiere den Datensatz. Ich erhalte das Element Vergleich. Ich Vergleiche Vergleich mit Gesucht, ist das Element gefunden gebe ich es zurück. Je nachdem ob Gesucht größer oder kleiner Vergleich ist, suche ich in der obere oder unteren hälfte des Datensatzes weiter. Die wiederhole ich, bis gesucht gefunden ist, oder Start > Ende.",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": " Ich halbiere den Datensatz. Ich erhalte das Element Vergleich. Ich Vergleiche Vergleich mit Gesucht",
              "elements": [
                [
                  71,
                  170
                ]
              ],
              "aIdx": 0,
              "label": 1
            },
            {
              "text": "Je nachdem ob Gesucht größer oder kleiner Vergleich ist, suche ich in der obere oder unteren hälfte des Datensatzes weiter",
              "elements": [
                [
                  217,
                  339
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Die binäre Suche wird in einem sortierten Datensatz durchgeführt. Es wird geprüft, ob das gesuchte Element gefunden wurde. Dazu wird zuerst das mittlere Element des Intervalls mit dem gesuchten Element verglichen. Wenn es nicht das gesuchte Element ist, wird geprüft, ob das gesuchte Element kleiner oder größer als das mittlere Element ist. Ist es kleiner, wird ende=vergleich gesetzt, ist es größer wird start=vergleich gesetzt. Es wird also jeweils in der entsprechenden Hälfte des Intervalls weitergesucht und dort erneut anhand des mittleren Wertes verglichen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Die binäre Suche wird in einem sortierten Datensatz durchgeführt. Es wird geprüft, ob das gesuchte Element gefunden wurde. Dazu wird zuerst das mittlere Element des Intervalls mit dem gesuchten Element verglichen. Wenn es nicht das gesuchte Element ist, wird geprüft, ob das gesuchte Element kleiner oder größer als das mittlere Element ist. Ist es kleiner, wird ende=vergleich gesetzt, ist es größer wird start=vergleich gesetzt. Es wird also jeweils in der entsprechenden Hälfte des Intervalls weitergesucht und dort erneut anhand des mittleren Wertes verglichen.",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": "Dazu wird zuerst das mittlere Element des Intervalls mit dem gesuchten Element verglichen",
              "elements": [
                [
                  123,
                  212
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Wenn es nicht das gesuchte Element ist, wird geprüft, ob das gesuchte Element kleiner oder größer als das mittlere Element ist. Ist es kleiner, wird ende=vergleich gesetzt, ist es größer wird start=vergleich gesetzt. Es wird also jeweils in der entsprechenden Hälfte des Intervalls weitergesucht und dort erneut anhand des mittleren Wertes verglichen",
              "elements": [
                [
                  214,
                  564
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Die binäre Suche sucht in einem sortierten Array. Sie beginnt in der Mitte (start+ende\\/2) und prüft, ob das aktuelle Element gleich, größer oder kleiner als das gesuchte ist. Entsprechend werden start oder ende neu gesetzte und die Suche nur in der entsprechenden Hälfte weiterdurchgeführt.",
          "id": "f09265efb456b0336079ad5b238daa1e38a11b1d71cc0e1a4e8edd56",
          "correctionOrComment": "Die binäre Suche sucht in einem sortierten Array. Sie beginnt in der Mitte (start+ende\\/2) und prüft, ob das aktuelle Element gleich, größer oder kleiner als das gesuchte ist. Entsprechend werden start oder ende neu gesetzte und die Suche nur in der entsprechenden Hälfte weiterdurchgeführt.",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": "Sie beginnt in der Mitte (start+ende\\/2) und prüft, ob das aktuelle Element gleich, größer oder kleiner als das gesuchte ist",
              "elements": [
                [
                  50,
                  174
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Entsprechend werden start oder ende neu gesetzte und die Suche nur in der entsprechenden Hälfte weiterdurchgeführt",
              "elements": [
                [
                  176,
                  290
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "bei der binären Suche wird der Suchbereich in einem geordneten Array in zwei bereiche aufgeteilt und je nachdem ob der Wert kleiner ist als der mittlere Wert des sortierten Arrays dann links oder rechts von dem Vergleichsindex weiter gesucht. Dann werden die Start und End indizies angepasst und das selbe nochmal durchgeführt.",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c",
          "correctionOrComment": "Bei der binären Suche wird der Suchbereich in einem geordneten Array in zwei bereiche aufgeteilt und je nachdem ob der Wert kleiner ist als der mittlere Wert des sortierten Arrays dann links oder rechts von dem Vergleichsindex weiter gesucht. Dann werden die Start und End indizies angepasst und das selbe nochmal durchgeführt.",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": "je nachdem ob der Wert kleiner ist als der mittlere Wert des sortierten Arrays dann links oder rechts von dem Vergleichsindex weiter gesucht",
              "elements": [
                [
                  101,
                  241
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "je nachdem ob der Wert kleiner ist als der mittlere Wert des sortierten Arrays dann links oder rechts von dem Vergleichsindex weiter gesucht",
              "elements": [
                [
                  101,
                  241
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Es wird immer in die hälfte geteilt & dann geguckt ob es größer oder kleiner ist & dann wieder das gleiche",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Es wird immer in die Hälfte geteilt & dann geguckt ob es größer oder kleiner ist & dann wieder das gleiche",
          "answerCategory": "partially_correct",
          "aspects": []
        },
        {
          "text": "Es wird jeweils nur das mittlere Element mit dem gesuchten Element verglichen. Je nachdem ob es größer oder kleiner ist, bildet es die neue vordere oder hintere Intervallsgrenze.",
          "id": "b8607e0369fbf3e33bc0e358f840915d8c085d1496097351913c0122",
          "correctionOrComment": "Es wird jeweils nur das mittlere Element mit dem gesuchten Element verglichen. Je nachdem ob es größer oder kleiner ist, bildet es die neue vordere oder hintere Intervallsgrenze.",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": "je nachdem ob der Wert kleiner ist als der mittlere Wert des sortierten Arrays dann links oder rechts von dem Vergleichsindex weiter gesucht",
              "elements": [],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Je nachdem ob es größer oder kleiner ist, bildet es die neue vordere oder hintere Intervallsgrenze",
              "elements": [
                [
                  79,
                  177
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Immer das mittlere Elemente wird mit dem gesuchten Element verglichen, entsprechend des Verhältnisses des gesuchten zur Mitte wird danach nur eine der Hälften betrachtet",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Immer das mittlere Elemente wird mit dem gesuchten Element verglichen, entsprechend des Verhältnisses des gesuchten zur Mitte wird danach nur eine der Hälften betrachtet",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": "Immer das mittlere Elemente wird mit dem gesuchten Element verglichen",
              "elements": [
                [
                  0,
                  69
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "entsprechend des Verhältnisses des gesuchten zur Mitte wird danach nur eine der Hälften betrachtet",
              "elements": [
                [
                  71,
                  169
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        }
      ]
    },
    {
      "text": "Was gehört zu der Signatur einer Operation in Java?",
      "id": 50809,
      "title": "Signatur in Java",
      "type": "definition",
      "aspects": [
        {
          "text": "der Name"
        },
        {
          "text": "die Parameter",
          "implied": true
        },
        {
          "text": "die Parameterzahl und Reihenfolge der Typen"
        }
      ],
      "referenceAnswers": [
        {
          "text": "Zur Signatur gehören der Name und die Parameter, insbesondere die Parameterzahl und Reihenfolge der Typen.",
          "aspects": [
            {
              "text": "Zur Signatur gehören der Name",
              "aIdx": 0,
              "elements": [
                [
                  0,
                  29
                ]
              ]
            },
            {
              "text": "Zur Signatur gehören ;; die Parameter",
              "aIdx": 1,
              "elements": [
                [
                  0,
                  20
                ],
                [
                  34,
                  47
                ]
              ],
              "implied": true
            },
            {
              "text": "Zur Signatur gehören ;; insbesondere die Parameterzahl und Reihenfolge der Typen",
              "aIdx": 2,
              "elements": [
                [
                  0,
                  20
                ],
                [
                  49,
                  105
                ]
              ]
            }
          ]
        }
      ],
      "studentAnswers": [
        {
          "text": "Ein Methodenkopf",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Ein Methodenkopf",
          "answerCategory": "irrelevant",
          "aspects": []
        },
        {
          "text": "Der Name der Operation, Anzahl und Typ ihrer Parameter.",
          "id": "4cfc3a1811fe40afa401b25ef7fa0379f1f7c1930a04f8755d678474",
          "correctionOrComment": "Dazu gehören der Name der Operation und Anzahl und Typ ihrer Parameter.",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": "Dazu gehören der Name der Operation",
              "elements": [],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Dazu gehören ;; Anzahl und Typ ihrer Parameter",
              "elements": [
                [
                  24,
                  54
                ]
              ],
              "aIdx": 2,
              "label": 0
            }
          ]
        },
        {
          "text": "Name der Operation, Parameter und Rückgabetyp.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Name der Operation, Parameter und Rückgabetyp.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Name der Operation",
              "elements": [
                [
                  0,
                  18
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Parameter",
              "elements": [
                [
                  20,
                  29
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Der Name und die Übergabeparameter.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Der Name und die Übergabeparameter.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Der Name",
              "elements": [
                [
                  0,
                  8
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "die Übergabeparameter",
              "elements": [
                [
                  13,
                  34
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Rückgabewert, Methodenname, Parameter",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Rückgabewert, Methodenname, Parameter",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Methodenname",
              "elements": [
                [
                  14,
                  26
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Parameter",
              "elements": [
                [
                  28,
                  37
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Public oder private, die übergebenen Argumente und zurückgegebener Datentyp oder void.",
          "id": "7ba019a2553e1137a4bbb8d3c779a48e5ceb2ca3a162e6e0a945ef0f",
          "correctionOrComment": "Public oder private, die übergebenen Argumente und zurückgegebener Datentyp oder void.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": " die übergebenen Argumente",
              "elements": [
                [
                  21,
                  46
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Der Rückgabewert, die Sichtbarkeit und der Name.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Der Rückgabewert, die Sichtbarkeit und der Name.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "der Name",
              "elements": [
                [
                  39,
                  47
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "lol",
          "id": "c1b8144ee1a30244a571c3d9b48b2c394a7489065d2565968f521645",
          "correctionOrComment": "lol",
          "answerCategory": "none",
          "aspects": []
        },
        {
          "text": "Die Sichtweise (public, private, protected etc).",
          "id": "0ce8152aa92136af039b687c01c7dccfcb271f3db2d0ddcb3cfdd3e6",
          "correctionOrComment": "Die Sichtweise (public, private, protected etc).",
          "answerCategory": "missconception",
          "aspects": []
        },
        {
          "text": "Die Rückgabe und Eingabe der Operation.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "correctionOrComment": "Die Rückgabe und Eingabe der Operation.",
          "answerCategory": "missconception",
          "aspects": [
            {
              "text": "Die ;; Eingabe der Operation",
              "elements": [
                [
                  0,
                  3
                ],
                [
                  17,
                  38
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Der Rückgabetyp, der Operationsname und die übergebenen Parameter.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Der Rückgabetyp, der Operationsname und die übergebenen Parameter.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "der Operationsname",
              "elements": [
                [
                  17,
                  35
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "die übergebenen Parameter",
              "elements": [
                [
                  40,
                  65
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "In die Signatur einer Operation gehören Name der Operation, Rückgabetyp und die Parameter, die der Operation übergeben werden sollen",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "In die Signatur einer Operation gehören Name der Operation, Rückgabetyp und die Parameter, die der Operation übergeben werden sollen",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "In die Signatur einer Operation gehören Name der Operation",
              "elements": [
                [
                  0,
                  58
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "die Parameter, die der Operation übergeben werden soll",
              "elements": [
                [
                  76,
                  130
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Öffentlichkeit \\/ statisch? \\/ Rückgabewert \\/ Name \\/ Parameter",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Öffentlichkeit, statisch?, Rückgabewert, Name, Parameter",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Name",
              "elements": [
                [
                  47,
                  51
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Parameter",
              "elements": [
                [
                  55,
                  64
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Name, Parameter.",
          "id": "408f0afbe2440a4383a1e75b7d5b0b4202c7f7131a9acf9bd70492f3",
          "correctionOrComment": "Name, Parameter.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Name",
              "elements": [
                [
                  0,
                  4
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Parameter",
              "elements": [
                [
                  6,
                  15
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "public private protected void dateneingabe",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "public private protected void dateneingabe",
          "answerCategory": "irrelevant",
          "aspects": [
            {
              "text": "dateneingabe",
              "elements": [
                [
                  30,
                  42
                ]
              ],
              "aIdx": 1,
              "label": 1
            }
          ]
        },
        {
          "text": "Um die Operation dem Aufruf zuordnen zu können",
          "id": "271f93f45e9b4067327ed5c8cd30a034730aaace4382803c3e1d6c2f",
          "correctionOrComment": "Um die Operation dem Aufruf zuordnen zu können",
          "answerCategory": "irrelevant",
          "aspects": []
        },
        {
          "text": "Sichtbarkeit, Rückgabewert, name (parameter)",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Sichtbarkeit, Rückgabewert, Name, Parameter",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Name",
              "elements": [],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Parameter",
              "elements": [],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Ein Methodenkopf, sowie Methodenrumpf. Im Methodenkopf steht der Name, der Operation, der Rückgabetyp, die zu übergebenen Parameter und die Sichtbarkeit.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6",
          "correctionOrComment": "Ein Methodenkopf, sowie Methodenrumpf. Im Methodenkopf steht der Name, der Operation, der Rückgabetyp, die zu übergebenen Parameter und die Sichtbarkeit.",
          "answerCategory": "missconception",
          "aspects": [
            {
              "text": "Im Methodenkopf steht der Name, der Operation ",
              "elements": [
                [
                  39,
                  84
                ]
              ],
              "aIdx": 0,
              "label": 1
            },
            {
              "text": " Im Methodenkopf steht ;; die zu übergebenen Parameter",
              "elements": [
                [
                  39,
                  60
                ],
                [
                  103,
                  131
                ]
              ],
              "aIdx": 1,
              "label": 1
            }
          ]
        },
        {
          "text": "Funktionsname und deren Parameter. Nicht der Rückgabewert.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6",
          "correctionOrComment": "Funktionsname und deren Parameter. Nicht der Rückgabewert.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Funktionsname",
              "elements": [
                [
                  0,
                  13
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "deren Parameter",
              "elements": [
                [
                  18,
                  33
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Der Name der Operation und ihre Parameter.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Der Name der Operation und ihre Parameter.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Der Name der Operation",
              "elements": [
                [
                  0,
                  22
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "ihre Parameter",
              "elements": [
                [
                  27,
                  41
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "public <Rückgabetyp> <Name der Klasse> (PArameter)",
          "id": "53750c72b7bb26cb6ff7115e383ca150d5a632a909a7f79e2f5274a4",
          "correctionOrComment": "public, Rückgabetyp, Name der Klasse, Parameter",
          "answerCategory": "irrelevant",
          "aspects": [
            {
              "text": "Name der Klasse",
              "elements": [
                [
                  22,
                  37
                ]
              ],
              "aIdx": 0,
              "label": 2
            },
            {
              "text": "Parameter",
              "elements": [],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Sichtbarkeit, Rückgabewert, Name",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Sichtbarkeit, Rückgabewert, Name",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Name",
              "elements": [
                [
                  28,
                  32
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "Sichtbarkeits dekalration: public, private, protected Wiedergabe Wert: void, Object, boolean etc. Name ggf: Parameter ggf static",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Sichtbarkeits dekalration: public, private, protected Wiedergabe Wert: void, Object, boolean etc. Name ggf: Parameter ggf static",
          "answerCategory": "irrelevant",
          "aspects": [
            {
              "text": "Name",
              "elements": [
                [
                  98,
                  102
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Parameter",
              "elements": [
                [
                  108,
                  117
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Der Kopf mit Rückgabeart und Parametern und der Rumpf mit dem Algorythmus",
          "id": "8416c38cc898f1ac7cc9d64e89dab1f70f5ddab002a5b2a1713f93f5",
          "correctionOrComment": "Der Kopf mit Rückgabeart und Parametern und der Rumpf mit dem Algorithmus",
          "answerCategory": "missconception",
          "aspects": [
            {
              "text": "Der Kopf mit ;; Parametern",
              "elements": [
                [
                  0,
                  12
                ],
                [
                  29,
                  39
                ]
              ],
              "aIdx": 1,
              "label": 1
            }
          ]
        },
        {
          "text": "nnb",
          "id": "192f56eb9bd894a72b30c303247b107be2c4591f310dd69a67927f48",
          "correctionOrComment": "nnb",
          "answerCategory": "none",
          "aspects": []
        },
        {
          "text": "Rückgabewert + Methodenname + zu übergebene Parameter",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "correctionOrComment": "Rückgabewert, Methodenname, zu übergebene Parameter",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Methodenname",
              "elements": [
                [
                  15,
                  27
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "zu übergebene Parameter",
              "elements": [
                [
                  30,
                  53
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "In Java umfasst die Signatur Operationsname und Parameter.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "correctionOrComment": "In Java umfasst die Signatur Operationsname und Parameter.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "In Java umfasst die Signatur Operationsname",
              "elements": [
                [
                  0,
                  43
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "In Java umfasst die Signatur ;; Parameter",
              "elements": [
                [
                  0,
                  28
                ],
                [
                  48,
                  57
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Name, Parameter und Rückgabetyp",
          "id": "b51d18b551043c1f145f22dbde6f8531faeaf68c54ed9dd79ce24d17",
          "correctionOrComment": "Name, Parameter und Rückgabetyp",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Name",
              "elements": [
                [
                  0,
                  4
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Parameter",
              "elements": [
                [
                  6,
                  15
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ]
        },
        {
          "text": "Sichtbarkeit, Rückgabetyp, Name, evtl. Übergabewerte",
          "id": "f09265efb456b0336079ad5b238daa1e38a11b1d71cc0e1a4e8edd56",
          "correctionOrComment": "Sichtbarkeit, Rückgabetyp, Name, evtl. Übergabewerte",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Name",
              "elements": [
                [
                  27,
                  31
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Übergabewerte",
              "elements": [
                [
                  39,
                  52
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "ein Funktionskopf (Rückgabewert Name und ggf. Übergabeparameter) und ein Funktionsrumpf die Ansammlung von Anweisungen.",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c",
          "correctionOrComment": "ein Funktionskopf mit Rückgabewert, Name und Übergabeparameter und ein Funktionsrumpf die Ansammlung von Anweisungen.",
          "answerCategory": "missconception",
          "aspects": [
            {
              "text": "ein Funktionskopf mit ;; Name ",
              "elements": [
                [
                  32,
                  36
                ]
              ],
              "aIdx": 0,
              "label": 1
            },
            {
              "text": "ein Funktionskopf mit ;; Übergabeparameter",
              "elements": [
                [
                  46,
                  63
                ]
              ],
              "aIdx": 1,
              "label": 1
            }
          ]
        },
        {
          "text": "Rückgabewert, Parameter und Datentyp",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Rückgabewert, Parameter und Datentyp",
          "answerCategory": "binary_correct",
          "aspects": [
            {
              "text": "Parameter",
              "elements": [
                [
                  14,
                  23
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "Datentyp",
              "elements": [
                [
                  28,
                  36
                ]
              ],
              "aIdx": 2,
              "label": 1
            }
          ]
        },
        {
          "text": "Rückgabe, Parameter",
          "id": "ae8820303e493738a211ebb2ae3a2f90b286f20f767609beb77522c0",
          "correctionOrComment": "Rückgabe, Parameter",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Parameter",
              "elements": [
                [
                  10,
                  19
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Der Name und der\\/die Parameter.",
          "id": "b8607e0369fbf3e33bc0e358f840915d8c085d1496097351913c0122",
          "correctionOrComment": "Der Name und die Parameter.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Der Name",
              "elements": [
                [
                  0,
                  8
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "die Parameter",
              "elements": [
                [
                  18,
                  31
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Rückgabetyp, Name und Variablen, die übergeben werden",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c",
          "correctionOrComment": "Rückgabetyp, Name und Variablen, die Übergeben werden",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Name",
              "elements": [
                [
                  13,
                  17
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Variablen, die Übergeben werden",
              "elements": [],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Der Rückgabetyp einer Methode, der Name der Operation und möglichweise noch die Werte die der Operation beim Aufruf übergeben wird.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Der Rückgabetyp einer Methode, der Name der Operation und möglichweise noch die Werte die der Operation beim Aufruf übergeben wird.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "der Name der Operation",
              "elements": [
                [
                  31,
                  53
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "möglichweise noch die Werte die der Operation beim Aufruf übergeben wird",
              "elements": [
                [
                  58,
                  130
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "Name und Parameter.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Name und Parameter.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "Name",
              "elements": [
                [
                  0,
                  4
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Parameter",
              "elements": [
                [
                  9,
                  18
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        },
        {
          "text": "name, anzahl, typ der Parameter",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Name, Anzahl und Typ der Parameter",
          "answerCategory": "correct",
          "aspects": [
            {
              "text": "Name",
              "elements": [],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Anzahl und Typ der Parameter",
              "elements": [],
              "aIdx": 2,
              "label": 0
            }
          ]
        },
        {
          "text": "Es gehört die Sichtbarkeit, der Rückgabetyp, der Name und die Parameter dazu.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Es gehört die Sichtbarkeit, der Rückgabetyp, der Name und die Parameter dazu.",
          "answerCategory": "partially_correct",
          "aspects": [
            {
              "text": "der Name",
              "elements": [
                [
                  45,
                  53
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "die Parameter",
              "elements": [
                [
                  58,
                  71
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ]
        }
      ]
    },
    {
      "text": "Was ist das Prinzip von 'call by value'?",
      "id": 50817,
      "title": "'Call by value'",
      "type": "definition",
      "aspects": [
        {
          "text": "bei der Parameterübergabe wird die Kopie des Wertes einer Variablen übergeben"
        },
        {
          "text": "Änderungen dieses Wertes innerhalb der Funktion haben keinen Effekte auf den ursprünglichen Wert"
        }
      ],
      "referenceAnswers": [
        {
          "text": "'Call by value' bedeutet, dass bei der Parameterübergabe die Kopie des Wertes einer Variablen übergeben wird. So haben Änderungen dieses Wertes innerhalb der Funktion keinen Effekte auf den ursprünglichen Wert.",
          "aspects": [
            {
              "text": "'Call by value' bedeutet, dass bei der Parameterübergabe die Kopie des Wertes einer Variablen übergeben wird",
              "aIdx": 0,
              "elements": [
                [
                  0,
                  108
                ]
              ]
            },
            {
              "text": "So haben Änderungen dieses Wertes innerhalb der Funktion keinen Effekte auf den ursprünglichen Wert",
              "aIdx": 1,
              "elements": [
                [
                  110,
                  209
                ]
              ]
            }
          ]
        }
      ],
      "studentAnswers": [
        {
          "text": "die Variable wird über ihren Wert definiert bsp Int, flow, long",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [],
          "correctionOrComment": "die Variable wird über ihren Wert definiert bsp Int, flow, long"
        },
        {
          "text": "Bezieht sich auf eine Variable die als Wert den tatsächlichen Wert gespeichert hat.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Bezieht sich auf eine Variable die als Wert den tatsächlichen Wert gespeichert hat",
              "elements": [
                [
                  0,
                  82
                ]
              ],
              "aIdx": 0,
              "label": 1
            }
          ],
          "correctionOrComment": "Bezieht sich auf eine Variable die als Wert den tatsächlichen Wert gespeichert hat."
        },
        {
          "text": "Der Wert ist direkt in der Variable gespeichert",
          "id": "7ba019a2553e1137a4bbb8d3c779a48e5ceb2ca3a162e6e0a945ef0f",
          "aspects": [
            {
              "text": "Der Wert ist direkt in der Variable gespeichert",
              "elements": [
                [
                  0,
                  47
                ]
              ],
              "aIdx": 0,
              "label": 1
            }
          ],
          "correctionOrComment": "Der Wert ist direkt in der Variable gespeichert"
        },
        {
          "text": "Das Prinzip von call by value ist, dass wenn die Variable abgerufen wird, mit dem Wert an sich gearbeitet wird.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Das Prinzip von call by value ist, dass wenn die Variable abgerufen wird, mit dem Wert an sich gearbeitet wird",
              "elements": [
                [
                  0,
                  110
                ]
              ],
              "aIdx": 0,
              "label": 1
            }
          ],
          "correctionOrComment": "Das Prinzip von call by value ist, dass wenn die Variable abgerufen wird, mit dem Wert an sich gearbeitet wird."
        },
        {
          "text": "wird durch wert aufgerufen",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [],
          "correctionOrComment": "wird durch wert aufgerufen"
        },
        {
          "text": "der eigentliche wert einer variablen wird aufgerufen",
          "id": "c1b8144ee1a30244a571c3d9b48b2c394a7489065d2565968f521645",
          "aspects": [
            {
              "text": "der eigentliche Wert einer Variablen wird aufgerufen",
              "elements": [],
              "aIdx": 0,
              "label": 1
            }
          ],
          "correctionOrComment": "der eigentliche Wert einer Variablen wird aufgerufen"
        },
        {
          "text": "Call by value bedeutet, dass eine Veränderung eines Parameters keine Auswirkungen auf die aufgerufene Variable hat.",
          "id": "0ce8152aa92136af039b687c01c7dccfcb271f3db2d0ddcb3cfdd3e6",
          "aspects": [
            {
              "text": "Call by value bedeutet, dass eine Veränderung eines Parameters keine Auswirkungen auf die aufgerufene Variable hat",
              "elements": [
                [
                  0,
                  114
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Call by value bedeutet, dass eine Veränderung eines Parameters keine Auswirkungen auf die aufgerufene Variable hat."
        },
        {
          "text": "Beim Aufrufen einer Operation werden die Parameter kopiert, sodass diese innerhalb der Operation verändert werden können, und außerhalb der Operation sich nicht verändern.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "aspects": [
            {
              "text": "Beim Aufrufen einer Operation werden die Parameter kopiert",
              "elements": [
                [
                  0,
                  58
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "sodass diese innerhalb der Operation verändert werden können, und außerhalb der Operation sich nicht verändern",
              "elements": [
                [
                  60,
                  170
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Beim Aufrufen einer Operation werden die Parameter kopiert, sodass diese innerhalb der Operation verändert werden können, und außerhalb der Operation sich nicht verändern."
        },
        {
          "text": "Wenn eine Variable direkt einen Wert verwaltet, wie bei integer oder boolean.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [],
          "correctionOrComment": "Wenn eine Variable direkt einen Wert verwaltet, wie bei integer oder boolean."
        },
        {
          "text": "beim call by value wird der Wert kopiert",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Beim call by value wird der Wert kopiert",
              "elements": [],
              "aIdx": 0,
              "label": 0
            }
          ],
          "correctionOrComment": "Beim call by value wird der Wert kopiert"
        },
        {
          "text": "Ruft einen primitiven Datentyp auf.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [],
          "correctionOrComment": "Ruft einen primitiven Datentyp auf."
        },
        {
          "text": "Die Veränderung des Parameters hat keine Auswirkung auf die übergegebene Variable des primitiven Datentyps.",
          "id": "408f0afbe2440a4383a1e75b7d5b0b4202c7f7131a9acf9bd70492f3",
          "aspects": [
            {
              "text": "Die Veränderung des Parameters hat keine Auswirkung auf die übergegebene Variable des primitiven Datentyps",
              "elements": [
                [
                  0,
                  106
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Die Veränderung des Parameters hat keine Auswirkung auf die übergegebene Variable des primitiven Datentyps."
        },
        {
          "text": "aufrufen im programm",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [],
          "correctionOrComment": "aufrufen im programm"
        },
        {
          "text": "Aufrufen, wenn bestimmter Wert gefunden",
          "id": "271f93f45e9b4067327ed5c8cd30a034730aaace4382803c3e1d6c2f",
          "aspects": [],
          "correctionOrComment": "Aufrufen, wenn bestimmter Wert gefunden"
        },
        {
          "text": "Man ruft direkt die Variable ab - nicht den Pointer.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6",
          "aspects": [
            {
              "text": "Man ruft direkt die Variable ab",
              "elements": [
                [
                  0,
                  31
                ]
              ],
              "aIdx": 0,
              "label": 1
            }
          ],
          "correctionOrComment": "Man ruft direkt die Variable ab, nicht den Pointer."
        },
        {
          "text": "Dass nicht die Referenz von Daten sondern die tatsächlichen Daten abgerufen werden.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Dass ;; die tatsächlichen Daten abgerufen werden",
              "elements": [
                [
                  0,
                  4
                ],
                [
                  42,
                  82
                ]
              ],
              "aIdx": 0,
              "label": 1
            }
          ],
          "correctionOrComment": "Dass nicht die Referenz von Daten sondern die tatsächlichen Daten abgerufen werden."
        },
        {
          "text": "man bezieht sich auf den Inhalt eines Objektes, nicht auf dessen Namen",
          "id": "53750c72b7bb26cb6ff7115e383ca150d5a632a909a7f79e2f5274a4",
          "aspects": [],
          "correctionOrComment": "man bezieht sich auf den Inhalt eines Objektes, nicht auf dessen Namen"
        },
        {
          "text": "Wenn wir einen einfachen Datentypen aufrufen, schauen wir direkt auf den Wert, eine Änderung dieses Wertes hat keinen Einfluss auf den Parameter",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "nn wir einen einfachen Datentypen aufrufen, schauen wir direkt auf den Wert",
              "elements": [
                [
                  2,
                  77
                ]
              ],
              "aIdx": 0,
              "label": 1
            },
            {
              "text": "eine Änderung dieses Wertes hat keinen Einfluss auf den Parameter",
              "elements": [
                [
                  79,
                  144
                ]
              ],
              "aIdx": 1,
              "label": 1
            }
          ],
          "correctionOrComment": "Wenn wir einen einfachen Datentypen aufrufen, schauen wir direkt auf den Wert, eine Änderung dieses Wertes hat keinen Einfluss auf den Parameter"
        },
        {
          "text": "dcv",
          "id": "192f56eb9bd894a72b30c303247b107be2c4591f310dd69a67927f48",
          "aspects": [],
          "correctionOrComment": "dcv"
        },
        {
          "text": "Das Prinzip findet bei Methoden statt. In Java werden beispielsweise Int-Werte mithilfe von Call-by-Value aufgerufen. Es wird quasi eine Kopie von dem Parameter erstellt.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "aspects": [
            {
              "text": "Es wird quasi eine Kopie von dem Parameter erstellt",
              "elements": [
                [
                  118,
                  169
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ],
          "correctionOrComment": "Das Prinzip findet bei Methoden statt. In Java werden beispielsweise Int-Werte mithilfe von Call-by-Value aufgerufen. Es wird quasi eine Kopie von dem Parameter erstellt."
        },
        {
          "text": "Parameter werden durch einfaches Kopieren des Inhalt der Variable (primitiver Datentyp) intitialisiert.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "aspects": [
            {
              "text": "Parameter werden durch einfaches Kopieren des Inhalt der Variable (primitiver Datentyp) intitialisiert",
              "elements": [
                [
                  0,
                  102
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ],
          "correctionOrComment": "Parameter werden durch einfaches Kopieren des Inhalt der Variable (primitiver Datentyp) intitialisiert."
        },
        {
          "text": "Das Prinzip von call by value ist, dass ein konkreter Wert übergeben wird.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Das Prinzip von call by value ist, dass ein konkreter Wert übergeben wird",
              "elements": [
                [
                  0,
                  73
                ]
              ],
              "aIdx": 0,
              "label": 1
            }
          ],
          "correctionOrComment": "Das Prinzip von call by value ist, dass ein konkreter Wert übergeben wird."
        },
        {
          "text": "Der Wert wurde kopiert und übergeben",
          "id": "b51d18b551043c1f145f22dbde6f8531faeaf68c54ed9dd79ce24d17",
          "aspects": [
            {
              "text": "Der Wert wurde kopiert und übergeben",
              "elements": [
                [
                  0,
                  36
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ],
          "correctionOrComment": "Der Wert wurde kopiert und übergeben"
        },
        {
          "text": "primitive Datentypen speichern den Inhalt an sich",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [],
          "correctionOrComment": "primitive Datentypen speichern den Inhalt an sich"
        },
        {
          "text": "Das Aufrufen einer Varibale gibt den Wert zurück.",
          "id": "f09265efb456b0336079ad5b238daa1e38a11b1d71cc0e1a4e8edd56",
          "aspects": [
            {
              "text": "Das Aufrufen einer Varibale gibt den Wert zurück",
              "elements": [
                [
                  0,
                  48
                ]
              ],
              "aIdx": 0,
              "label": 1
            }
          ],
          "correctionOrComment": "Das Aufrufen einer Varibale gibt den Wert zurück."
        },
        {
          "text": "es wird eine variable an eine methode übergeben, jedoch nur der Wert dieser, somit hat die Methode keinen Einfluss auf die Variable direkt.",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c",
          "aspects": [
            {
              "text": "Es wird eine Variable an eine Methode übergeben, jedoch nur der Wert dieser",
              "elements": [],
              "aIdx": 0,
              "label": 1
            },
            {
              "text": " somit hat die Methode keinen Einfluss auf die Variable direkt",
              "elements": [
                [
                  77,
                  138
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Es wird eine Variable an eine Methode übergeben, jedoch nur der Wert dieser, somit hat die Methode keinen Einfluss auf die Variable direkt."
        },
        {
          "text": "der wert wird wiedergegeben",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [],
          "correctionOrComment": "der Wert wird wiedergegeben"
        },
        {
          "text": "Es wird eine Kopie der Variable an die Operation übergeben, so das der ursprüngliche Wert nicht verändert wird.",
          "id": "b8607e0369fbf3e33bc0e358f840915d8c085d1496097351913c0122",
          "aspects": [
            {
              "text": "Es wird eine Kopie der Variable an die Operation übergeben",
              "elements": [
                [
                  0,
                  58
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "so das der ursprüngliche Wert nicht verändert wird",
              "elements": [
                [
                  60,
                  110
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Es wird eine Kopie der Variable an die Operation übergeben, so das der ursprüngliche Wert nicht verändert wird."
        },
        {
          "text": "Bei call-by-value wird auf einen direkten Wert im Speicher zugegriffen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [],
          "correctionOrComment": "Bei call-by-value wird auf einen direkten Wert im Speicher zugegriffen."
        },
        {
          "text": "es wird eine Kopie erzeugt, der Originalwert wird nicht verändert, die Methode arbeitet mit der Kopie",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c",
          "aspects": [
            {
              "text": "es wird eine Kopie erzeugt",
              "elements": [
                [
                  0,
                  26
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "der Originalwert wird nicht verändert",
              "elements": [
                [
                  28,
                  65
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "es wird eine Kopie erzeugt, der Originalwert wird nicht verändert, die Methode arbeitet mit der Kopie"
        },
        {
          "text": "Nur der Wert wird kopiert und übergeben, Änderungen haben keinen weiteren Einfluss",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Nur der Wert wird kopiert und übergeben",
              "elements": [
                [
                  0,
                  39
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Änderungen haben keinen weiteren Einfluss",
              "elements": [
                [
                  41,
                  82
                ]
              ],
              "aIdx": 1,
              "label": 1
            }
          ],
          "correctionOrComment": "Nur der Wert wird kopiert und übergeben, Änderungen haben keinen weiteren Einfluss"
        },
        {
          "text": "Der Wert wird kopiert.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Der Wert wird kopiert",
              "elements": [
                [
                  0,
                  21
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ],
          "correctionOrComment": "Der Wert wird kopiert."
        }
      ]
    },
    {
      "text": "Was ist das Prinzip von 'call by reference'?",
      "id": 50818,
      "title": "'Call by reference'",
      "type": "definition",
      "aspects": [
        {
          "text": "bei der Parameterübergabe wird die Referenz auf den Wert übergeben"
        },
        {
          "text": "Veränderungen des Parameters innerhalb der Operation beeinflussen auch den Wert der beim Funktionsaufruf übergebenen Variablen"
        }
      ],
      "referenceAnswers": [
        {
          "text": "'Call by reference' bedeutet, dass bei der Parameterübergabe eine Referenz auf einen Wert übergeben wird. So beeinflussen Veränderungen des Parameters innerhalb der Operation auch den Wert der beim Funktionsaufruf übergebenen Variablen.",
          "aspects": [
            {
              "text": "'Call by reference' bedeutet, dass bei der Parameterübergabe eine Referenz auf einen Wert übergeben wird",
              "aIdx": 0,
              "elements": [
                [
                  0,
                  104
                ]
              ]
            },
            {
              "text": "So beeinflussen Veränderungen des Parameters innerhalb der Operation auch den Wert der beim Funktionsaufruf übergebenen Variablen",
              "aIdx": 1,
              "elements": [
                [
                  106,
                  235
                ]
              ]
            }
          ]
        }
      ],
      "studentAnswers": [
        {
          "text": "bei der übergabe werden referenzen übergeben, sodass änderungen auch die ursprünglich variable betreffen",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Bei der Übergabe werden Referenzen übergeben",
              "elements": [],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "sodass Änderungen auch die ursprünglich Variable betreffen",
              "elements": [],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Bei der Übergabe werden Referenzen übergeben, sodass Änderungen auch die ursprünglich Variable betreffen"
        },
        {
          "text": "'Call by reference' bedeutet, dass bei der Parameterübergabe die Kopie der Referenz einer Variablen übergeben wird.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "'Call by reference' bedeutet, dass bei der Parameterübergabe die Kopie der Referenz einer Variablen übergeben wird",
              "elements": [
                [
                  0,
                  114
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ],
          "correctionOrComment": "'Call by reference' bedeutet, dass bei der Parameterübergabe die Kopie der Referenz einer Variablen übergeben wird."
        },
        {
          "text": "Die Referenz auf den Wert wird als Parameter übergeben. Somit kann der Wert überall verändert werden.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Die Referenz auf den Wert wird als Parameter übergeben",
              "elements": [
                [
                  0,
                  54
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Somit kann der Wert überall verändert werden",
              "elements": [
                [
                  56,
                  100
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Die Referenz auf den Wert wird als Parameter übergeben. Somit kann der Wert überall verändert werden."
        },
        {
          "text": "Es wird die Referenz übergeben, sodass Änderungen sich auf beide auswirken.",
          "id": "7ba019a2553e1137a4bbb8d3c779a48e5ceb2ca3a162e6e0a945ef0f",
          "aspects": [
            {
              "text": "Es wird die Referenz übergeben",
              "elements": [
                [
                  0,
                  30
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "sodass Änderungen sich auf beide auswirken",
              "elements": [
                [
                  32,
                  74
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Es wird die Referenz übergeben, sodass Änderungen sich auf beide auswirken."
        },
        {
          "text": "Das Prinzip von call by reference ist, dass bei der Übergabe von Werten die Referenz übergeben wird, Veränderungen sich also auf den ursprünglichen Wert auswirken.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Das Prinzip von call by reference ist, dass bei der Übergabe von Werten die Referenz übergeben wir",
              "elements": [
                [
                  0,
                  98
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "eränderungen sich also auf den ursprünglichen Wert auswirken",
              "elements": [
                [
                  102,
                  162
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Das Prinzip von call by reference ist, dass bei der Übergabe von Werten die Referenz übergeben wird, Veränderungen sich also auf den ursprünglichen Wert auswirken."
        },
        {
          "text": "die Referenz einer variablen, also der Speicherort wird übergeben",
          "id": "c1b8144ee1a30244a571c3d9b48b2c394a7489065d2565968f521645",
          "aspects": [
            {
              "text": "Die Referenz einer Variablen, also der Speicherort wird übergeben",
              "elements": [],
              "aIdx": 0,
              "label": 0
            }
          ],
          "correctionOrComment": "Die Referenz einer Variablen, also der Speicherort wird übergeben"
        },
        {
          "text": "Call by reference bedeutet, dass bei der Parameterübergabe die Referenz der durch die Funktion aufgerufenen und veränderten Variablen kopiert und übergeben wird.",
          "id": "0ce8152aa92136af039b687c01c7dccfcb271f3db2d0ddcb3cfdd3e6",
          "aspects": [
            {
              "text": "Call by reference bedeutet, dass bei der Parameterübergabe die Referenz der durch die Funktion aufgerufenen und veränderten Variablen kopiert und übergeben wird",
              "elements": [
                [
                  0,
                  160
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ],
          "correctionOrComment": "Call by reference bedeutet, dass bei der Parameterübergabe die Referenz der durch die Funktion aufgerufenen und veränderten Variablen kopiert und übergeben wird."
        },
        {
          "text": "Das Prinzip call by reference bedeutet, dass beim Aufrufen einer Operation die Parameter als Verweis übergeben werden. Dadurch werden Änderungen innerhalb der Operation sich auf die ursprünglichen Werte auswirken.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "aspects": [
            {
              "text": "Das Prinzip call by reference bedeutet, dass beim Aufrufen einer Operation die Parameter als Verweis übergeben werden",
              "elements": [
                [
                  0,
                  117
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Dadurch werden Änderungen innerhalb der Operation sich auf die ursprünglichen Werte auswirken",
              "elements": [
                [
                  119,
                  212
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Das Prinzip call by reference bedeutet, dass beim Aufrufen einer Operation die Parameter als Verweis übergeben werden. Dadurch werden Änderungen innerhalb der Operation sich auf die ursprünglichen Werte auswirken."
        },
        {
          "text": "Das bei einem Parameter die Referenz übergeben wird und eine Änderung dieser Referenz Auswirkungen auf die ursprungsvariable hat.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Dass bei einem Parameter die Referenz übergeben wird",
              "elements": [],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "eine Änderung dieser Referenz Auswirkungen auf die Ursprungsvariable hat",
              "elements": [],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Dass bei einem Parameter die Referenz übergeben wird und eine Änderung dieser Referenz Auswirkungen auf die Ursprungsvariable hat."
        },
        {
          "text": "bei call by reference wird nicht der Wert sondern die Referenz kopiert",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Bei call by reference wird nicht der Wert sondern die Referenz kopiert",
              "elements": [],
              "aIdx": 0,
              "label": 0
            }
          ],
          "correctionOrComment": "Bei call by reference wird nicht der Wert sondern die Referenz kopiert"
        },
        {
          "text": "Ruft eine Referenz auf.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Ruft eine Referenz auf",
              "elements": [
                [
                  0,
                  22
                ]
              ],
              "aIdx": 0,
              "label": 1
            }
          ],
          "correctionOrComment": "Ruft eine Referenz auf."
        },
        {
          "text": "Wenn ein Array als Parameter übergeben wird, haben die Änderungen des Parameters auswirkung auf das Array.",
          "id": "408f0afbe2440a4383a1e75b7d5b0b4202c7f7131a9acf9bd70492f3",
          "aspects": [
            {
              "text": "haben die Änderungen des Parameters Auswirkung auf das Array",
              "elements": [],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Wenn ein Array als Parameter übergeben wird, haben die Änderungen des Parameters Auswirkung auf das Array."
        },
        {
          "text": "zugriff auf die kopie",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Zugriff auf die Kopie",
              "elements": [],
              "aIdx": 0,
              "label": 2
            }
          ],
          "correctionOrComment": "Zugriff auf die Kopie"
        },
        {
          "text": "Die Referenz der Variablen wird übergeben",
          "id": "271f93f45e9b4067327ed5c8cd30a034730aaace4382803c3e1d6c2f",
          "aspects": [
            {
              "text": "Die Referenz der Variablen wird übergeben",
              "elements": [
                [
                  0,
                  41
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ],
          "correctionOrComment": "Die Referenz der Variablen wird übergeben"
        },
        {
          "text": "Man übergibt einen Pointer auf die Variable, die man dann beliebig ändern kann.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6",
          "aspects": [
            {
              "text": "Man übergibt einen Pointer auf die Variable",
              "elements": [
                [
                  0,
                  43
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ],
          "correctionOrComment": "Man übergibt einen Pointer auf die Variable, die man dann beliebig ändern kann."
        },
        {
          "text": "Call by reference bedeutet, dass die Referenz und nicht die eigentlichen Daten abgerufen werden. Bei der Parameterübergabe einer Operation bedeutet das dann, dass die in der Referenz stehenden Daten im Laufe der Operation verändert werden könnten.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Call by reference bedeutet, dass die Referenz und nicht die eigentlichen Daten abgerufen werden",
              "elements": [
                [
                  0,
                  95
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Bei der Parameterübergabe einer Operation bedeutet das dann, dass die in der Referenz stehenden Daten im Laufe der Operation verändert werden könnten",
              "elements": [
                [
                  97,
                  246
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Call by reference bedeutet, dass die Referenz und nicht die eigentlichen Daten abgerufen werden. Bei der Parameterübergabe einer Operation bedeutet das dann, dass die in der Referenz stehenden Daten im Laufe der Operation verändert werden könnten."
        },
        {
          "text": "Bei call by reference wird die Referenz auf einen Wert übergeben, ursprünglicher Wert\\/Objekt wird verändert, es geht nicht nur um Inhalt",
          "id": "53750c72b7bb26cb6ff7115e383ca150d5a632a909a7f79e2f5274a4",
          "aspects": [
            {
              "text": "Bei call by reference wird die Referenz auf einen Wert übergeben",
              "elements": [
                [
                  0,
                  64
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "ursprünglicher Wert\\ Objekt wird verändert",
              "elements": [],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Bei call by reference wird die Referenz auf einen Wert übergeben, ursprünglicher Wert\\ Objekt wird verändert, es geht nicht nur um Inhalt"
        },
        {
          "text": "Wir über geben nur die Referenz auf ein Objekt (zB bei Strings, Arrays, Objekten), dadurch verändern wir auch das in den Parametern gespeicherte",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Wir über geben nur die Referenz auf ein Objekt",
              "elements": [
                [
                  0,
                  46
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "dadurch verändern wir auch das in den Parametern gespeicherte",
              "elements": [
                [
                  83,
                  144
                ]
              ],
              "aIdx": 1,
              "label": 1
            }
          ],
          "correctionOrComment": "Wir über geben nur die Referenz auf ein Objekt (zB bei Strings, Arrays, Objekten), dadurch verändern wir auch das in den Parametern gespeicherte"
        },
        {
          "text": "kml",
          "id": "192f56eb9bd894a72b30c303247b107be2c4591f310dd69a67927f48",
          "aspects": [],
          "correctionOrComment": "kml"
        },
        {
          "text": "Ist bei der Parameterübergabe von Objekten der Fall. Hier ist es keine Kopie, wie bei dem Prinzip Call-by-Value, sondern es verweist auf die Referenz des Objekts.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "aspects": [
            {
              "text": "Hier ist es keine Kopie, wie bei dem Prinzip Call-by-Value, sondern es verweist auf die Referenz des Objekts",
              "elements": [
                [
                  53,
                  161
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ],
          "correctionOrComment": "Ist bei der Parameterübergabe von Objekten der Fall. Hier ist es keine Kopie, wie bei dem Prinzip Call-by-Value, sondern es verweist auf die Referenz des Objekts."
        },
        {
          "text": "Hier wird die Referenz übergeben. Änderungen innerhalb der Funktion wirken sich nun auch auf den ursprünglichen Wert aus.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "aspects": [
            {
              "text": "Hier wird die Referenz übergeben",
              "elements": [
                [
                  0,
                  32
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": " Änderungen innerhalb der Funktion wirken sich nun auch auf den ursprünglichen Wert aus",
              "elements": [
                [
                  34,
                  120
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Hier wird die Referenz übergeben. Änderungen innerhalb der Funktion wirken sich nun auch auf den ursprünglichen Wert aus."
        },
        {
          "text": "Bei der Parameterübergabe wird eine Kopie der Referenz auf ein Objekt übergeben.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Bei der Parameterübergabe wird eine Kopie der Referenz auf ein Objekt übergeben",
              "elements": [
                [
                  0,
                  79
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ],
          "correctionOrComment": "Bei der Parameterübergabe wird eine Kopie der Referenz auf ein Objekt übergeben."
        },
        {
          "text": "Bei der Parameterübergabe wird eine Kopie der Referenz der Variable übergeben. Die Veränderung des Parameters hat somit Auswirkungen auf den Inhalt der Variable",
          "id": "b51d18b551043c1f145f22dbde6f8531faeaf68c54ed9dd79ce24d17",
          "aspects": [
            {
              "text": "Bei der Parameterübergabe wird eine Kopie der Referenz auf ein Objekt übergeben",
              "elements": [],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Die Veränderung des Parameters hat somit Auswirkungen auf den Inhalt der Variable",
              "elements": [
                [
                  79,
                  160
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Bei der Parameterübergabe wird eine Kopie der Referenz der Variable übergeben. Die Veränderung des Parameters hat somit Auswirkungen auf den Inhalt der Variable"
        },
        {
          "text": "variable hält als wert eine Referenz auf den Inhalt im speicher",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [],
          "correctionOrComment": "Die Variable hält als Wert eine Referenz auf den Inhalt im Speicher"
        },
        {
          "text": "Beim Übergeben einer Variable wird die Referenz kopiert.",
          "id": "f09265efb456b0336079ad5b238daa1e38a11b1d71cc0e1a4e8edd56",
          "aspects": [
            {
              "text": "Beim Übergeben einer Variable wird die Referenz kopiert",
              "elements": [
                [
                  0,
                  55
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ],
          "correctionOrComment": "Beim Übergeben einer Variable wird die Referenz kopiert."
        },
        {
          "text": "call bei refernce übergibt die Referenz der variablen also die Adresse im Speicher wodurch eine methode auf diese zugreifen kann und diese ändern kann.",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c",
          "aspects": [
            {
              "text": "Call bei refernce übergibt die Referenz der Variablen, also die Adresse im Speicher",
              "elements": [],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "wodurch eine Methode auf diese zugreifen kann und diese ändern kann",
              "elements": [],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Call bei refernce übergibt die Referenz der Variablen, also die Adresse im Speicher, wodurch eine Methode auf diese zugreifen kann und diese ändern kann."
        },
        {
          "text": "die referenz wird kopiert",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "die Referenz wird kopiert",
              "elements": [],
              "aIdx": 0,
              "label": 1
            }
          ],
          "correctionOrComment": "die Referenz wird kopiert"
        },
        {
          "text": "Es wird der ursprüngliche Wert an die Operation übergeben, sodass Änderungen innerhalb der Operation Auswirkungen auf den ursprünglichen Wert haben.",
          "id": "b8607e0369fbf3e33bc0e358f840915d8c085d1496097351913c0122",
          "aspects": [
            {
              "text": "Es wird der ursprüngliche Wert an die Operation übergeben",
              "elements": [
                [
                  0,
                  57
                ]
              ],
              "aIdx": 0,
              "label": 1
            },
            {
              "text": "sodass Änderungen innerhalb der Operation Auswirkungen auf den ursprünglichen Wert haben",
              "elements": [
                [
                  59,
                  147
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Es wird der ursprüngliche Wert an die Operation übergeben, sodass Änderungen innerhalb der Operation Auswirkungen auf den ursprünglichen Wert haben."
        },
        {
          "text": "hier wird die Referenz auf eine Variable übergeben und von der Operation auch der Originalwert geändert",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c",
          "aspects": [
            {
              "text": "Hier wird die Referenz auf eine Variable übergeben ",
              "elements": [],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Hier wird ;; von der Operation auch der Originalwert geändert",
              "elements": [
                [
                  55,
                  103
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Hier wird die Referenz auf eine Variable übergeben und von der Operation auch der Originalwert geändert"
        },
        {
          "text": "Die Feferen wird übergeben, Veränderungen bleiben auch außerhalb der Operation erhalten",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Die Referenz wird übergeben",
              "elements": [],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Veränderungen bleiben auch außerhalb der Operation erhalten",
              "elements": [
                [
                  28,
                  87
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Die Referenz wird übergeben, Veränderungen bleiben auch außerhalb der Operation erhalten"
        }
      ]
    },
    {
      "text": "Wie werden Klassen in Java einem Paket zugeordnet?",
      "id": 50820,
      "title": "Paketzuordnung",
      "type": "procedure",
      "aspects": [
        {
          "text": "Die Dateien müssen im selben Verzeichnis liegen"
        },
        {
          "text": "Der Dateiinhalt muss mit der Anweisung 'package <Verzeichnispfad>' dem Paket hinzugefügt werden"
        }
      ],
      "referenceAnswers": [
        {
          "text": "Die Dateien der zum Paket zugehörigen Klassen müssen im selben Verzeichnis liegen und dem Paket mit der Anweisung 'package <Verzeichnispfad>' hinzugefügt werden.",
          "aspects": [
            {
              "text": "Die Dateien der zum Paket zugehörigen Klassen müssen im selben Verzeichnis liegen",
              "aIdx": 0,
              "elements": [
                [
                  0,
                  91
                ]
              ]
            },
            {
              "text": "und dem Paket mit der Anweisung 'package <Verzeichnispfad>' hinzugefügt werden",
              "aIdx": 1,
              "elements": [
                [
                  92,
                  160
                ]
              ]
            }
          ]
        }
      ],
      "studentAnswers": [
        {
          "text": "Über den methodenkopf, public oder private bspw",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [],
          "correctionOrComment": "Über den methodenkopf, public oder private bspw"
        },
        {
          "text": "Die Klassen werden in einem Ordner gespeichert.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Die Klassen werden in einem Ordner gespeichert",
              "elements": [
                [
                  0,
                  46
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ],
          "correctionOrComment": "Die Klassen werden in einem Ordner gespeichert."
        },
        {
          "text": "Durch den Befehl package.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Durch den Befehl package",
              "elements": [
                [
                  0,
                  24
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Durch den Befehl package."
        },
        {
          "text": "semantik",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [],
          "correctionOrComment": "semantik"
        },
        {
          "text": "j",
          "id": "c1b8144ee1a30244a571c3d9b48b2c394a7489065d2565968f521645",
          "aspects": [],
          "correctionOrComment": "j"
        },
        {
          "text": "Die Klasse muss in einem Verzeichnis sein, dass dem Paketnamen entspricht.",
          "id": "0ce8152aa92136af039b687c01c7dccfcb271f3db2d0ddcb3cfdd3e6",
          "aspects": [
            {
              "text": "Die Klasse muss in einem Verzeichnis sein",
              "elements": [
                [
                  0,
                  41
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "dass dem Paketnamen entspricht",
              "elements": [
                [
                  43,
                  73
                ]
              ],
              "aIdx": 1,
              "label": 1
            }
          ],
          "correctionOrComment": "Die Klasse muss in einem Verzeichnis sein, dass dem Paketnamen entspricht."
        },
        {
          "text": "Klassen in Java werden zu einem Paket durch ihren Ordner zugeordnet.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "aspects": [
            {
              "text": "Klassen in Java werden zu einem Paket durch ihren Ordner zugeordnet",
              "elements": [
                [
                  0,
                  67
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ],
          "correctionOrComment": "Klassen in Java werden zu einem Paket durch ihren Ordner zugeordnet."
        },
        {
          "text": "In dem sie in so einem Paket abgespeichert werden.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [],
          "correctionOrComment": "In dem sie in so einem Paket abgespeichert werden."
        },
        {
          "text": "mit der Definition package am Anfang des Codes.",
          "id": "408f0afbe2440a4383a1e75b7d5b0b4202c7f7131a9acf9bd70492f3",
          "aspects": [
            {
              "text": "mit der Definition package am Anfang des Codes",
              "elements": [
                [
                  0,
                  46
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "mit der Definition package am Anfang des Codes."
        },
        {
          "text": "import",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [],
          "correctionOrComment": "import"
        },
        {
          "text": "Indem sie über den Pfad zugeordnet werden",
          "id": "271f93f45e9b4067327ed5c8cd30a034730aaace4382803c3e1d6c2f",
          "aspects": [
            {
              "text": "Indem sie über den Pfad zugeordnet werden",
              "elements": [
                [
                  0,
                  41
                ]
              ],
              "aIdx": 0,
              "label": 1
            },
            {
              "text": "Indem sie über den Pfad zugeordnet werden",
              "elements": [
                [
                  0,
                  41
                ]
              ],
              "aIdx": 1,
              "label": 1
            }
          ],
          "correctionOrComment": "Indem sie über den Pfad zugeordnet werden"
        },
        {
          "text": "paket.klasse.java",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [],
          "correctionOrComment": "paket.klasse.java"
        },
        {
          "text": "Man packt diese in eine Datei, welche via package XY zu einem solchen zugehörig erklärt wurde.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6",
          "aspects": [
            {
              "text": "welche via package XY zu einem solchen zugehörig erklärt wurde",
              "elements": [
                [
                  31,
                  93
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Man packt diese in eine Datei, welche via package XY zu einem solchen zugehörig erklärt wurde."
        },
        {
          "text": "Dadurch in welchem Ordner sie gespeichert sind. Klassen im gleichen Ordner bilden ein Paket.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Dadurch in welchem Ordner sie gespeichert sind. Klassen im gleichen Ordner bilden ein Paket",
              "elements": [
                [
                  0,
                  91
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ],
          "correctionOrComment": "Dadurch in welchem Ordner sie gespeichert sind. Klassen im gleichen Ordner bilden ein Paket."
        },
        {
          "text": "package.NameDesPackets",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "package.NameDesPackets",
              "elements": [
                [
                  0,
                  22
                ]
              ],
              "aIdx": 1,
              "label": 1
            }
          ],
          "correctionOrComment": "package.NameDesPackets"
        },
        {
          "text": "l,l,",
          "id": "192f56eb9bd894a72b30c303247b107be2c4591f310dd69a67927f48",
          "aspects": [],
          "correctionOrComment": "l,l,"
        },
        {
          "text": "Das ist dann der jeweilige Ordnername.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "aspects": [
            {
              "text": "Das ist dann der jeweilige Ordnername",
              "elements": [
                [
                  0,
                  37
                ]
              ],
              "aIdx": 0,
              "label": 1
            }
          ],
          "correctionOrComment": "Das ist dann der jeweilige Ordnername."
        },
        {
          "text": "Klassen müssen sich in einem Verzeichnis befinden, dass dem Namen des Pakets entspricht.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "aspects": [
            {
              "text": "Klassen müssen sich in einem Verzeichnis befinden, dass dem Namen des Pakets entspricht",
              "elements": [
                [
                  0,
                  87
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Klassen müssen sich in einem Verzeichnis befinden, dass dem Namen des Pakets entspricht",
              "elements": [
                [
                  0,
                  87
                ]
              ],
              "aIdx": 1,
              "label": 1
            }
          ],
          "correctionOrComment": "Klassen müssen sich in einem Verzeichnis befinden, dass dem Namen des Pakets entspricht."
        },
        {
          "text": "Um einen Klasse einem Paket zuzuordnen, muss die Klasse in einem Verzeichnis sein, das dem Paketnamen entspricht. In der Java Daten muss zu Beginn das Paket angegeben werden.",
          "id": "b51d18b551043c1f145f22dbde6f8531faeaf68c54ed9dd79ce24d17",
          "aspects": [
            {
              "text": "Um einen Klasse einem Paket zuzuordnen, muss die Klasse in einem Verzeichnis sein, das dem Paketnamen entspricht",
              "elements": [
                [
                  0,
                  112
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "In der Java Daten muss zu Beginn das Paket angegeben werden",
              "elements": [
                [
                  114,
                  173
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Um einen Klasse einem Paket zuzuordnen, muss die Klasse in einem Verzeichnis sein, das dem Paketnamen entspricht. In der Java Daten muss zu Beginn das Paket angegeben werden."
        },
        {
          "text": "ordner",
          "id": "ae8820303e493738a211ebb2ae3a2f90b286f20f767609beb77522c0",
          "aspects": [
            {
              "text": "ordner",
              "elements": [
                [
                  0,
                  6
                ]
              ],
              "aIdx": 0,
              "label": 1
            }
          ],
          "correctionOrComment": "ordner"
        },
        {
          "text": "Mit dem Schlüsselwort package",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c",
          "aspects": [
            {
              "text": "Mit dem Schlüsselwort package",
              "elements": [
                [
                  0,
                  29
                ]
              ],
              "aIdx": 1,
              "label": 1
            }
          ],
          "correctionOrComment": "Mit dem Schlüsselwort package"
        },
        {
          "text": "Ein Verzeichnis packag'Dateipfad'",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Ein Verzeichnis packag'Dateipfad'",
              "elements": [
                [
                  0,
                  33
                ]
              ],
              "aIdx": 0,
              "label": 1
            },
            {
              "text": "Ein Verzeichnis packag'Dateipfad'",
              "elements": [
                [
                  0,
                  33
                ]
              ],
              "aIdx": 1,
              "label": 1
            }
          ],
          "correctionOrComment": "Ein Verzeichnis packag'Dateipfad'"
        },
        {
          "text": "import dies.ist.mein.pakage.Klasse;",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [],
          "correctionOrComment": "import dies.ist.mein.pakage.Klasse;"
        }
      ]
    },
    {
      "text": "Warum sind Sortierverfahren die darauf beruhen Fehlstellungen von Nachbarn zu beheben im best-case besser als n*log(n)?",
      "id": 50888,
      "title": "BubbleSort",
      "type": "reason",
      "aspects": [
        {
          "text": "Bei einem sortierten Array gibt es keine Fehlstellungen"
        },
        {
          "text": "Das Array muss nur einmal durchlaufen werden"
        }
      ],
      "referenceAnswers": [
        {
          "text": "Bei einem sortierten Array gibt es keine Fehlstellungen. Das Array muss deshalb nur einmal durchlaufen werden.",
          "aspects": [
            {
              "text": "Bei einem sortierten Array gibt es keine Fehlstellungen",
              "aIdx": 0,
              "elements": [
                [
                  0,
                  55
                ]
              ]
            },
            {
              "text": "Das Array muss deshalb nur einmal durchlaufen werden",
              "aIdx": 1,
              "elements": [
                [
                  57,
                  109
                ]
              ]
            }
          ]
        }
      ],
      "studentAnswers": [
        {
          "text": "Best case: Schon sortiert. Nach n-1 Vergleichen ist man dann fertig.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Schon sortiert",
              "elements": [
                [
                  11,
                  25
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Nach n-1 Vergleichen ist man dann fertig",
              "elements": [
                [
                  27,
                  67
                ]
              ],
              "aIdx": 1,
              "label": 1
            }
          ],
          "correctionOrComment": "Best case: Schon sortiert. Nach n-1 Vergleichen ist man dann fertig."
        },
        {
          "text": "Weil ein sortiertes Array nur genau n Vergleiche und somit eine Laufzeit von O(n) benötigt.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "ein sortiertes Array",
              "elements": [
                [
                  5,
                  25
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Weil ein sortiertes Array nur genau n Vergleiche ;; benötigt",
              "elements": [
                [
                  0,
                  48
                ],
                [
                  82,
                  90
                ]
              ],
              "aIdx": 1,
              "label": 1
            }
          ],
          "correctionOrComment": "Weil ein sortiertes Array nur genau n Vergleiche und somit eine Laufzeit von O(n) benötigt."
        },
        {
          "text": "Im Best-Case ist das Array schon sortiert. Der Algorithmus kann abbrechen, wenn das Array einmal durchgegangen wurde. Damit ist die Laufzeit n.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Im Best-Case ist das Array schon sortiert",
              "elements": [
                [
                  0,
                  41
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Der Algorithmus kann abbrechen, wenn das Array einmal durchgegangen wurde",
              "elements": [
                [
                  43,
                  116
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Im Best-Case ist das Array schon sortiert. Der Algorithmus kann abbrechen, wenn das Array einmal durchgegangen wurde. Damit ist die Laufzeit n."
        },
        {
          "text": "Da viele Fehlstellung bereits beim ersten Durchlauf korrigiert werden.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Da viele Fehlstellung bereits beim ersten Durchlauf korrigiert werden",
              "elements": [
                [
                  0,
                  69
                ]
              ],
              "aIdx": 0,
              "label": 2
            }
          ],
          "correctionOrComment": "Da viele Fehlstellung bereits beim ersten Durchlauf korrigiert werden."
        },
        {
          "text": "Weil im best case die Laufzeit n ist, da nur einmal durchgelaufen werden muss.",
          "id": "7ba019a2553e1137a4bbb8d3c779a48e5ceb2ca3a162e6e0a945ef0f",
          "aspects": [
            {
              "text": "da nur einmal durchgelaufen werden muss",
              "elements": [
                [
                  38,
                  77
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Weil im best case die Laufzeit n ist, da nur einmal durchgelaufen werden muss."
        },
        {
          "text": "Da sie im best-case nur das Array durchlaufen und alle Nachbarn einmal vergleichen, also eine Laufzeit von O(n) haben.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Da sie im best-case nur das Array durchlaufen",
              "elements": [
                [
                  0,
                  45
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Da sie im best-case nur das Array durchlaufen und alle Nachbarn einmal vergleichen, also eine Laufzeit von O(n) haben."
        },
        {
          "text": "Das array wird nur einmal durchgelaufen dh die Laufzeit ist n",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Das Array wird nur einmal durchgelaufen",
              "elements": [],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Das Array wird nur einmal durchgelaufen dh die Laufzeit ist n"
        },
        {
          "text": "Weil im besten Fall das Array schon vorsortiert ist und nur einmal durchlaufen werden muss (um festzustellen dass jede einzelne Position passt).",
          "id": "0ce8152aa92136af039b687c01c7dccfcb271f3db2d0ddcb3cfdd3e6",
          "aspects": [
            {
              "text": "Weil im besten Fall das Array schon vorsortiert ist",
              "elements": [
                [
                  0,
                  51
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Weil im besten Fall das Array ;; nur einmal durchlaufen werden muss ",
              "elements": [
                [
                  0,
                  29
                ],
                [
                  56,
                  90
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Weil im besten Fall das Array schon vorsortiert ist und nur einmal durchlaufen werden muss (um festzustellen dass jede einzelne Position passt)."
        },
        {
          "text": "Falls die Menge vorsortiert ist, wird dies durch ein einmaliges durchlaufen sofort festgestellt.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "aspects": [
            {
              "text": "Falls die Menge vorsortiert ist",
              "elements": [
                [
                  0,
                  31
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "wird dies durch ein einmaliges durchlaufen sofort festgestellt",
              "elements": [
                [
                  33,
                  95
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Falls die Menge vorsortiert ist, wird dies durch ein einmaliges durchlaufen sofort festgestellt."
        },
        {
          "text": "Weil sie dann in einem bereits sortierten Array nur die Laufzeit O(n) benötigen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "in einem bereits sortierten Array",
              "elements": [
                [
                  14,
                  47
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ],
          "correctionOrComment": "Weil sie dann in einem bereits sortierten Array nur die Laufzeit O(n) benötigen."
        },
        {
          "text": "Weil in dem best-case, d.h. wenn das Array schon vorsortiert war, laufen sie nur einmal durch. Wenn richtig implementiert, kommt ein One-Way-Flag - nichts zu tauschen - und der Algorithmus ist fertig. O(n)",
          "id": "408f0afbe2440a4383a1e75b7d5b0b4202c7f7131a9acf9bd70492f3",
          "aspects": [
            {
              "text": "wenn das Array schon vorsortiert war",
              "elements": [
                [
                  28,
                  64
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": " laufen sie nur einmal durch",
              "elements": [
                [
                  66,
                  93
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Weil in dem best-case, d.h. wenn das Array schon vorsortiert war, laufen sie nur einmal durch. Wenn richtig implementiert, kommt ein One-Way-Flag - nichts zu tauschen - und der Algorithmus ist fertig. O(n)"
        },
        {
          "text": "dann ist es schon sortiert",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "dann ist es schon sortiert",
              "elements": [
                [
                  0,
                  26
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ],
          "correctionOrComment": "dann ist es schon sortiert"
        },
        {
          "text": "Weil das Array so immer in geordneterer Reihenfolge auftaucht",
          "id": "271f93f45e9b4067327ed5c8cd30a034730aaace4382803c3e1d6c2f",
          "aspects": [],
          "correctionOrComment": "Weil das Array so immer in geordneterer Reihenfolge auftaucht"
        },
        {
          "text": "im best case liegt das array bereits sortiert vor und muss deshalb nur einmal durchlaufen werden",
          "id": "c1b8144ee1a30244a571c3d9b48b2c394a7489065d2565968f521645",
          "aspects": [
            {
              "text": "im best case liegt das array bereits sortiert vor",
              "elements": [
                [
                  0,
                  49
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "muss deshalb nur einmal durchlaufen werden",
              "elements": [
                [
                  54,
                  96
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "im best case liegt das array bereits sortiert vor und muss deshalb nur einmal durchlaufen werden"
        },
        {
          "text": "Bei vorsortierten Arrays muss das Array nur einmal durchlaufen werden. Daher O(n)",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6",
          "aspects": [
            {
              "text": "Bei vorsortierten Arrays",
              "elements": [
                [
                  0,
                  24
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "muss das Array nur einmal durchlaufen werden",
              "elements": [
                [
                  25,
                  69
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Bei vorsortierten Arrays muss das Array nur einmal durchlaufen werden. Daher O(n)"
        },
        {
          "text": "kjkjk",
          "id": "192f56eb9bd894a72b30c303247b107be2c4591f310dd69a67927f48",
          "aspects": [],
          "correctionOrComment": "kjkjk"
        },
        {
          "text": "Weil sie, wenn alles schon sortiert ist nicht korrigieren müssen, d.h. sie müssen nur einmal das Array durchlaufen, was O(n) benötigt.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Weil sie, wenn alles schon sortiert ist nicht korrigieren müssen",
              "elements": [
                [
                  0,
                  64
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "sie müssen nur einmal das Array durchlaufen",
              "elements": [
                [
                  71,
                  114
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Weil sie, wenn alles schon sortiert ist nicht korrigieren müssen, d.h. sie müssen nur einmal das Array durchlaufen, was O(n) benötigt."
        },
        {
          "text": "Weil das Array im besten Fall nur einmal durchlaufen werden muss.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "aspects": [
            {
              "text": "Weil das Array im besten Fall nur einmal durchlaufen werden muss",
              "elements": [
                [
                  0,
                  64
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Weil das Array im besten Fall nur einmal durchlaufen werden muss."
        },
        {
          "text": "Solche Verahren werden abgebrochen, wenn kein Tausch durchgeführt wurde. Wenn das Array sortiert war, passiert das in der Zeit n.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "aspects": [
            {
              "text": "Solche Verahren werden abgebrochen, wenn kein Tausch durchgeführt wurde",
              "elements": [
                [
                  0,
                  71
                ]
              ],
              "aIdx": 1,
              "label": 1
            },
            {
              "text": "wenn das Array sortiert war",
              "elements": [],
              "aIdx": 0,
              "label": 0
            }
          ],
          "correctionOrComment": "Solche Verahren werden abgebrochen, wenn kein Tausch durchgeführt wurde. Wenn das Array sortiert war, passiert das in der Zeit n."
        },
        {
          "text": "Weil sie nur einmal das Array durchlaufen und sofort erkennen (außer unoptimiertes SelectionSort), wenn im gesamten Array keine Fehlstellung vorliegt. Die Laufzeit beträgt dann O(n).",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "und sofort erkennen ;;  wenn im gesamten Array keine Fehlstellung vorliegt",
              "elements": [
                [
                  42,
                  61
                ],
                [
                  99,
                  149
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Weil sie nur einmal das Array durchlaufen",
              "elements": [
                [
                  0,
                  41
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Weil sie nur einmal das Array durchlaufen und sofort erkennen (außer unoptimiertes SelectionSort), wenn im gesamten Array keine Fehlstellung vorliegt. Die Laufzeit beträgt dann O(n)."
        },
        {
          "text": "Weil din dem Fall das Array im Best case vorsortiert ist, es also keine Fehlstellung gibt, die man beheben muss",
          "id": "8416c38cc898f1ac7cc9d64e89dab1f70f5ddab002a5b2a1713f93f5",
          "aspects": [
            {
              "text": "Weil in dem Fall das Array im Best case vorsortiert ist, es also keine Fehlstellung gibt, die man beheben muss",
              "elements": [],
              "aIdx": 0,
              "label": 0
            }
          ],
          "correctionOrComment": "Weil in dem Fall das Array im Best case vorsortiert ist, es also keine Fehlstellung gibt, die man beheben muss"
        },
        {
          "text": "das Array muss wenn es vorsortiert ist nur einmal durchlaufen werden",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "das Array muss wenn es vorsortiert",
              "elements": [
                [
                  0,
                  34
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "das Array muss ;; nur einmal durchlaufen werden",
              "elements": [
                [
                  0,
                  14
                ],
                [
                  39,
                  68
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "das Array muss wenn es vorsortiert ist nur einmal durchlaufen werden"
        },
        {
          "text": "Weil im besten Fall schon eine sortierte Menge vorliegt und die Menge nur einmal durchlaufen werden muss um herauszufinden dass keine Fehlstellung vorliegt.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Weil im besten Fall schon eine sortierte Menge vorliegt ;; um herauszufinden dass keine Fehlstellung vorliegt",
              "elements": [
                [
                  0,
                  55
                ],
                [
                  105,
                  155
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": " und die Menge nur einmal durchlaufen werden muss",
              "elements": [
                [
                  56,
                  104
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Weil im besten Fall schon eine sortierte Menge vorliegt und die Menge nur einmal durchlaufen werden muss um herauszufinden dass keine Fehlstellung vorliegt."
        },
        {
          "text": "weil im Best Case, nur maximal ein durchlauf nötig isst und somit nur O(n)",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c",
          "aspects": [
            {
              "text": "weil im Best Case, nur maximal ein Durchlauf nötig ist",
              "elements": [],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "weil im Best Case, nur maximal ein Durchlauf nötig ist und somit nur O(n)"
        },
        {
          "text": "Bei sortierten daten brauch man nur 1 durchlauf",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Bei sortierten daten",
              "elements": [
                [
                  0,
                  20
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "brauch man nur 1 Durchlauf",
              "elements": [],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Bei sortierten daten brauch man nur 1 Durchlauf"
        },
        {
          "text": "Vergleichsbasierend",
          "id": "ae8820303e493738a211ebb2ae3a2f90b286f20f767609beb77522c0",
          "aspects": [],
          "correctionOrComment": "Vergleichsbasierend"
        },
        {
          "text": "Im besten Fall muss der Datensatz nur einmal durchlaufen werden (O(n)).",
          "id": "b8607e0369fbf3e33bc0e358f840915d8c085d1496097351913c0122",
          "aspects": [
            {
              "text": "Im besten Fall muss der Datensatz nur einmal durchlaufen werden",
              "elements": [
                [
                  0,
                  63
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Im besten Fall muss der Datensatz nur einmal durchlaufen werden (O(n))."
        },
        {
          "text": "Der best case ist, wenn das Array bereits sortiert ist. Dann werden n Vergleiche gemacht und kein Mal getauscht. Der Algorithmus bricht ab, wenn nict getauscht wurde in einem Durchgang.",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c",
          "aspects": [
            {
              "text": "Der best case ist, wenn das Array bereits sortiert ist",
              "elements": [
                [
                  0,
                  54
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Der Algorithmus bricht ab, wenn nicht getauscht wurde in einem Durchgang",
              "elements": [],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Der best case ist, wenn das Array bereits sortiert ist. Dann werden n Vergleiche gemacht und kein Mal getauscht. Der Algorithmus bricht ab, wenn nicht getauscht wurde in einem Durchgang."
        },
        {
          "text": "Da ein bereits richtig sortiertes Array in einem Durchlauf abgearbeitet werden kann",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6",
          "aspects": [
            {
              "text": "ein bereits richtig sortiertes Array",
              "elements": [
                [
                  3,
                  39
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "in einem Durchlauf abgearbeitet werden kann",
              "elements": [
                [
                  40,
                  83
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Da ein bereits richtig sortiertes Array in einem Durchlauf abgearbeitet werden kann"
        },
        {
          "text": "Nur ein Durchlauf erforderlich, wenn das Array bereits sortiert ist",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "wenn das Array bereits sortiert ist",
              "elements": [
                [
                  32,
                  67
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Nur ein Durchlauf erforderlich",
              "elements": [
                [
                  0,
                  30
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Nur ein Durchlauf erforderlich, wenn das Array bereits sortiert ist"
        },
        {
          "text": "Da dass Array nur einmal durchlaufen werden muss",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Da dass Array nur einmal durchlaufen werden muss",
              "elements": [
                [
                  0,
                  48
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Da dass Array nur einmal durchlaufen werden muss"
        }
      ]
    },
    {
      "text": "Was ist die Idee von Heapsort?",
      "id": 50889,
      "title": "Idee HeapSort",
      "type": "description",
      "aspects": [
        {
          "text": "Die durch Vergleiche erlangten Informationen in einem Binärbaum zu speichern"
        },
        {
          "text": "Alle Väter des Binärbaumes sind größer ist als seine Söhne"
        },
        {
          "text": "Das größte Element befindet in der Wurzel",
          "implied": true
        },
        {
          "text": "Die Wurzel wird iterativ entfernt und der Baum wird wiederhergestellt"
        }
      ],
      "referenceAnswers": [
        {
          "text": "Die Grundidee ist es die durch Vergleiche erlangten Informationen in einem Binärbaum zu speichern. Die Elemente werden so in den Baum übertragen, dass der Vater größer ist als seine Söhne. Das größte Element befindet sich somit in der Wurzel. Es wird iterativ entfernt und der Baum wird wiederhergestellt.",
          "aspects": [
            {
              "text": "Die Grundidee ist es die durch Vergleiche erlangten Informationen in einem Binärbaum zu speichern",
              "aIdx": 0,
              "elements": [
                [
                  0,
                  97
                ]
              ]
            },
            {
              "text": "Die Elemente werden so in den Baum übertragen, dass der Vater größer ist als seine Söhne",
              "aIdx": 1,
              "elements": [
                [
                  99,
                  187
                ]
              ]
            },
            {
              "text": "Das größte Element befindet sich somit in der Wurzel",
              "aIdx": 2,
              "elements": [
                [
                  189,
                  241
                ]
              ]
            },
            {
              "text": "Es wird iterativ entfernt und der Baum wird wiederhergestellt",
              "aIdx": 3,
              "elements": [
                [
                  243,
                  304
                ]
              ]
            }
          ]
        }
      ],
      "studentAnswers": [
        {
          "text": "Möglichst viele der gewonnen Daten zu verwenden, es wird ein Binärbaum konstruiert",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Möglichst viele der gewonnen Daten zu verwenden, es wird ein Binärbaum konstruiert",
              "elements": [
                [
                  0,
                  82
                ]
              ],
              "aIdx": 0,
              "label": 1
            }
          ],
          "correctionOrComment": "Möglichst viele der gewonnen Daten zu verwenden, es wird ein Binärbaum konstruiert"
        },
        {
          "text": "Ein Binärbaum wird erstellt, das Maximum\\/Minimum wird zum 0. Knoten, darunter sind die jeweiligen Kinder, welche aufsteigend bis zum 0. Knoten sortiert werden, danach wird dieser abgeschnitten.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Ein Binärbaum wird erstellt",
              "elements": [
                [
                  0,
                  27
                ]
              ],
              "aIdx": 0,
              "label": 1
            },
            {
              "text": "darunter sind die jeweiligen Kinder, welche aufsteigend bis zum 0. Knoten sortiert werden",
              "elements": [
                [
                  70,
                  159
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": " das Maximum oder Minimum wird zum 0. Knoten",
              "elements": [],
              "aIdx": 2,
              "label": 0
            },
            {
              "text": "danach wird dieser abgeschnitten",
              "elements": [
                [
                  161,
                  193
                ]
              ],
              "aIdx": 3,
              "label": 1
            }
          ],
          "correctionOrComment": "Ein Binärbaum wird erstellt, das Maximum oder Minimum wird zum 0. Knoten, darunter sind die jeweiligen Kinder, welche aufsteigend bis zum 0. Knoten sortiert werden, danach wird dieser abgeschnitten."
        },
        {
          "text": "Man strukturiert die Vergleiche so, dass eine Veränderung möglichste viele Informationen erhält.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Man strukturiert die Vergleiche so, dass eine Veränderung möglichste viele Informationen erhält",
              "elements": [
                [
                  0,
                  95
                ]
              ],
              "aIdx": 0,
              "label": 1
            }
          ],
          "correctionOrComment": "Man strukturiert die Vergleiche so, dass eine Veränderung möglichste viele Informationen erhält."
        },
        {
          "text": "In einem Binärbaum wird der Vater als größeres Element mit seinen kleineren Kindern dargestellt.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "In einem Binärbaum wird der Vater als größeres Element",
              "elements": [
                [
                  0,
                  54
                ]
              ],
              "aIdx": 2,
              "label": 0
            }
          ],
          "correctionOrComment": "In einem Binärbaum wird der Vater als größeres Element mit seinen kleineren Kindern dargestellt."
        },
        {
          "text": "DIe Elemente werden in einem binärbaum dargestellt und nacheinander ausgelesen.",
          "id": "7ba019a2553e1137a4bbb8d3c779a48e5ceb2ca3a162e6e0a945ef0f",
          "aspects": [
            {
              "text": "DIe Elemente werden in einem binärbaum dargestellt ",
              "elements": [
                [
                  0,
                  50
                ]
              ],
              "aIdx": 0,
              "label": 1
            }
          ],
          "correctionOrComment": "DIe Elemente werden in einem binärbaum dargestellt und nacheinander ausgelesen."
        },
        {
          "text": "Mit einem Binärbaum suchen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Mit einem Binärbaum suchen",
              "elements": [
                [
                  0,
                  26
                ]
              ],
              "aIdx": 0,
              "label": 1
            }
          ],
          "correctionOrComment": "Mit einem Binärbaum suchen."
        },
        {
          "text": "Man interpretiert die Daten in einem Baum. Mit heapify() wird dieser zu einem Heap gemacht und die Wurzel entfernt. Durch eine weitere Anwendung von heapify() wird der Baum wieder zu einem heap gemacht.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Man interpretiert die Daten in einem Baum",
              "elements": [
                [
                  0,
                  41
                ]
              ],
              "aIdx": 0,
              "label": 1
            }
          ],
          "correctionOrComment": "Man interpretiert die Daten in einem Baum. Mit heapify() wird dieser zu einem Heap gemacht und die Wurzel entfernt. Durch eine weitere Anwendung von heapify() wird der Baum wieder zu einem heap gemacht."
        },
        {
          "text": "Alle Vergleiche werden genutzt. Die Beziehung des Vaters zu seinen Kindern ist stets, dass der Vater größer als seine Kinder ist. Das Maximum ist die Wurzel d.h. immer bekannt in einem Heap. Die Wurzel wird abgeschnitten und in ein Array gepackt, anschließend das letzte Blatt an den Platz der Wurzel gesetzt und der Baum wird zu einem Heap repariert, woraufhin das Maximum wieder bekannt ist und wieder abgeschnitten werden kann...",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Alle Vergleiche werden genutzt",
              "elements": [
                [
                  0,
                  30
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": " Die Beziehung des Vaters zu seinen Kindern ist stets, dass der Vater größer als seine Kinder ist",
              "elements": [
                [
                  32,
                  128
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "Das Maximum ist die Wurzel",
              "elements": [
                [
                  130,
                  156
                ]
              ],
              "aIdx": 2,
              "label": 0
            },
            {
              "text": "Die Wurzel wird abgeschnitten und in ein Array gepackt, anschließend das letzte Blatt an den Platz der Wurzel gesetzt und der Baum wird zu einem Heap repariert, woraufhin das Maximum wieder bekannt ist und wieder abgeschnitten werden kann",
              "elements": [
                [
                  191,
                  429
                ]
              ],
              "aIdx": 3,
              "label": 0
            }
          ],
          "correctionOrComment": "Alle Vergleiche werden genutzt. Die Beziehung des Vaters zu seinen Kindern ist stets, dass der Vater größer als seine Kinder ist. Das Maximum ist die Wurzel d.h. immer bekannt in einem Heap. Die Wurzel wird abgeschnitten und in ein Array gepackt, anschließend das letzte Blatt an den Platz der Wurzel gesetzt und der Baum wird zu einem Heap repariert, woraufhin das Maximum wieder bekannt ist und wieder abgeschnitten werden kann..."
        },
        {
          "text": "Heapsort schreibt alle Positionen eines Arrays in einen Baum, wo immer die Wurzel den größten Wert hat und immer die Wurzel eines Teilbaums den größten Wert des Teilbaums.",
          "id": "0ce8152aa92136af039b687c01c7dccfcb271f3db2d0ddcb3cfdd3e6",
          "aspects": [
            {
              "text": "Heapsort schreibt alle Positionen eines Arrays in einen Baum",
              "elements": [
                [
                  0,
                  60
                ]
              ],
              "aIdx": 0,
              "label": 1
            },
            {
              "text": "immer die Wurzel eines Teilbaums den größten Wert des Teilbaums",
              "elements": [
                [
                  107,
                  170
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "wo immer die Wurzel den größten Wert hat",
              "elements": [
                [
                  62,
                  102
                ]
              ],
              "aIdx": 2,
              "label": 0
            }
          ],
          "correctionOrComment": "Heapsort schreibt alle Positionen eines Arrays in einen Baum, wo immer die Wurzel den größten Wert hat und immer die Wurzel eines Teilbaums den größten Wert des Teilbaums."
        },
        {
          "text": "Bei dem Heapsort wird zunächst aus der gegebenen Menge ein heap erstellt. Bei dem Heap ist die Wurzel das größte Element. Nun nimmt man die Wurzel hinaus und setzt das letzte Element des Heaps als neue Wurzel und stellt erneut den heap durch heapify wieder her. Dies wird solange wiederholt bis der heap leer ist.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "aspects": [
            {
              "text": "Bei dem Heapsort wird zunächst aus der gegebenen Menge ein heap erstellt",
              "elements": [
                [
                  0,
                  72
                ]
              ],
              "aIdx": 0,
              "label": 1
            },
            {
              "text": " Bei dem Heap ist die Wurzel das größte Element",
              "elements": [
                [
                  74,
                  120
                ]
              ],
              "aIdx": 2,
              "label": 0
            },
            {
              "text": "Nun nimmt man die Wurzel hinaus und setzt das letzte Element des Heaps als neue Wurzel und stellt erneut den heap durch heapify wieder her. Dies wird solange wiederholt bis der heap leer ist",
              "elements": [
                [
                  122,
                  312
                ]
              ],
              "aIdx": 3,
              "label": 0
            }
          ],
          "correctionOrComment": "Bei dem Heapsort wird zunächst aus der gegebenen Menge ein heap erstellt. Bei dem Heap ist die Wurzel das größte Element. Nun nimmt man die Wurzel hinaus und setzt das letzte Element des Heaps als neue Wurzel und stellt erneut den heap durch heapify wieder her. Dies wird solange wiederholt bis der heap leer ist."
        },
        {
          "text": "Die Menge wird als ein Heap betrachtet, bei dem der Vater immer größer als seine Kinder ist. Dann entspricht die Wurzel immer dem Maximum und dieses kann mehrmals herausgelesen werden.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Die Menge wird als ein Heap betrachtet",
              "elements": [
                [
                  0,
                  38
                ]
              ],
              "aIdx": 0,
              "label": 1
            },
            {
              "text": "bei dem der Vater immer größer als seine Kinder ist",
              "elements": [
                [
                  40,
                  91
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "Dann entspricht die Wurzel immer dem Maximum",
              "elements": [
                [
                  93,
                  137
                ]
              ],
              "aIdx": 2,
              "label": 0
            },
            {
              "text": "dieses kann mehrmals herausgelesen werden",
              "elements": [
                [
                  142,
                  183
                ]
              ],
              "aIdx": 3,
              "label": 0
            }
          ],
          "correctionOrComment": "Die Menge wird als ein Heap betrachtet, bei dem der Vater immer größer als seine Kinder ist. Dann entspricht die Wurzel immer dem Maximum und dieses kann mehrmals herausgelesen werden."
        },
        {
          "text": "die Idee ist das in einem Heap alles unter einem Knoten sortiert ist",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "die Idee ist das in einem Heap alles unter einem Knoten sortiert ist",
              "elements": [
                [
                  0,
                  68
                ]
              ],
              "aIdx": 2,
              "label": 1
            }
          ],
          "correctionOrComment": "die Idee ist das in einem Heap alles unter einem Knoten sortiert ist"
        },
        {
          "text": "Ein Array als Baum zu definieren und dann die größten Elemente sortiert in ein neues Array zu übertragen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Ein Array als Baum zu definieren",
              "elements": [
                [
                  0,
                  32
                ]
              ],
              "aIdx": 0,
              "label": 1
            },
            {
              "text": "die größten Elemente sortiert in ein neues Array zu übertragen",
              "elements": [
                [
                  42,
                  104
                ]
              ],
              "aIdx": 3,
              "label": 1
            }
          ],
          "correctionOrComment": "Ein Array als Baum zu definieren und dann die größten Elemente sortiert in ein neues Array zu übertragen."
        },
        {
          "text": "Das Array als Binärbaum zu betrachten und den so zu sortieren, dass Vater größer als jedes Kind ist.",
          "id": "408f0afbe2440a4383a1e75b7d5b0b4202c7f7131a9acf9bd70492f3",
          "aspects": [
            {
              "text": "Das Array als Binärbaum zu betrachten",
              "elements": [
                [
                  0,
                  37
                ]
              ],
              "aIdx": 0,
              "label": 1
            },
            {
              "text": "dass Vater größer als jedes Kind ist",
              "elements": [
                [
                  63,
                  99
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Das Array als Binärbaum zu betrachten und dann so zu sortieren, dass Vater größer als jedes Kind ist."
        },
        {
          "text": "Suchen in form von bäumen",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [],
          "correctionOrComment": "Suchen in form von bäumen"
        },
        {
          "text": "die idee ist es, das array in einen binärbaum zu sortieren, der voraussetzt, dass der Knoten immer größer als die Kinder ist. Mit dieser Information kann man immer die Wurzel rausziehen und nach und nach den Heap abbauen",
          "id": "c1b8144ee1a30244a571c3d9b48b2c394a7489065d2565968f521645",
          "aspects": [
            {
              "text": "Die Idee ist es, das Array in einen Binärbaum zu sortieren",
              "elements": [],
              "aIdx": 0,
              "label": 1
            },
            {
              "text": "dass der Knoten immer größer als die Kinder ist",
              "elements": [
                [
                  77,
                  124
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "Mit dieser Information kann man immer die Wurzel rausziehen und nach und nach den Heap abbauen",
              "elements": [
                [
                  126,
                  220
                ]
              ],
              "aIdx": 3,
              "label": 0
            }
          ],
          "correctionOrComment": "Die Idee ist es, das Array in einen Binärbaum zu sortieren, der voraussetzt, dass der Knoten immer größer als die Kinder ist. Mit dieser Information kann man immer die Wurzel rausziehen und nach und nach den Heap abbauen"
        },
        {
          "text": "Die zu sortierenden Elemente werden in einem Binärbaum angeordnet und mithilfe der Operation heapify () sortiert",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6",
          "aspects": [
            {
              "text": "Die zu sortierenden Elemente werden in einem Binärbaum angeordnet ",
              "elements": [
                [
                  0,
                  65
                ]
              ],
              "aIdx": 0,
              "label": 1
            }
          ],
          "correctionOrComment": "Die zu sortierenden Elemente werden in einem Binärbaum angeordnet und mithilfe der Operation heapify () sortiert"
        },
        {
          "text": "kjk",
          "id": "192f56eb9bd894a72b30c303247b107be2c4591f310dd69a67927f48",
          "aspects": [],
          "correctionOrComment": "kjk"
        },
        {
          "text": "Das Array wird in einen Binärbaum mit der Eigenschaft, dass alle Väter größer als ihre Kinder sind, umgewandelt. Dadurch ist die Wurzel der größte Eintrag. Diese wird rausgenommen, das letzte Blatt hochgetauscht und dann wird das Ganze mit dem verbleibenden Teilarray gemacht.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Das Array wird in einen Binärbaum ;; umgewandelt",
              "elements": [
                [
                  0,
                  33
                ],
                [
                  100,
                  111
                ]
              ],
              "aIdx": 0,
              "label": 1
            },
            {
              "text": "alle Väter größer als ihre Kinder sind",
              "elements": [
                [
                  60,
                  98
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "Dadurch ist die Wurzel der größte Eintrag",
              "elements": [
                [
                  113,
                  154
                ]
              ],
              "aIdx": 2,
              "label": 0
            },
            {
              "text": "Es wird iterativ entfernt und der Baum wird wiederhergestellt",
              "elements": [],
              "aIdx": 3,
              "label": 0
            }
          ],
          "correctionOrComment": "Das Array wird in einen Binärbaum mit der Eigenschaft, dass alle Väter größer als ihre Kinder sind, umgewandelt. Dadurch ist die Wurzel der größte Eintrag. Diese wird rausgenommen, das letzte Blatt hochgetauscht und dann wird das Ganze mit dem verbleibenden Teilarray gemacht."
        },
        {
          "text": "Ein Binärbaum mit Vater-Kind-Beziehung.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "aspects": [],
          "correctionOrComment": "Ein Binärbaum mit Vater-Kind-Beziehung."
        },
        {
          "text": "Ein Array wird als binärer Baum interpretiert, der die Heapbedingung erfüllt. Die Maximumssuche kann jetzt n mal in der Zeit logn  durchgeführt werden.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "aspects": [
            {
              "text": "Ein Array wird als binärer Baum interpretiert",
              "elements": [
                [
                  0,
                  45
                ]
              ],
              "aIdx": 0,
              "label": 1
            }
          ],
          "correctionOrComment": "Ein Array wird als binärer Baum interpretiert, der die Heapbedingung erfüllt. Die Maximumssuche kann jetzt n mal in der Zeit logn durchgeführt werden."
        },
        {
          "text": "Ein Array wird als Binärbaum interpretiert, wodurch man bei jedem Vergleich Informationen speichert und somit wiederverwerten kann.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Ein Array wird als Binärbaum interpretiert, wodurch man bei jedem Vergleich Informationen speichert und somit wiederverwerten kann",
              "elements": [
                [
                  0,
                  130
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ],
          "correctionOrComment": "Ein Array wird als Binärbaum interpretiert, wodurch man bei jedem Vergleich Informationen speichert und somit wiederverwerten kann."
        },
        {
          "text": "Die Elemente werden in einem Binärbaum angeordnet. Der Vater ist hierbei immer größer als die Kinder. Um diese Bedingung zu erfüllen muss heapify auf jeder der Teilbäume angewendet werden.",
          "id": "b51d18b551043c1f145f22dbde6f8531faeaf68c54ed9dd79ce24d17",
          "aspects": [
            {
              "text": "Die Elemente werden in einem Binärbaum angeordnet",
              "elements": [
                [
                  0,
                  49
                ]
              ],
              "aIdx": 0,
              "label": 1
            },
            {
              "text": "Der Vater ist hierbei immer größer als die Kinder",
              "elements": [
                [
                  51,
                  100
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Die Elemente werden in einem Binärbaum angeordnet. Der Vater ist hierbei immer größer als die Kinder. Um diese Bedingung zu erfüllen muss heapify auf jeder der Teilbäume angewendet werden."
        },
        {
          "text": "Die Elemente werden so in einem Binärbaum arrangiert, dass eine Kante immer einen Vergleich zwischen zwei Elementen darstellt, bei welchem der Vater das größere Element ist. Die so gespeicherten Vergleichsinformationen verschnellern die Suche nach dem größten Element.",
          "id": "8416c38cc898f1ac7cc9d64e89dab1f70f5ddab002a5b2a1713f93f5",
          "aspects": [
            {
              "text": "bei welchem der Vater das größere Element is; Die so gespeicherten Vergleichsinformationen verschnellern die Suche nach dem größten Element",
              "elements": [],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "Die Elemente werden so in einem Binärbaum arrangiert, dass eine Kante immer einen Vergleich zwischen zwei Elementen darstellt ;",
              "elements": [],
              "aIdx": 0,
              "label": 0
            }
          ],
          "correctionOrComment": "Die Elemente werden so in einem Binärbaum arrangiert, dass eine Kante immer einen Vergleich zwischen zwei Elementen darstellt, bei welchem der Vater das größere Element ist. Die so gespeicherten Vergleichsinformationen verschnellern die Suche nach dem größten Element."
        },
        {
          "text": "Wir bauen einen Binärbaum wo der Vater größer ist als seine Kinder (Heap) und ersetzen die Wurzel (das größte Element ) immer mit einem Blatt und tauschen dann durch bis die Heapbedinngung wieder erfüllt ist",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Wir bauen einen Binärbaum",
              "elements": [
                [
                  0,
                  25
                ]
              ],
              "aIdx": 0,
              "label": 1
            },
            {
              "text": "wo der Vater größer ist als seine Kinder",
              "elements": [
                [
                  26,
                  66
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "ersetzen die Wurzel, das größte Element,",
              "elements": [],
              "aIdx": 2,
              "label": 0
            },
            {
              "text": "und ersetzen die Wurzel, das größte Element, immer mit einem Blatt und tauschen dann durch bis die Heapbedinngung wieder erfüllt ist",
              "elements": [],
              "aIdx": 3,
              "label": 0
            }
          ],
          "correctionOrComment": "Wir bauen einen Binärbaum wo der Vater größer ist als seine Kinder (Heap) und ersetzen die Wurzel, das größte Element, immer mit einem Blatt und tauschen dann durch bis die Heapbedinngung wieder erfüllt ist"
        },
        {
          "text": "heapsort nutzt einen Baum um die Werte zu speichern mit der Bedingung Kinder sind kleiner als Eltern",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c",
          "aspects": [
            {
              "text": "Heapsort nutzt einen Baum um die Werte zu speichern ",
              "elements": [],
              "aIdx": 0,
              "label": 1
            },
            {
              "text": "mit der Bedingung Kinder sind kleiner als Eltern",
              "elements": [
                [
                  52,
                  100
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Heapsort nutzt einen Baum um die Werte zu speichern mit der Bedingung Kinder sind kleiner als Eltern"
        },
        {
          "text": "Ein Baum verwenden um so immer den größten ans ende zu packen",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [],
          "correctionOrComment": "Ein Baum verwenden um so immer den größten ans ende zu packen"
        },
        {
          "text": "Baum",
          "id": "ae8820303e493738a211ebb2ae3a2f90b286f20f767609beb77522c0",
          "aspects": [],
          "correctionOrComment": "Baum"
        },
        {
          "text": "Die Menge wird als Baum darestellt. Die Kanten bilden dabei jeweils Vergleiche, wobei der Knoten jeweils Größer als seine Kinder ist.",
          "id": "b8607e0369fbf3e33bc0e358f840915d8c085d1496097351913c0122",
          "aspects": [
            {
              "text": "Die Menge wird als Baum darestellt. Die Kanten bilden dabei jeweils Vergleiche",
              "elements": [
                [
                  0,
                  78
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "wobei der Knoten jeweils Größer als seine Kinder ist",
              "elements": [
                [
                  80,
                  132
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Die Menge wird als Baum darestellt. Die Kanten bilden dabei jeweils Vergleiche, wobei der Knoten jeweils Größer als seine Kinder ist."
        },
        {
          "text": "Wir interpretieren das Array als Baum, bei dem jeder Knoten im Wert größer ist als seine Kinder. Beim Aufbau eines Heaps merken wir uns an den Kanten die schon erfolgten Vergleiche und nutzen diese später wieder. Wenn der Heap aufgebaut ist, steht auf jeden Fall das größte Element in der Wurzel. Diese wird dann abgeschnitten und an die letzte Stelle im Array geschrieben. Das letzte Blatt (also der vorletzte Wert im Array) wird dann in die Wurzel geschrieben. Dann werden solange Täusche vorgenommen bis diese neue Zahl an der richtigen Stelle steht du somit der Baum wieder ein heap ist. dann steht wieder das größte Element in der Wurzel und kann ins zweitletzte Element des Arrays geschrieben werden.",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c",
          "aspects": [
            {
              "text": "Wir interpretieren das Array als Baum ;;  Beim Aufbau eines Heaps merken wir uns an den Kanten die schon erfolgten Vergleiche und nutzen diese später wieder",
              "elements": [
                [
                  0,
                  37
                ],
                [
                  97,
                  211
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "bei dem jeder Knoten im Wert größer ist als seine Kinder",
              "elements": [
                [
                  39,
                  95
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "Wenn der Heap aufgebaut ist, steht auf jeden Fall das größte Element in der Wurzel",
              "elements": [
                [
                  213,
                  295
                ]
              ],
              "aIdx": 2,
              "label": 0
            },
            {
              "text": "Diese wird dann abgeschnitten und an die letzte Stelle im Array geschrieben. Das letzte Blatt (also der vorletzte Wert im Array) wird dann in die Wurzel geschrieben. Dann werden solange Täusche vorgenommen bis diese neue Zahl an der richtigen Stelle steht du somit der Baum wieder ein heap ist. dann steht wieder das größte Element in der Wurzel und kann ins zweitletzte Element des Arrays geschrieben werden",
              "elements": [
                [
                  297,
                  705
                ]
              ],
              "aIdx": 3,
              "label": 0
            }
          ],
          "correctionOrComment": "Wir interpretieren das Array als Baum, bei dem jeder Knoten im Wert größer ist als seine Kinder. Beim Aufbau eines Heaps merken wir uns an den Kanten die schon erfolgten Vergleiche und nutzen diese später wieder. Wenn der Heap aufgebaut ist, steht auf jeden Fall das größte Element in der Wurzel. Diese wird dann abgeschnitten und an die letzte Stelle im Array geschrieben. Das letzte Blatt (also der vorletzte Wert im Array) wird dann in die Wurzel geschrieben. Dann werden solange Täusche vorgenommen bis diese neue Zahl an der richtigen Stelle steht du somit der Baum wieder ein heap ist. dann steht wieder das größte Element in der Wurzel und kann ins zweitletzte Element des Arrays geschrieben werden."
        },
        {
          "text": "Binärer Baum, Kanten repräsintieren Vergleiche, Vater größer als Kinder",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Binärer Baum, Kanten repräsintieren Vergleiche",
              "elements": [
                [
                  0,
                  46
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Vater größer als Kinder",
              "elements": [
                [
                  48,
                  71
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Binärer Baum, Kanten repräsintieren Vergleiche, Vater größer als Kinder"
        },
        {
          "text": "Ein binärer Baum, bei dem jeder Vater größer als seine beiden Kinder ist",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "bei dem jeder Vater größer als seine beiden Kinder ist",
              "elements": [
                [
                  18,
                  72
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Ein binärer Baum, bei dem jeder Vater größer als seine beiden Kinder ist"
        }
      ]
    },
    {
      "text": "Welche Eigenschaften eines Heaps sind essentiell für das Sortieren?",
      "id": 50890,
      "title": "Eigenschaften eines Heaps",
      "type": "description",
      "aspects": [
        {
          "text": "Jeder Vater ist größer als seine Söhne"
        },
        {
          "text": "Der größte Wert ist in der Wurzel",
          "implied": true
        },
        {
          "text": "maximale Tiefe von log(n)"
        }
      ],
      "referenceAnswers": [
        {
          "text": "In einem Heap ist jeder Vater größer als seine Söhne, der größte Wert ist in der Wurzel und er hat maximale Tiefe von log(n).",
          "aspects": [
            {
              "text": "In einem Heap ist jeder Vater größer als seine Söhne",
              "aIdx": 0,
              "elements": [
                [
                  0,
                  52
                ]
              ]
            },
            {
              "text": "der größte Wert ist in der Wurzel",
              "aIdx": 1,
              "elements": [
                [
                  54,
                  87
                ]
              ]
            },
            {
              "text": "er hat maximale Tiefe von log(n)",
              "aIdx": 2,
              "elements": [
                [
                  92,
                  124
                ]
              ]
            }
          ]
        }
      ],
      "studentAnswers": [
        {
          "text": "Der Vater ist größer als die Kinder",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Der Vater ist größer als die Kinder",
              "elements": [
                [
                  0,
                  35
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ],
          "correctionOrComment": "Der Vater ist größer als die Kinder"
        },
        {
          "text": "Binärbaum, also nur zwei Kinder pro Vater.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Binärbaum, also nur zwei Kinder pro Vater",
              "elements": [
                [
                  0,
                  41
                ]
              ],
              "aIdx": 2,
              "label": 1
            }
          ],
          "correctionOrComment": "Binärbaum, also nur zwei Kinder pro Vater."
        },
        {
          "text": "Ein Heap ist ein Binärbaum, in dem jeder Vater größer oder gleich den Kindern ist.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "in dem jeder Vater größer oder gleich den Kindern ist",
              "elements": [
                [
                  28,
                  81
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Ein Heap ist ein Binärbaum",
              "elements": [
                [
                  0,
                  26
                ]
              ],
              "aIdx": 2,
              "label": 1
            }
          ],
          "correctionOrComment": "Ein Heap ist ein Binärbaum, in dem jeder Vater größer oder gleich den Kindern ist."
        },
        {
          "text": "Kinder sind kleiner als der Vater. Darstellung in einem Binärbaum. Wurzel ist das größte Element.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Kinder sind kleiner als der Vater",
              "elements": [
                [
                  0,
                  33
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Wurzel ist das größte Element",
              "elements": [
                [
                  67,
                  96
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "Darstellung in einem Binärbaum",
              "elements": [
                [
                  35,
                  65
                ]
              ],
              "aIdx": 2,
              "label": 1
            }
          ],
          "correctionOrComment": "Kinder sind kleiner als der Vater. Darstellung in einem Binärbaum. Wurzel ist das größte Element."
        },
        {
          "text": "Die Väter sind größer als die Kinder",
          "id": "7ba019a2553e1137a4bbb8d3c779a48e5ceb2ca3a162e6e0a945ef0f",
          "aspects": [
            {
              "text": "Die Väter sind größer als die Kinder",
              "elements": [
                [
                  0,
                  36
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ],
          "correctionOrComment": "Die Väter sind größer als die Kinder"
        },
        {
          "text": "Die Eigenschaft, dass er ein Binärbaum ist, also jeder Vater nur zwei Kinder hat, und dass der Vater immer größer als die Kinder ist.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "und dass der Vater immer größer als die Kinder ist",
              "elements": [
                [
                  82,
                  132
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "ie Eigenschaft, dass er ein Binärbaum ist, also jeder Vater nur zwei Kinder hat",
              "elements": [
                [
                  1,
                  80
                ]
              ],
              "aIdx": 2,
              "label": 1
            }
          ],
          "correctionOrComment": "Die Eigenschaft, dass er ein Binärbaum ist, also jeder Vater nur zwei Kinder hat, und dass der Vater immer größer als die Kinder ist."
        },
        {
          "text": "Der vater ist größer als das kind un ddas maximum ist die wurzel also bekannt!",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Der Vater ist größer als das Kind",
              "elements": [],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "das Maximum ist die Wurzel",
              "elements": [],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Der Vater ist größer als das Kind und das Maximum ist die Wurzel also bekannt!"
        },
        {
          "text": "Dass die Wurzel jedes Teilbaums immer der größte Wert des Teilbaums ist.",
          "id": "0ce8152aa92136af039b687c01c7dccfcb271f3db2d0ddcb3cfdd3e6",
          "aspects": [
            {
              "text": "Dass die Wurzel jedes Teilbaums immer der größte Wert des Teilbaums ist",
              "elements": [
                [
                  0,
                  71
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Dass die Wurzel jedes Teilbaums immer der größte Wert des Teilbaums ist."
        },
        {
          "text": "Das größte Element des Heaps steht in der Wurzel.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "aspects": [
            {
              "text": "Das größte Element des Heaps steht in der Wurzel",
              "elements": [
                [
                  0,
                  48
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Das größte Element des Heaps steht in der Wurzel."
        },
        {
          "text": "Der Vater ist immer größer als seine Kinder, die Wurzel ist immer das Maximum.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "er Vater ist immer größer als seine Kinder",
              "elements": [
                [
                  1,
                  43
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "die Wurzel ist immer das Maximum",
              "elements": [
                [
                  45,
                  77
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Der Vater ist immer größer als seine Kinder, die Wurzel ist immer das Maximum."
        },
        {
          "text": "das jeder Teilbaum ein Heap ist",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [],
          "correctionOrComment": "das jeder Teilbaum ein Heap ist"
        },
        {
          "text": "Die Wurzel muss den größten Wert haben und die Kinder immer kleiner sein als ihre Väter.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": " die Kinder immer kleiner sein als ihre Väter",
              "elements": [
                [
                  43,
                  87
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Die Wurzel muss den größten Wert haben",
              "elements": [
                [
                  0,
                  38
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Die Wurzel muss den größten Wert haben und die Kinder immer kleiner sein als ihre Väter."
        },
        {
          "text": "Das linke Kind = 2i+1, das rechte Kind 2i+2, Vater (i-1)\\/2 ist größer als Kinder",
          "id": "408f0afbe2440a4383a1e75b7d5b0b4202c7f7131a9acf9bd70492f3",
          "aspects": [
            {
              "text": " Vater ist größer als Kinder",
              "elements": [],
              "aIdx": 0,
              "label": 0
            }
          ],
          "correctionOrComment": " Vater ist größer als Kinder"
        },
        {
          "text": "Dass der Vater und die Kinder bekannt sind",
          "id": "271f93f45e9b4067327ed5c8cd30a034730aaace4382803c3e1d6c2f",
          "aspects": [],
          "correctionOrComment": "Dass der Vater und die Kinder bekannt sind"
        },
        {
          "text": "muss ein binärbaum mit tiefe log(n) sein und die Väter größer als ihre kinder.",
          "id": "c1b8144ee1a30244a571c3d9b48b2c394a7489065d2565968f521645",
          "aspects": [
            {
              "text": " die Väter größer als ihre kinder",
              "elements": [
                [
                  45,
                  77
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Muss ein Binärbaum mit tiefe log(n) sein",
              "elements": [],
              "aIdx": 2,
              "label": 0
            }
          ],
          "correctionOrComment": "Muss ein Binärbaum mit tiefe log(n) sein und die Väter größer als ihre kinder."
        },
        {
          "text": "Die Wurzel ist das größte Element. Die Kindsknoten bzw. Blätter sind kleiner als der Vater.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6",
          "aspects": [
            {
              "text": "Die Kindsknoten bzw. Blätter sind kleiner als der Vater",
              "elements": [
                [
                  35,
                  90
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Die Wurzel ist das größte Element",
              "elements": [
                [
                  0,
                  33
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Die Wurzel ist das größte Element. Die Kindsknoten bzw. Blätter sind kleiner als der Vater."
        },
        {
          "text": "lm,lm",
          "id": "192f56eb9bd894a72b30c303247b107be2c4591f310dd69a67927f48",
          "aspects": [],
          "correctionOrComment": "lm,lm"
        },
        {
          "text": "Dass der Vater größer ist als seine Kinder, dass nur die letzte Ebene (die Blätter) und evtl. ein Teil der vorletzten Ebene keine Kinder hat.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Dass der Vater größer ist als seine Kinder,",
              "elements": [
                [
                  0,
                  43
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ],
          "correctionOrComment": "Dass der Vater größer ist als seine Kinder, dass nur die letzte Ebene (die Blätter) und evtl. ein Teil der vorletzten Ebene keine Kinder hat."
        },
        {
          "text": "Die Vater-Kind-Beziehung",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "aspects": [],
          "correctionOrComment": "Die Vater-Kind-Beziehung"
        },
        {
          "text": "Die Heapbedingung ist erfüllt, die Wurzel jedes Teilbaums ist größer als die Kinder.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "aspects": [
            {
              "text": "die Wurzel jedes Teilbaums ist größer als die Kinder",
              "elements": [
                [
                  31,
                  83
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "die Wurzel jedes Teilbaums ist größer als die Kinder",
              "elements": [
                [
                  31,
                  83
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Die Heapbedingung ist erfüllt, die Wurzel jedes Teilbaums ist größer als die Kinder."
        },
        {
          "text": "Dass der Vater immer größer ist als seine Kinder, somit die Wurzel der größte Wert des gesamten Arrays ist.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Dass der Vater immer größer ist als seine Kinder",
              "elements": [
                [
                  0,
                  48
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": " somit die Wurzel der größte Wert des gesamten Arrays ist",
              "elements": [
                [
                  50,
                  106
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Dass der Vater immer größer ist als seine Kinder, somit die Wurzel der größte Wert des gesamten Arrays ist."
        },
        {
          "text": "Die Wurzel ist das Maximum",
          "id": "b51d18b551043c1f145f22dbde6f8531faeaf68c54ed9dd79ce24d17",
          "aspects": [
            {
              "text": "Die Wurzel ist das Maximum",
              "elements": [
                [
                  0,
                  26
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Die Wurzel ist das Maximum"
        },
        {
          "text": "Dass in der Wurzel immer das größte Element steht",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Dass in der Wurzel immer das größte Element steht",
              "elements": [
                [
                  0,
                  49
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Dass in der Wurzel immer das größte Element steht"
        },
        {
          "text": "Die Bedingung dass die Kinder immer kleiner sind als die Eltern",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c",
          "aspects": [
            {
              "text": "Die Bedingung dass die Kinder immer kleiner sind als die Eltern",
              "elements": [
                [
                  0,
                  63
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ],
          "correctionOrComment": "Die Bedingung dass die Kinder immer kleiner sind als die Eltern"
        },
        {
          "text": "Vater größer als Kinder",
          "id": "ae8820303e493738a211ebb2ae3a2f90b286f20f767609beb77522c0",
          "aspects": [
            {
              "text": "Vater größer als Kinder",
              "elements": [
                [
                  0,
                  23
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ],
          "correctionOrComment": "Vater größer als Kinder"
        },
        {
          "text": "Alle Ebenen bis auf die letzte müssen vollständig gefüllt sein.",
          "id": "b8607e0369fbf3e33bc0e358f840915d8c085d1496097351913c0122",
          "aspects": [],
          "correctionOrComment": "Alle Ebenen bis auf die letzte müssen vollständig gefüllt sein."
        },
        {
          "text": "Der Binärbaum muss vorsortiert sein",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6",
          "aspects": [],
          "correctionOrComment": "Der Binärbaum muss vorsortiert sein"
        },
        {
          "text": "Für jeden Knoten gilt dass seine Kinder kleiner sind als er selbst. Wenn Kinder da sind.",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c",
          "aspects": [
            {
              "text": "Für jeden Knoten gilt dass seine Kinder kleiner sind als er selbst",
              "elements": [
                [
                  0,
                  66
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ],
          "correctionOrComment": "Für jeden Knoten gilt dass seine Kinder kleiner sind als er selbst. Wenn Kinder da sind."
        },
        {
          "text": "Die Kanten stelllen einen Vergleich da, der Vater ist größer als seine beiden Kinder",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "der Vater ist größer als seine beiden Kinder",
              "elements": [
                [
                  40,
                  84
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ],
          "correctionOrComment": "Die Kanten stelllen einen Vergleich da, der Vater ist größer als seine beiden Kinder"
        }
      ]
    },
    {
      "text": "Wie muss ein Binärbaum strukturiert sein um ihn in einer Laufzeit von n*log(n) in einen Heap transformiert werden zu können? Die Binärbäume in den folgenden Aufgaben weisen stets diese Struktur auf.",
      "id": 50891,
      "title": "Struktur eines Heap",
      "type": "description",
      "aspects": [
        {
          "text": "Alle Ebenen des Baumes, bis auf die letzte, müssen vollständig befüllt sein"
        },
        {
          "text": "Auf der vorletzten Ebene darf maximal ein Teilbaum nicht voll besetzt sein."
        }
      ],
      "referenceAnswers": [
        {
          "text": "Alle Ebenen des Baumes, bis auf die letzte, müssen vollständig befüllt sein. Auf der vorletzten Ebene darf maximal ein Teilbaum nicht voll besetzt sein.",
          "aspects": [
            {
              "text": "Alle Ebenen des Baumes, bis auf die letzte, müssen vollständig befüllt sein",
              "aIdx": 0,
              "elements": [
                [
                  0,
                  75
                ]
              ]
            },
            {
              "text": "Auf der vorletzten Ebene darf maximal ein Teilbaum nicht voll besetzt sein",
              "aIdx": 1,
              "elements": [
                [
                  77,
                  151
                ]
              ]
            }
          ]
        }
      ],
      "studentAnswers": [
        {
          "text": "er muss sortiert sein der größte wert in der wurzel die kleinsten in den Blätter, es muss ein binärbaum sein",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [],
          "correctionOrComment": "Er muss sortiert sein, der größte Wert in der Wurzel die Kleinsten in den Blättern, es muss ein Binärbaum sein"
        },
        {
          "text": "Alle Ebenen des Baumes, bis auf die letzte, müssen vollständig befüllt sein. Die letzte Ebene muss vom linken Ende bis zum rechtesten Element vollständig befüllt sein.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Alle Ebenen des Baumes, bis auf die letzte, müssen vollständig befüllt sein",
              "elements": [
                [
                  0,
                  75
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Die letzte Ebene muss vom linken Ende bis zum rechtesten Element vollständig befüllt sein",
              "elements": [
                [
                  77,
                  166
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Alle Ebenen des Baumes, bis auf die letzte, müssen vollständig befüllt sein. Die letzte Ebene muss vom linken Ende bis zum rechtesten Element vollständig befüllt sein."
        },
        {
          "text": "Ein Knoten hat maximal zwei Kinder.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [],
          "correctionOrComment": "Ein Knoten hat maximal zwei Kinder."
        },
        {
          "text": "geht das nicht bei jedem?",
          "id": "7ba019a2553e1137a4bbb8d3c779a48e5ceb2ca3a162e6e0a945ef0f",
          "aspects": [],
          "correctionOrComment": "geht das nicht bei jedem?"
        },
        {
          "text": "Er muss eine Tiefe von maximal n*log(n) haben.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Er muss eine Tiefe von maximal n*log(n) haben",
              "elements": [
                [
                  0,
                  45
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ],
          "correctionOrComment": "Er muss eine Tiefe von maximal n*log(n) haben."
        },
        {
          "text": "er muss die maximale tiefe log(n) haben. Alle möglichen Positionen sind besetzt. geringst mögliche tiefe. Jeder Vater hat zwangsläufig 2 kinder außer der letzte.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "er muss die maximale tiefe log(n) haben",
              "elements": [
                [
                  0,
                  39
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Jeder Vater hat zwangsläufig 2 kinder außer der letzte",
              "elements": [
                [
                  106,
                  160
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "er muss die maximale tiefe log(n) haben. Alle möglichen Positionen sind besetzt. geringst mögliche tiefe. Jeder Vater hat zwangsläufig 2 kinder außer der letzte."
        },
        {
          "text": "Er muss schon vorsortiert sein.",
          "id": "0ce8152aa92136af039b687c01c7dccfcb271f3db2d0ddcb3cfdd3e6",
          "aspects": [],
          "correctionOrComment": "Er muss schon vorsortiert sein."
        },
        {
          "text": "Der Binärbaum muss in den beiden Kindern der Wurzel Heaps besitzen.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "aspects": [],
          "correctionOrComment": "Der Binärbaum muss in den beiden Kindern der Wurzel Heaps besitzen."
        },
        {
          "text": "Die Ebenen müssen soweit aufgefüllt werden, wie es möglich ist.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Die Ebenen müssen soweit aufgefüllt werden, wie es möglich ist",
              "elements": [
                [
                  0,
                  62
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ],
          "correctionOrComment": "Die Ebenen müssen soweit aufgefüllt werden, wie es möglich ist."
        },
        {
          "text": "unsortiert",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [],
          "correctionOrComment": "unsortiert"
        },
        {
          "text": "darf nur 2 kinder haben, muss tiefe log(n) haben",
          "id": "c1b8144ee1a30244a571c3d9b48b2c394a7489065d2565968f521645",
          "aspects": [
            {
              "text": "muss tiefe log(n) haben",
              "elements": [
                [
                  25,
                  48
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ],
          "correctionOrComment": "darf nur 2 kinder haben, muss tiefe log(n) haben"
        },
        {
          "text": "klkl",
          "id": "192f56eb9bd894a72b30c303247b107be2c4591f310dd69a67927f48",
          "aspects": [],
          "correctionOrComment": "klkl"
        },
        {
          "text": "Egal wie.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [],
          "correctionOrComment": "Egal wie."
        },
        {
          "text": "Er muss konstanz gefüllt sein.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "aspects": [
            {
              "text": "Er muss konstant gefüllt sein",
              "elements": [],
              "aIdx": 0,
              "label": 1
            }
          ],
          "correctionOrComment": "Er muss konstant gefüllt sein."
        },
        {
          "text": "Wir füllen die Knoten von oben nach unten und von links nach rechts auf, anschließend überprüfen wir jeden Knoten, ob er die Bedinngungen erfüllt",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Wir füllen die Knoten von oben nach unten ",
              "elements": [
                [
                  0,
                  41
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Wir füllen die Knoten ;; von links nach rechts auf",
              "elements": [
                [
                  0,
                  21
                ],
                [
                  46,
                  71
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Wir füllen die Knoten von oben nach unten und von links nach rechts auf, anschließend überprüfen wir jeden Knoten, ob er die Bedinngungen erfüllt"
        },
        {
          "text": "geringe TIefe",
          "id": "ae8820303e493738a211ebb2ae3a2f90b286f20f767609beb77522c0",
          "aspects": [],
          "correctionOrComment": "geringe TIefe"
        },
        {
          "text": "Er muss als Suchbaum strukturiert sein.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6",
          "aspects": [],
          "correctionOrComment": "Er muss als Suchbaum strukturiert sein."
        },
        {
          "text": "Bis auf die letzte Ebene vollständig gefüllt, diese soweit wie möglich von links nach rechts gefüllt",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Bis auf die letzte Ebene vollständig gefüllt",
              "elements": [
                [
                  0,
                  44
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "diese soweit wie möglich von links nach rechts gefüllt",
              "elements": [
                [
                  46,
                  100
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Bis auf die letzte Ebene vollständig gefüllt, diese soweit wie möglich von links nach rechts gefüllt"
        },
        {
          "text": "alle Ebenen muss vollständig gefüllt sein",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "alle Ebenen muss vollständig gefüllt sein",
              "elements": [
                [
                  0,
                  41
                ]
              ],
              "aIdx": 0,
              "label": 2
            }
          ],
          "correctionOrComment": "alle Ebenen muss vollständig gefüllt sein"
        }
      ]
    },
    {
      "text": "Wie wird aus einem Binärbaum dessen beiden Teilbäume selber Heaps sind ein Heap erstellt? Wieso benötigt diese Operation eine log(n) Schritte?",
      "id": 50892,
      "title": "Heap reparieren",
      "type": "procedure",
      "aspects": [
        {
          "text": "Das Element in der Wurzel tauscht immer wieder die Position mit dem größeren seiner Kinder bis der Heap wiederhergestellt ist"
        },
        {
          "text": "Der Binärbaum besitzt maximal log(n) Ebenen"
        }
      ],
      "referenceAnswers": [
        {
          "text": "Das Element in der Wurzel tauscht immer wieder die Position mit dem größeren seiner Kinder bis der Heap wiederhergestellt ist. Der Binärbaum besitzt maximal log(n) Ebenen.",
          "aspects": [
            {
              "text": "Das Element in der Wurzel tauscht immer wieder die Position mit dem größeren seiner Kinder bis der Heap wiederhergestellt ist",
              "aIdx": 0,
              "elements": [
                [
                  0,
                  125
                ]
              ]
            },
            {
              "text": "Der Binärbaum besitzt maximal log(n) Ebenen",
              "aIdx": 1,
              "elements": [
                [
                  127,
                  170
                ]
              ]
            }
          ]
        }
      ],
      "studentAnswers": [
        {
          "text": "das letzte (rechteste) Blatt wird die neue Wurzel und solange nach unten getauscht bis der heap wieder sortiert ist",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "das letzte (rechteste) Blatt wird die neue Wurzel und solange nach unten getauscht bis der heap wieder sortiert ist",
              "elements": [
                [
                  0,
                  115
                ]
              ],
              "aIdx": 0,
              "label": 1
            }
          ],
          "correctionOrComment": "das letzte (rechteste) Blatt wird die neue Wurzel und solange nach unten getauscht bis der heap wieder sortiert ist"
        },
        {
          "text": "Das Element in der Wurzel tauscht immer wieder die Position mit dem größeren seiner Kinder, bis es selber wieder ein Blatt ist oder größer ist als beide Kinder. Der Binärbaum besitzt maximal log(n) Ebenen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Das Element in der Wurzel tauscht immer wieder die Position mit dem größeren seiner Kinder, bis es selber wieder ein Blatt ist oder größer ist als beide Kinder",
              "elements": [
                [
                  0,
                  159
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Der Binärbaum besitzt maximal log(n) Ebenen",
              "elements": [
                [
                  161,
                  204
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Das Element in der Wurzel tauscht immer wieder die Position mit dem größeren seiner Kinder, bis es selber wieder ein Blatt ist oder größer ist als beide Kinder. Der Binärbaum besitzt maximal log(n) Ebenen."
        },
        {
          "text": "Heapify auf die Teilbäume anwenden.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [],
          "correctionOrComment": "Heapify auf die Teilbäume anwenden."
        },
        {
          "text": "Das Letzte Blatt wird zur Wurzel und danach wird dieses mit dem jeweils größten Kind getauscht solange das Kinde größer ist. Die Laufzeit ergibt sich daraus, dass die Tiefe des Baumes maximal log(n) ist.",
          "id": "7ba019a2553e1137a4bbb8d3c779a48e5ceb2ca3a162e6e0a945ef0f",
          "aspects": [
            {
              "text": "Das Letzte Blatt wird zur Wurzel und danach wird dieses mit dem jeweils größten Kind getauscht solange das Kinde größer ist",
              "elements": [
                [
                  0,
                  123
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Die Laufzeit ergibt sich daraus, dass die Tiefe des Baumes maximal log(n) ist",
              "elements": [
                [
                  125,
                  202
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Das Letzte Blatt wird zur Wurzel und danach wird dieses mit dem jeweils größten Kind getauscht solange das Kinde größer ist. Die Laufzeit ergibt sich daraus, dass die Tiefe des Baumes maximal log(n) ist."
        },
        {
          "text": "die zwei kinder werden verglichen und das größte der kinder wird mit dem vater getauscht wenn es größer als der vater ist. diese operation wird durchgeführt solange v kinder hat, dh es werden alle knoten auf der strecke auf der getausht wurde überprüft, bis man bei einem blatt ankommt. Die strecke bis man bei einem Blatt ankommt ist die tiefe eines baums, die maximal log(n ) ist. Dh es werden maximal log(n) tauschs durchgeführt.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Die zwei Kinder werden verglichen und das Größte der Kinder wird mit dem Vater getauscht, wenn es größer als der Vater ist. diese Operation wird durchgeführt solange der Vater Kinder hat ;; bis man bei einem Blatt ankommt",
              "elements": [
                [
                  299,
                  330
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Die Strecke bis man bei einem Blatt ankommt ist die Tiefe eines Baums, die maximal log(n ) ist",
              "elements": [],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Die zwei Kinder werden verglichen und das Größte der Kinder wird mit dem Vater getauscht, wenn es größer als der Vater ist. diese Operation wird durchgeführt solange der Vater Kinder hat, dh es werden alle Knoten auf der Strecke auf der getauscht wurde überprüft, bis man bei einem Blatt ankommt. Die Strecke bis man bei einem Blatt ankommt ist die Tiefe eines Baums, die maximal log(n ) ist. Es werden maximal log(n) Tausche durchgeführt."
        },
        {
          "text": "Heapify wird auf jeden Knoten der Teilbäume angewandt. Weil man für jede Reparatur die Kanten entlang gehen muss, also dauert es die Tiefe des Baumes lang und die ist log(n).",
          "id": "0ce8152aa92136af039b687c01c7dccfcb271f3db2d0ddcb3cfdd3e6",
          "aspects": [
            {
              "text": "also dauert es die Tiefe des Baumes lang und die ist log(n)",
              "elements": [
                [
                  114,
                  173
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Heapify wird auf jeden Knoten der Teilbäume angewandt. Weil man für jede Reparatur die Kanten entlang gehen muss, also dauert es die Tiefe des Baumes lang und die ist log(n)."
        },
        {
          "text": "Bei einem Binärbaum, dessen Teilbäume selber Heaps sind muss nur die Wurzel kontrolliert werden, dass für diese die Bedingung gilt.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [],
          "correctionOrComment": "Bei einem Binärbaum, dessen Teilbäume selber Heaps sind muss nur die Wurzel kontrolliert werden, dass für diese die Bedingung gilt."
        },
        {
          "text": "Man tauscht die Wurzel mit dem größten Kind und wiederholt dies bis es größer ist als beide Kinder.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "aspects": [
            {
              "text": "Man tauscht die Wurzel mit dem größten Kind und wiederholt dies bis es größer ist als beide Kinder.",
              "elements": [
                [
                  0,
                  99
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ],
          "correctionOrComment": "Man tauscht die Wurzel mit dem größten Kind und wiederholt dies bis es größer ist als beide Kinder."
        },
        {
          "text": "heapify",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [],
          "correctionOrComment": "heapify"
        },
        {
          "text": "Weil log(n) ist die maximale Tiefe des Baumes. Die Wurzel (der Vater) wird mit beiden Kindern verglichen. Wenn kleiner, wird er mit dem größeren Kind vertauscht. und dann wieder mit den nächsten Kindern usw. bis die Kinder Blätter sind.",
          "id": "408f0afbe2440a4383a1e75b7d5b0b4202c7f7131a9acf9bd70492f3",
          "aspects": [
            {
              "text": "Weil log(n) ist die maximale Tiefe des Baume",
              "elements": [
                [
                  0,
                  44
                ]
              ],
              "aIdx": 1,
              "label": 0
            },
            {
              "text": "Die Wurzel (der Vater) wird mit beiden Kindern verglichen. Wenn kleiner, wird er mit dem größeren Kind vertauscht. und dann wieder mit den nächsten Kindern usw.",
              "elements": [
                [
                  47,
                  207
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ],
          "correctionOrComment": "Weil log(n) ist die maximale Tiefe des Baumes. Die Wurzel (der Vater) wird mit beiden Kindern verglichen. Wenn kleiner, wird er mit dem größeren Kind vertauscht. und dann wieder mit den nächsten Kindern usw. bis die Kinder Blätter sind."
        },
        {
          "text": "Das größte Kind des obersten Knotens (bsp die Wurzel) wird mit dem Koten getauscht",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6",
          "aspects": [
            {
              "text": "Das größte Kind des obersten Knotens (bsp die Wurzel) wird mit dem Koten getauscht",
              "elements": [
                [
                  0,
                  82
                ]
              ],
              "aIdx": 0,
              "label": 1
            }
          ],
          "correctionOrComment": "Das größte Kind des obersten Knotens (bsp die Wurzel) wird mit dem Koten getauscht"
        },
        {
          "text": "die wurzel wird durch heapify mit dem größeren kind vertauscht, dadurch muss der komplette heap nochmals überprüft werden nach fehlstellungen",
          "id": "c1b8144ee1a30244a571c3d9b48b2c394a7489065d2565968f521645",
          "aspects": [
            {
              "text": "Die Wurzel wird durch heapify mit dem größeren Kind vertauscht",
              "elements": [],
              "aIdx": 0,
              "label": 1
            }
          ],
          "correctionOrComment": "Die Wurzel wird durch heapify mit dem größeren Kind vertauscht, dadurch muss der komplette Heap nochmals überprüft werden nach Fehlstellungen"
        },
        {
          "text": "mkm",
          "id": "192f56eb9bd894a72b30c303247b107be2c4591f310dd69a67927f48",
          "aspects": [],
          "correctionOrComment": "mkm"
        },
        {
          "text": "Falls das größere Kind größer ist als der Vater werden diese getauscht. Das runtertauschen einer ungültigen Wurzel benötigt höchstens log(n) Schritte, weil es höchstens für jede Ebene einmal gemacht werden muss und der Baum log(n) viele Ebenen hat.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Falls das größere Kind größer ist als der Vater werden diese getauscht",
              "elements": [
                [
                  0,
                  70
                ]
              ],
              "aIdx": 0,
              "label": 1
            },
            {
              "text": "Das runtertauschen einer ungültigen Wurzel benötigt höchstens log(n) Schritte, weil es höchstens für jede Ebene einmal gemacht werden muss und der Baum log(n) viele Ebenen hat",
              "elements": [
                [
                  72,
                  247
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Falls das größere Kind größer ist als der Vater werden diese getauscht. Das runtertauschen einer ungültigen Wurzel benötigt höchstens log(n) Schritte, weil es höchstens für jede Ebene einmal gemacht werden muss und der Baum log(n) viele Ebenen hat."
        },
        {
          "text": "Es wird die Operation heapify() genutzt.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "aspects": [],
          "correctionOrComment": "Es wird die Operation heapify() genutzt."
        },
        {
          "text": "Die Wurzel muss mit den Kindern verglichen werden und möglicherweise, mit dem größeren getsucht werden. Dieser Schritt muss iterativ, logn mal passieren (entspricht der Tiefe des Tielbaums).",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "aspects": [
            {
              "text": "Die Wurzel muss mit den Kindern verglichen werden und möglicherweise, mit dem größeren getauscht werden. Dieser Schritt muss iterativ, logn mal passieren",
              "elements": [],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Dieser Schritt muss iterativ, log(n) mal passieren. Dies entspricht der Tiefe des Teilbaums",
              "elements": [],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Die Wurzel muss mit den Kindern verglichen werden und möglicherweise, mit dem größeren getauscht werden. Dieser Schritt muss iterativ, log(n) mal passieren. Dies entspricht der Tiefe des Teilbaums."
        },
        {
          "text": "Indem die Wurzel des Baumes die größten Kinder entlang nach unten wandert. Wenn oben einer der kleinsten Wert des ganzen Arrays stand, muss der Knoten die komplette Tiefe des Baumes nach unten wandern. Diese beträgt log(n).",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Indem die Wurzel des Baumes die größten Kinder entlang nach unten wandert",
              "elements": [
                [
                  0,
                  73
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Wenn oben einer der kleinsten Wert des ganzen Arrays stand, muss der Knoten die komplette Tiefe des Baumes nach unten wandern. Diese beträgt log(n)",
              "elements": [
                [
                  75,
                  222
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Indem die Wurzel des Baumes die größten Kinder entlang nach unten wandert. Wenn oben einer der kleinsten Wert des ganzen Arrays stand, muss der Knoten die komplette Tiefe des Baumes nach unten wandern. Diese beträgt log(n)."
        },
        {
          "text": "Wir wissen bereits, dass beide Teilbäume ein Heap sind. Nun muss sichergestellt werden, dass die Wurzel unser Maximum ist. Ist dies nicht der Fall muss die Reparatur durchgeführt werden und somit können wieder Fehler in den einzelnen Teilbäumen entstehen. Wir müssen nach der Änderung der Wurzel für den ganzen Baum kontrollieren ob jeder Teilbaum noch ein Heap ist. Dies benötigt eine Zeit von log n",
          "id": "b51d18b551043c1f145f22dbde6f8531faeaf68c54ed9dd79ce24d17",
          "aspects": [],
          "correctionOrComment": "Wir wissen bereits, dass beide Teilbäume ein Heap sind. Nun muss sichergestellt werden, dass die Wurzel unser Maximum ist. Ist dies nicht der Fall muss die Reparatur durchgeführt werden und somit können wieder Fehler in den einzelnen Teilbäumen entstehen. Wir müssen nach der Änderung der Wurzel für den ganzen Baum kontrollieren ob jeder Teilbaum noch ein Heap ist. Dies benötigt eine Zeit von log n"
        },
        {
          "text": "Max. Log(n) ebenen Die Wurzel wandert runter bis sie größer ist als ihre Kinder oder sie ein Blatt ist",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Die Wurzel wandert runter bis sie größer ist als ihre Kinder oder sie ein Blatt ist",
              "elements": [
                [
                  19,
                  102
                ]
              ],
              "aIdx": 0,
              "label": 1
            },
            {
              "text": "Der Baum hat maximal log(n) Ebenen",
              "elements": [],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Der Baum hat maximal log(n) Ebenen. Die Wurzel wandert runter bis sie größer ist als ihre Kinder oder sie ein Blatt ist"
        },
        {
          "text": "es muss ein heapify durchgeführt werden, welcher sich ggf bis zu einem Blatt durchziehen kann",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c",
          "aspects": [],
          "correctionOrComment": "es muss ein heapify durchgeführt werden, welcher sich ggf bis zu einem Blatt durchziehen kann"
        },
        {
          "text": "kp",
          "id": "ae8820303e493738a211ebb2ae3a2f90b286f20f767609beb77522c0",
          "aspects": [],
          "correctionOrComment": "kp"
        },
        {
          "text": "Das Element an der Wurzel wird mit dem letzten Kind getauscht. Dafür wird es immer wieder mit dem rechten Kind getauscht. D ein Baum log(n) Tiefe hat, benötigt die Operation log(n) Schritte.",
          "id": "b8607e0369fbf3e33bc0e358f840915d8c085d1496097351913c0122",
          "aspects": [
            {
              "text": "Dafür wird es immer wieder mit dem rechten Kind getauscht",
              "elements": [
                [
                  63,
                  120
                ]
              ],
              "aIdx": 0,
              "label": 2
            },
            {
              "text": "Da ein Baum log(n) Tiefe hat, benötigt die Operation log(n) Schritte",
              "elements": [],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Das Element an der Wurzel wird mit dem letzten Kind getauscht. Dafür wird es immer wieder mit dem rechten Kind getauscht. Da ein Baum log(n) Tiefe hat, benötigt die Operation log(n) Schritte."
        },
        {
          "text": "Die heapify Funktion muss auf den Binärbaum angewendet werden.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6",
          "aspects": [],
          "correctionOrComment": "Die heapify Funktion muss auf den Binärbaum angewendet werden."
        },
        {
          "text": "Die Wurzel wird durch sinnvolles Tauschen an die richtige Stelle gebracht. Immer am größten Kind entlang.",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c",
          "aspects": [
            {
              "text": "Die Wurzel wird durch sinnvolles Tauschen an die richtige Stelle gebracht. Immer am größten Kind entlang",
              "elements": [
                [
                  0,
                  104
                ]
              ],
              "aIdx": 0,
              "label": 0
            }
          ],
          "correctionOrComment": "Die Wurzel wird durch sinnvolles Tauschen an die richtige Stelle gebracht. Immer am größten Kind entlang."
        }
      ]
    },
    {
      "text": "Was ist die Idee des rekursiven MergeSort Algorithmus?",
      "id": 50895,
      "title": "Idee MergeSort",
      "type": "description",
      "aspects": [
        {
          "text": "Die Problemgröße wird durch das halbieren der Menge immer wieder reduziert bis das Sortieren einer Hälften trivial ist"
        },
        {
          "text": "Alle sortierten Hälften werden sortiert wieder zusammengefügt"
        }
      ],
      "referenceAnswers": [
        {
          "text": "Die Problemgröße wird durch das halbieren der Menge immer wieder zu reduzieren bis das Sortieren der Hälften trivial ist. Alle sortierten Hälften werden dann sortiert wieder zusammengefügt.",
          "aspects": [
            {
              "text": "Die Problemgröße wird durch das halbieren der Menge immer wieder zu reduzieren bis das Sortieren der Hälften trivial ist",
              "aIdx": 0,
              "elements": [
                [
                  0,
                  120
                ]
              ]
            },
            {
              "text": "Alle sortierten Hälften werden dann sortiert wieder zusammengefügt",
              "aIdx": 1,
              "elements": [
                [
                  122,
                  188
                ]
              ]
            }
          ]
        }
      ],
      "studentAnswers": [
        {
          "text": "die menge wird solange geteilt bis sie fertig sortiert ist",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Die Menge wird solange geteilt, bis sie fertig sortiert ist",
              "elements": [],
              "aIdx": 0,
              "label": 0
            }
          ],
          "correctionOrComment": "Die Menge wird solange geteilt, bis sie fertig sortiert ist"
        },
        {
          "text": "Das Intervall einer Menge wird halbiert und vergleicht, wenn es bis auf zwei bzw. ein Element immer weiter rekursiv halbiert wurde die Elemente und vertauscht sie, falls nötig. Danach werden die Intervalle (Stapel) wieder zusammengemischt (eigentlich eher wieder aneinandergelegt).",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Das Intervall einer Menge wird halbiert und vergleicht, wenn es bis auf zwei bzw. ein Element immer weiter rekursiv halbiert wurde",
              "elements": [
                [
                  0,
                  130
                ]
              ],
              "aIdx": 0,
              "label": 1
            },
            {
              "text": "Danach werden die Intervalle (Stapel) wieder zusammengemischt",
              "elements": [
                [
                  177,
                  238
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Das Intervall einer Menge wird halbiert und vergleicht, wenn es bis auf zwei bzw. ein Element immer weiter rekursiv halbiert wurde die Elemente und vertauscht sie, falls nötig. Danach werden die Intervalle (Stapel) wieder zusammengemischt (eigentlich eher wieder aneinandergelegt)."
        },
        {
          "text": "Devide and Conquer",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Devide and Conquer",
              "elements": [
                [
                  0,
                  18
                ]
              ],
              "aIdx": 0,
              "label": 1
            }
          ],
          "correctionOrComment": "Devide and Conquer"
        },
        {
          "text": "Die Operation ruft sich solange selbst auf, bis nur noch 2 Zahlen zu vergleichen sind. Danach gibt sie diese sortiert wieder zurück.",
          "id": "7ba019a2553e1137a4bbb8d3c779a48e5ceb2ca3a162e6e0a945ef0f",
          "aspects": [
            {
              "text": "Die Operation ruft sich solange selbst auf, bis nur noch 2 Zahlen zu vergleichen sind. Danach gibt sie diese sortiert wieder zurück.",
              "elements": [
                [
                  0,
                  132
                ]
              ],
              "aIdx": 0,
              "label": 1
            }
          ],
          "correctionOrComment": "Die Operation ruft sich solange selbst auf, bis nur noch 2 Zahlen zu vergleichen sind. Danach gibt sie diese sortiert wieder zurück."
        },
        {
          "text": "Bei MergeSort werden die zu sortierenden Elemente immer wieder in der Hälfte geteilt, bis jeweils nur noch zwei Elemente übrig sind. Diese werden sortiert und mit einem anderen sortierten Stapel vermischt (sodass es insgesamt sortiert ist, nicht irgendwie mischen).",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Bei MergeSort werden die zu sortierenden Elemente immer wieder in der Hälfte geteilt, bis jeweils nur noch zwei Elemente übrig sind",
              "elements": [
                [
                  0,
                  131
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Diese werden sortiert und mit einem anderen sortierten Stapel vermischt, sodass es insgesamt sortiert ist, nicht irgendwie mischen",
              "elements": [],
              "aIdx": 1,
              "label": 1
            }
          ],
          "correctionOrComment": "Bei MergeSort werden die zu sortierenden Elemente immer wieder in der Hälfte geteilt, bis jeweils nur noch zwei Elemente übrig sind. Diese werden sortiert und mit einem anderen sortierten Stapel vermischt, sodass es insgesamt sortiert ist, nicht irgendwie mischen."
        },
        {
          "text": "Duvide and conquer. Ein Array wird so lange aufgeteilt bis es nur 1 element hat. Dann werden 2 sortierte teile des arrays in einem neu angelegten array gemischt dh sortiert und in das ursprüngliche array übertragen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Ein Array wird so lange aufgeteilt bis es nur 1 element hat",
              "elements": [
                [
                  20,
                  79
                ]
              ],
              "aIdx": 0,
              "label": 1
            },
            {
              "text": "Dann werden 2 sortierte Teile des Arrays in einem neu angelegten Array gemischt dh sortiert und in das ursprüngliche Array übertragen",
              "elements": [],
              "aIdx": 1,
              "label": 1
            }
          ],
          "correctionOrComment": "Divide and conquer. Ein Array wird so lange aufgeteilt bis es nur 1 element hat. Dann werden 2 sortierte Teile des Arrays in einem neu angelegten Array gemischt dh sortiert und in das ursprüngliche Array übertragen."
        },
        {
          "text": "Die gegebene Menge wird immer wieder aufgeteilt in zwei Mengen und rekursiv selbst weitergegeben. Hat man eine Menge von nur zwei Elementen sortiert man diese und gibt sie zurück.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "aspects": [
            {
              "text": "Die gegebene Menge wird immer wieder aufgeteilt in zwei Mengen und rekursiv selbst weitergegeben. Hat man eine Menge von nur zwei Elementen",
              "elements": [
                [
                  0,
                  139
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Hat man eine Menge von nur zwei Elementen sortiert man diese und gibt sie zurück",
              "elements": [
                [
                  98,
                  178
                ]
              ],
              "aIdx": 1,
              "label": 1
            }
          ],
          "correctionOrComment": "Die gegebene Menge wird immer wieder aufgeteilt in zwei Mengen und rekursiv selbst weitergegeben. Hat man eine Menge von nur zwei Elementen sortiert man diese und gibt sie zurück."
        },
        {
          "text": "Das eine Menge immer wieder aufgeteilt wird bis nur noch <= 2 Elemente vorhanden sind, die einfach sortiert werden können. Somit wird die Menge in kleinere Probleme aufgeteilt und sobald diese kleinsten Probleme gelöst sind wieder zusammengefügt.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Das eine Menge immer wieder aufgeteilt wird bis nur noch <= 2 Elemente vorhanden sind, die einfach sortiert werden können",
              "elements": [
                [
                  0,
                  121
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Somit wird die Menge in kleinere Probleme aufgeteilt und sobald diese kleinsten Probleme gelöst sind wieder zusammengefügt",
              "elements": [
                [
                  123,
                  245
                ]
              ],
              "aIdx": 1,
              "label": 1
            }
          ],
          "correctionOrComment": "Das eine Menge immer wieder aufgeteilt wird bis nur noch <= 2 Elemente vorhanden sind, die einfach sortiert werden können. Somit wird die Menge in kleinere Probleme aufgeteilt und sobald diese kleinsten Probleme gelöst sind wieder zusammengefügt."
        },
        {
          "text": "Die Idee ist Divide and Conquer, dazu wird der zu sortierende Stapel immer wieder in zwei Hälften aufgeteilt und diese jeweils sortiert und sortiert wieder zusammengemischt.",
          "id": "0ce8152aa92136af039b687c01c7dccfcb271f3db2d0ddcb3cfdd3e6",
          "aspects": [
            {
              "text": "Die Idee ist Divide and Conquer, dazu wird der zu sortierende Stapel immer wieder in zwei Hälften aufgeteilt und diese jeweils sortiert",
              "elements": [
                [
                  0,
                  135
                ]
              ],
              "aIdx": 0,
              "label": 1
            },
            {
              "text": " und sortiert wieder zusammengemischt",
              "elements": [
                [
                  136,
                  172
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Die Idee ist Divide and Conquer, dazu wird der zu sortierende Stapel immer wieder in zwei Hälften aufgeteilt und diese jeweils sortiert und sortiert wieder zusammengemischt."
        },
        {
          "text": "bei Merge Sort wird das Array in Teilarrays unterteilt und dann wieder geteilt und wieder geteilt bis die Elemente einzeln vorliegen. Diese werden dann mit den anderen Teilarrays gemergt und dabei sortiert",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "bei Merge Sort wird das Array in Teilarrays unterteilt und dann wieder geteilt und wieder geteilt bis die Elemente einzeln vorliegen",
              "elements": [
                [
                  0,
                  132
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Diese werden dann mit den anderen Teilarrays gemergt und dabei sortiert",
              "elements": [
                [
                  134,
                  205
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "bei Merge Sort wird das Array in Teilarrays unterteilt und dann wieder geteilt und wieder geteilt bis die Elemente einzeln vorliegen. Diese werden dann mit den anderen Teilarrays gemergt und dabei sortiert"
        },
        {
          "text": "MergeSort sortiert immer weiter geteilte Stapel erst, wenn diese höchstens zwei Elemente besitzen. Dann werden die einzelnen Elemente zusammengemischt und so sortiert.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "MergeSort sortiert immer weiter geteilte Stapel erst, wenn diese höchstens zwei Elemente besitzen",
              "elements": [
                [
                  0,
                  97
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": " Dann werden die einzelnen Elemente zusammengemischt und so sortiert",
              "elements": [
                [
                  99,
                  166
                ]
              ],
              "aIdx": 1,
              "label": 1
            }
          ],
          "correctionOrComment": "MergeSort sortiert immer weiter geteilte Stapel erst, wenn diese höchstens zwei Elemente besitzen. Dann werden die einzelnen Elemente zusammengemischt und so sortiert."
        },
        {
          "text": "teile und herrsche",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Teile und Herrsche",
              "elements": [],
              "aIdx": 0,
              "label": 1
            }
          ],
          "correctionOrComment": "Teile und Herrsche"
        },
        {
          "text": "Divide & Conquer. Die Menge wird auf zwei geteilt und rekursiv wieder und wieder, bis jede Teilmenge nur ein Element enthält und dann je nach Größe wieder zusammen geklebt.",
          "id": "408f0afbe2440a4383a1e75b7d5b0b4202c7f7131a9acf9bd70492f3",
          "aspects": [
            {
              "text": "Die Menge wird auf zwei geteilt und rekursiv wieder und wieder, bis jede Teilmenge nur ein Element enthält ",
              "elements": [
                [
                  18,
                  124
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "und dann je nach Größe wieder zusammen geklebt",
              "elements": [
                [
                  125,
                  171
                ]
              ],
              "aIdx": 1,
              "label": 1
            }
          ],
          "correctionOrComment": "Divide & Conquer. Die Menge wird auf zwei geteilt und rekursiv wieder und wieder, bis jede Teilmenge nur ein Element enthält und dann je nach Größe wieder zusammen geklebt."
        },
        {
          "text": "Divide & conquer Das zu sortierende Array wird solange in zwei Teilarrays aufgeteilt, bis die Teilarrays nur noch aus einem Element bestehen. Daraufhin geht die Rekursion rückwärts und fügt dabei die Teilarrays so zusammen, dass sie sortiert sind. Das geschieht solange, bis das Array vollständig sortiert ist.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6",
          "aspects": [
            {
              "text": "Das zu sortierende Array wird solange in zwei Teilarrays aufgeteilt, bis die Teilarrays nur noch aus einem Element bestehen",
              "elements": [
                [
                  17,
                  140
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Daraufhin geht die Rekursion rückwärts und fügt dabei die Teilarrays so zusammen, dass sie sortiert sind. Das geschieht solange, bis das Array vollständig sortiert ist",
              "elements": [
                [
                  142,
                  309
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Divide & conquer Das zu sortierende Array wird solange in zwei Teilarrays aufgeteilt, bis die Teilarrays nur noch aus einem Element bestehen. Daraufhin geht die Rekursion rückwärts und fügt dabei die Teilarrays so zusammen, dass sie sortiert sind. Das geschieht solange, bis das Array vollständig sortiert ist."
        },
        {
          "text": "das array rekursiv in arrays der länge 2 oder 1 und diese zu sortieren und dann nach und nach die kurzen arrays mit anderen arrays zusammensortieren",
          "id": "c1b8144ee1a30244a571c3d9b48b2c394a7489065d2565968f521645",
          "aspects": [
            {
              "text": "Das Array rekursiv in Arrays der Länge 2 oder 1 teilen",
              "elements": [],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "diese Sortieren und dann nach und nach die kurzen Arrays mit anderen Arrays zusammensortiere",
              "elements": [],
              "aIdx": 1,
              "label": 1
            }
          ],
          "correctionOrComment": "Das Array rekursiv in Arrays der Länge 2 oder 1 teilen und diese Sortieren und dann nach und nach die kurzen Arrays mit anderen Arrays zusammensortieren"
        },
        {
          "text": "ml,l,",
          "id": "192f56eb9bd894a72b30c303247b107be2c4591f310dd69a67927f48",
          "aspects": [],
          "correctionOrComment": "ml,l,"
        },
        {
          "text": "Devide and Conquer",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "aspects": [
            {
              "text": "Devide and Conquer",
              "elements": [
                [
                  0,
                  18
                ]
              ],
              "aIdx": 0,
              "label": 1
            }
          ],
          "correctionOrComment": "Devide and Conquer"
        },
        {
          "text": "Ein (Teil-)Array wird so oft halbiert bis es nurnoch aus zwei Elementen besteht, diese werden dann sortiert. Dieses Teilarray wird mit einem anderen gemergt also so zusammengeführt, dass es immernoch sortiert ist. Das macht man dann so oft bis man wieder beim ursprünglichen Array angekommen ist.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Ein (Teil-)Array wird so oft halbiert bis es nurnoch aus zwei Elementen besteht",
              "elements": [
                [
                  0,
                  79
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "diese werden dann sortiert. Dieses Teilarray wird mit einem anderen gemergt also so zusammengeführt, dass es immernoch sortiert ist. Das macht man dann so oft bis man wieder beim ursprünglichen Array angekommen ist",
              "elements": [
                [
                  81,
                  295
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Ein (Teil-)Array wird so oft halbiert bis es nurnoch aus zwei Elementen besteht, diese werden dann sortiert. Dieses Teilarray wird mit einem anderen gemergt also so zusammengeführt, dass es immernoch sortiert ist. Das macht man dann so oft bis man wieder beim ursprünglichen Array angekommen ist."
        },
        {
          "text": "Divide and conquer. Ein Problem wird in Teilprobleme aufgeteilt, die delegiert werden (auf denen die sort-operation rekursiv aufgerufen wird). Wenn die Probleme klein genug sind, können sie gelöst werden und die Lösungen können zur Problemlösung kombiniert werden.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "aspects": [
            {
              "text": "Ein Problem wird in Teilprobleme aufgeteilt, die delegiert werden, das heißt auf denen die sort-operation rekursiv aufgerufen wird. Wenn die Probleme klein genug sind, können sie gelöst werden",
              "elements": [],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "und die Lösungen können zur Problemlösung kombiniert werden",
              "elements": [
                [
                  204,
                  263
                ]
              ],
              "aIdx": 1,
              "label": 1
            }
          ],
          "correctionOrComment": "Divide and conquer. Ein Problem wird in Teilprobleme aufgeteilt, die delegiert werden, das heißt auf denen die sort-operation rekursiv aufgerufen wird. Wenn die Probleme klein genug sind, können sie gelöst werden und die Lösungen können zur Problemlösung kombiniert werden."
        },
        {
          "text": "Man teilt ein gegebenes Array so lange in der Hälfte, bis es maximal aus 2 Werten besteht, diese kann man leicht sortieren, danach werden die Teilarrays zusammengemischt.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Man teilt ein gegebenes Array so lange in der Hälfte, bis es maximal aus 2 Werten besteht, diese kann man leicht sortieren",
              "elements": [
                [
                  0,
                  122
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "danach werden die Teilarrays zusammengemischt",
              "elements": [
                [
                  124,
                  169
                ]
              ],
              "aIdx": 1,
              "label": 1
            }
          ],
          "correctionOrComment": "Man teilt ein gegebenes Array so lange in der Hälfte, bis es maximal aus 2 Werten besteht, diese kann man leicht sortieren, danach werden die Teilarrays zusammengemischt."
        },
        {
          "text": "Der Datensatz mit n Elementen wird so häufig halbiert bis jeweils nur noch 1 Element da ist. dann wird er sortiert wieder zusammengefügt",
          "id": "b51d18b551043c1f145f22dbde6f8531faeaf68c54ed9dd79ce24d17",
          "aspects": [
            {
              "text": "Der Datensatz mit n Elementen wird so häufig halbiert bis jeweils nur noch 1 Element da ist",
              "elements": [
                [
                  0,
                  91
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "dann wird er sortiert wieder zusammengefügt",
              "elements": [
                [
                  93,
                  136
                ]
              ],
              "aIdx": 1,
              "label": 1
            }
          ],
          "correctionOrComment": "Der Datensatz mit n Elementen wird so häufig halbiert bis jeweils nur noch 1 Element da ist. dann wird er sortiert wieder zusammengefügt"
        },
        {
          "text": "Wir Teilen das was wir bekommen in zwei Teile, die jeweils wieder zerteilt werden, bis nur noch ein einzelnes element übrig ist, dann werden sie wieder zusammen gemischt, so dass immer die obersten elemente Zweier Teile verglichen werden und der Kleinere zu erst auf den Zusammenfügestapel kommt, bis alle Einzelteile wieder zusammengefügt wurden",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Wir Teilen das was wir bekommen in zwei Teile, die jeweils wieder zerteilt werden, bis nur noch ein einzelnes element übrig ist",
              "elements": [
                [
                  0,
                  127
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "dann werden sie wieder zusammen gemischt, so dass immer die obersten elemente Zweier Teile verglichen werden und der Kleinere zu erst auf den Zusammenfügestapel kommt, bis alle Einzelteile wieder zusammengefügt wurden",
              "elements": [
                [
                  129,
                  346
                ]
              ],
              "aIdx": 1,
              "label": 0
            }
          ],
          "correctionOrComment": "Wir Teilen das was wir bekommen in zwei Teile, die jeweils wieder zerteilt werden, bis nur noch ein einzelnes element übrig ist, dann werden sie wieder zusammen gemischt, so dass immer die obersten elemente Zweier Teile verglichen werden und der Kleinere zu erst auf den Zusammenfügestapel kommt, bis alle Einzelteile wieder zusammengefügt wurden"
        },
        {
          "text": "Divide and Conquer",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c",
          "aspects": [
            {
              "text": "Divide and Conquer",
              "elements": [
                [
                  0,
                  18
                ]
              ],
              "aIdx": 0,
              "label": 1
            }
          ],
          "correctionOrComment": "Divide and Conquer"
        },
        {
          "text": "Divide and Conquer",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Divide and Conquer",
              "elements": [
                [
                  0,
                  18
                ]
              ],
              "aIdx": 0,
              "label": 1
            }
          ],
          "correctionOrComment": "Divide and Conquer"
        },
        {
          "text": "Divide and Conquer",
          "id": "ae8820303e493738a211ebb2ae3a2f90b286f20f767609beb77522c0",
          "aspects": [
            {
              "text": "Divide and Conquer",
              "elements": [
                [
                  0,
                  18
                ]
              ],
              "aIdx": 0,
              "label": 1
            }
          ],
          "correctionOrComment": "Divide and Conquer"
        },
        {
          "text": "Der Datensatz wird so lange rekursiv aufgeteilt, bis er nur noch zwei Elemente miteinander vergleichen muss. Anschließend werden die Elemente wieder ebenenweise zusammengefügt.",
          "id": "b8607e0369fbf3e33bc0e358f840915d8c085d1496097351913c0122",
          "aspects": [
            {
              "text": "Der Datensatz wird so lange rekursiv aufgeteilt, bis er nur noch zwei Elemente miteinander vergleichen muss",
              "elements": [
                [
                  0,
                  107
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Anschließend werden die Elemente wieder ebenenweise zusammengefügt",
              "elements": [
                [
                  109,
                  175
                ]
              ],
              "aIdx": 1,
              "label": 1
            }
          ],
          "correctionOrComment": "Der Datensatz wird so lange rekursiv aufgeteilt, bis er nur noch zwei Elemente miteinander vergleichen muss. Anschließend werden die Elemente wieder ebenenweise zusammengefügt."
        },
        {
          "text": "Die Menge wird rekursiv immer weiter geteilt, bis nur noch zwei Elemente vorhanden sind. Diese und die zurückgegebenen Mengen werden dann entsprechend wieder sortiert.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6",
          "aspects": [
            {
              "text": "Die Menge wird rekursiv immer weiter geteilt, bis nur noch zwei Elemente vorhanden sind",
              "elements": [
                [
                  0,
                  87
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Diese und die zurückgegebenen Mengen werden dann entsprechend wieder sortiert",
              "elements": [
                [
                  89,
                  166
                ]
              ],
              "aIdx": 1,
              "label": 1
            }
          ],
          "correctionOrComment": "Die Menge wird rekursiv immer weiter geteilt, bis nur noch zwei Elemente vorhanden sind. Diese und die zurückgegebenen Mengen werden dann entsprechend wieder sortiert."
        },
        {
          "text": "Die zu sortierende Menge wird immer weiter aufgeteilt, bis nur noch zwei oder weniger Objekte übrig sind, diese werden dann zurückgebeben und mit den anderen zusammengefügt",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "ie zu sortierende Menge wird immer weiter aufgeteilt, bis nur noch zwei oder weniger Objekte übrig sind",
              "elements": [
                [
                  1,
                  104
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "diese werden dann zurückgebeben und mit den anderen zusammengefügt",
              "elements": [
                [
                  106,
                  172
                ]
              ],
              "aIdx": 1,
              "label": 1
            }
          ],
          "correctionOrComment": "Die zu sortierende Menge wird immer weiter aufgeteilt, bis nur noch zwei oder weniger Objekte übrig sind, diese werden dann zurückgebeben und mit den anderen zusammengefügt"
        },
        {
          "text": "Wir brauchen nur einen Vergleich zu programmieren, da wir von Beginn an die zu sortierende Menge teilen und dann für beide Hälften das Sort aufrufen, m Sort dann wieder teilen und für beide Hälften Sort aufrufen. Das passiert so lange, bis die zu sortierende Menge nur noch 2 Elemente hat. die sind ganz leicht zu sortieren. Bein Rückkehren werden die beiden Mengen zusamengemischt und wieder zurückgegeben.",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c",
          "aspects": [
            {
              "text": "da wir von Beginn an die zu sortierende Menge teilen und dann für beide Hälften das Sort aufrufen ;; Das passiert so lange, bis die zu sortierende Menge nur noch 2 Elemente hat. die sind ganz leicht zu sortieren",
              "elements": [
                [
                  51,
                  148
                ],
                [
                  213,
                  323
                ]
              ],
              "aIdx": 0,
              "label": 0
            },
            {
              "text": "Bein Rückkehren werden die beiden Mengen zusamengemischt und wieder zurückgegeben",
              "elements": [
                [
                  325,
                  406
                ]
              ],
              "aIdx": 1,
              "label": 1
            }
          ],
          "correctionOrComment": "Wir brauchen nur einen Vergleich zu programmieren, da wir von Beginn an die zu sortierende Menge teilen und dann für beide Hälften das Sort aufrufen, m Sort dann wieder teilen und für beide Hälften Sort aufrufen. Das passiert so lange, bis die zu sortierende Menge nur noch 2 Elemente hat. die sind ganz leicht zu sortieren. Bein Rückkehren werden die beiden Mengen zusamengemischt und wieder zurückgegeben."
        },
        {
          "text": "Das zu sortierende Array wird immer weiter verkleinert",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "aspects": [
            {
              "text": "Das zu sortierende Array wird immer weiter verkleinert",
              "elements": [
                [
                  0,
                  54
                ]
              ],
              "aIdx": 0,
              "label": 1
            }
          ],
          "correctionOrComment": "Das zu sortierende Array wird immer weiter verkleinert"
        }
      ]
    }
  ]
}
