{
  "questions": [
    {
      "text": "Was versteht man unter Typecasting?",
      "id": 50714,
      "type": "definition",
      "title": "Definition Typecasting",
      "referenceAnswer": {
        "text": "Darunter versteht man die Umwandlung des Datentyps eines Wertes in einen anderen.",
        "aspects": [
          {
            "text": "die Umwandlung des Datentyps eines Wertes in einen anderen",
            "elements": [
              [
                22,
                80
              ]
            ]
          }
        ]
      },
      "answersAnnotation": [
        {
          "text": "Unter Typecasting wir die Umwandlung eines Datentyps in einen anderen verstanden.",
          "id": "8bbd52208353c14f154f1402cebf5829afb1708d06b5dc25064dff23",
          "correctionOrComment": "Unter Typecasting wir die Umwandlung eines Datentyps in einen anderen verstanden.",
          "answerCategory": "correct"
        },
        {
          "text": "Interpretation des Binärmusters des Wertes einer Variablen als ein anderer Datentyp als der deklarierte.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Interpretation des Binärmusters des Wertes einer Variablen als ein anderer Datentyp als der deklarierte.",
          "answerCategory": "correct"
        },
        {
          "text": "Unter Typecasting versteht man die zwanghafte umformung von Datentypen in einen anderen, beispielsweise einen int in einen float.",
          "id": "8a217ea5f39d0f20db42ef9bcb667eacd060a40b50a18655172ec4b8",
          "correctionOrComment": "Unter Typecasting versteht man die zwanghafte umformung von Datentypen in einen anderen, beispielsweise einen int in einen float.",
          "answerCategory": "correct"
        },
        {
          "text": "Typecasting ist das zu sichern oder umwandeln eines bestimmten Datentypes in einen anderen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Typecasting ist das zu sichern oder umwandeln eines bestimmten Datentypes in einen anderen.",
          "answerCategory": "correct"
        },
        {
          "text": "Typecasting ermöglicht den Wechsel eines Datentyps in einen anderen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Typecasting ermöglicht den Wechsel eines Datentyps in einen anderen.",
          "answerCategory": "correct"
        },
        {
          "text": "Gibt den Datentyp an um nicht in der Oberklasse Objekt zu landen.",
          "id": "1e2c3eb4744dbc36de4e827f187dd2a073d91b8790a2ff117694dd7b",
          "correctionOrComment": "Gibt den Datentyp an um nicht in der Oberklasse Objekt zu landen.",
          "answerCategory": "missconception"
        },
        {
          "text": "Typecasting ist das Erzwingen eines Wertes sich in einen anderen umzuwandeln.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Typecasting ist das Erzwingen eines Wertes sich in einen anderen umzuwandeln.",
          "answerCategory": "correct"
        },
        {
          "text": "das ein\\/umstellen des Datentyps einer variablen",
          "id": "c1b8144ee1a30244a571c3d9b48b2c394a7489065d2565968f521645",
          "correctionOrComment": "das ein\\/umstellen des Datentyps einer variablen",
          "answerCategory": "correct"
        },
        {
          "text": "Das Umwandeln eines Datentypens. (einen bestimmten Datentyp aufzwingen)",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Das Umwandeln eines Datentypens. (einen bestimmten Datentyp aufzwingen)",
          "answerCategory": "correct"
        },
        {
          "text": "in den meisten fällen müssen die elemente mit denen wir arbeiten den gleichen datentyp, typecast haben, wir typecasten wenn wir umwandeln",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "in den meisten fällen müssen die elemente mit denen wir arbeiten den gleichen datentyp, typecast haben, wir typecasten wenn wir umwandeln",
          "answerCategory": "binary_correct"
        },
        {
          "text": "Einen Datentyp in einen anderen umzuwandeln z.B. double in int.",
          "id": "ea674ab55536a8b603be44d13510e32c7aab02088bf48c2802e4febd",
          "correctionOrComment": "Einen Datentyp in einen anderen umzuwandeln z.B. double in int.",
          "answerCategory": "correct"
        },
        {
          "text": "Typecasting ist die erzwungene Umwandlung von Daten in einen bestimmten Datentypen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Typecasting ist die erzwungene Umwandlung von Daten in einen bestimmten Datentypen.",
          "answerCategory": "correct"
        },
        {
          "text": "Typecasting ist die Umformung eines Datentyps in einen anderen Datentyp.  Z.b. Integer in Char",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Typecasting ist die Umformung eines Datentyps in einen anderen Datentyp. Z.b. Integer in Char",
          "answerCategory": "correct"
        },
        {
          "text": "Man versteht die Umwandlung von Datentypen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Man versteht die Umwandlung von Datentypen.",
          "answerCategory": "correct"
        },
        {
          "text": "Unter Typecasting versteht man die Umwandlung von einem Datentyp zu einem anderen.",
          "id": "408f0afbe2440a4383a1e75b7d5b0b4202c7f7131a9acf9bd70492f3",
          "correctionOrComment": "Unter Typecasting versteht man die Umwandlung von einem Datentyp zu einem anderen.",
          "answerCategory": "correct"
        },
        {
          "text": "Typecasting bedeutet, einem Datentyp eine neue Funktion zuzuweisen, z.B. einen Int in ein Char zu casten",
          "id": "0ce8152aa92136af039b687c01c7dccfcb271f3db2d0ddcb3cfdd3e6",
          "correctionOrComment": "Typecasting bedeutet, einem Datentyp eine neue Funktion zuzuweisen, z.B. einen Int in ein Char zu casten",
          "answerCategory": "missconception"
        },
        {
          "text": "Wenn man dem Programm angibt welchen Datentyp ein Objekt hat bzw als welchen Datentyp er interpretiert werden soll.  ClassCastException fehler wenn sie nicht übereinstimmen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Wenn man dem Programm angibt welchen Datentyp ein Objekt hat bzw als welchen Datentyp er interpretiert werden soll. ClassCastException fehler wenn sie nicht übereinstimmen.",
          "answerCategory": "correct"
        },
        {
          "text": "Typecasting ist das Umwandeln von verschiedenen Datentypen.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "correctionOrComment": "Typecasting ist das Umwandeln von verschiedenen Datentypen.",
          "answerCategory": "correct"
        },
        {
          "text": "Vorgabe des Datentypen einer Variable",
          "id": "8a1c55283fd2fc15f72ad8c88c9dcc447f528814a41bf2a7ab51950a",
          "correctionOrComment": "Vorgabe des Datentypen einer Variable",
          "answerCategory": "correct"
        },
        {
          "text": "Umwandlung eines Datentyps, zum Beispiel Integer 1 zu Float 1.0",
          "id": "6332531eeafc6e0ede272192be898f549950fb32b209d04f0a98306a",
          "correctionOrComment": "Umwandlung eines Datentyps, zum Beispiel Integer 1 zu Float 1.0",
          "answerCategory": "correct"
        },
        {
          "text": "Unter Typecasting versteht man, dass vor der zugeordneten Variable ein Typ in Klammern gestellt wird, aus welchen die Variable ist bzw. , dass soll angenommen werden.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Unter Typecasting versteht man, dass vor der zugeordneten Variable ein Typ in Klammern gestellt wird, aus welchen die Variable ist bzw. , dass soll angenommen werden.",
          "answerCategory": "correct"
        },
        {
          "text": "erzwungene Umwandlung eines Datentyps zu einem anderen Datentyp",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "erzwungene Umwandlung eines Datentyps zu einem anderen Datentyp",
          "answerCategory": "correct"
        },
        {
          "text": "Unter Typecasting versteht man eine erzwungene Umwandlung von einem Datentypen zu einem anderen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Unter Typecasting versteht man eine erzwungene Umwandlung von einem Datentypen zu einem anderen.",
          "answerCategory": "correct"
        },
        {
          "text": "Typecasting konvertiert einen Datentyp in einen anderen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Typecasting konvertiert einen Datentyp in einen anderen.",
          "answerCategory": "correct"
        },
        {
          "text": "veränderung des datentyps einer variable",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "veränderung des datentyps einer variable",
          "answerCategory": "correct"
        },
        {
          "text": "Man versichert Java, dass der zugeortnete Wert das richtige Format hat",
          "id": "271f93f45e9b4067327ed5c8cd30a034730aaace4382803c3e1d6c2f",
          "correctionOrComment": "Man versichert Java, dass der zugeortnete Wert das richtige Format hat",
          "answerCategory": "missconception"
        },
        {
          "text": "Die ausdrückliche Umwandlung von einem Datentyp in einen anderen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Die ausdrückliche Umwandlung von einem Datentyp in einen anderen.",
          "answerCategory": "correct"
        },
        {
          "text": "Möchte man den Wert einer Variablen in einem anderen Datentyp speichern, als im bisherigen, nutzt man das sogenannte Typecasting, bei dem der Wert eines Datentyps in einen anderen Datentyp konvertiert wird. Zum Beispiel: int i; double d; i = (int) d;",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6",
          "correctionOrComment": "Möchte man den Wert einer Variablen in einem anderen Datentyp speichern, als im bisherigen, nutzt man das sogenannte Typecasting, bei dem der Wert eines Datentyps in einen anderen Datentyp konvertiert wird. Zum Beispiel: int i; double d; i = (int) d;",
          "answerCategory": "correct"
        },
        {
          "text": "Das casten von bestimmten Daten zu anderen Datentypen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Das casten von bestimmten Daten zu anderen Datentypen.",
          "answerCategory": "correct"
        },
        {
          "text": "Das Umwandeln eines Datentypes in einen anderen. Z.B. char in int, oder Object in [irgendeine Klasse], da Java alle Klassen als Child-Class von 'Object' betrachtet.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6",
          "correctionOrComment": "Das Umwandeln eines Datentypes in einen anderen. Z.B. char in int, oder Object in [irgendeine Klasse], da Java alle Klassen als Child-Class von 'Object' betrachtet.",
          "answerCategory": "correct"
        },
        {
          "text": "Man weist einem Wert einen anderen Datentyp zu",
          "id": "53750c72b7bb26cb6ff7115e383ca150d5a632a909a7f79e2f5274a4",
          "correctionOrComment": "Man weist einem Wert einen anderen Datentyp zu",
          "answerCategory": "correct"
        },
        {
          "text": "Typecasting ist die Umwandlung zwischen verschiedenen Datentypen, zum Beispiel ein Int als Double oder Float interpretieren.",
          "id": "8416c38cc898f1ac7cc9d64e89dab1f70f5ddab002a5b2a1713f93f5",
          "correctionOrComment": "Typecasting ist die Umwandlung zwischen verschiedenen Datentypen, zum Beispiel ein Int als Double oder Float interpretieren.",
          "answerCategory": "correct"
        },
        {
          "text": "kkjkjj",
          "id": "192f56eb9bd894a72b30c303247b107be2c4591f310dd69a67927f48",
          "correctionOrComment": "kkjkjj",
          "answerCategory": "none"
        },
        {
          "text": "Typcasting bedeutet, dass man Java den Datentyp eines Objektes mitteilt.",
          "id": "7ba019a2553e1137a4bbb8d3c779a48e5ceb2ca3a162e6e0a945ef0f",
          "correctionOrComment": "Typcasting bedeutet, dass man Java den Datentyp eines Objektes mitteilt.",
          "answerCategory": "correct"
        },
        {
          "text": "Umwandlung eines Datentypes in einen geeigneteren Datentyp.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "correctionOrComment": "Umwandlung eines Datentypes in einen geeigneteren Datentyp.",
          "answerCategory": "correct"
        },
        {
          "text": "Wenn einem Rückgabewert beigestellt wird, welchem Datentyp er entspricht.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Wenn einem Rückgabewert beigestellt wird, welchem Datentyp er entspricht.",
          "answerCategory": "missconception"
        },
        {
          "text": "Die Umwandlung\\/bzw. Interpretation eines Werts eines Datentypen in einen äquivalenten Werte eines anderen Datentypen.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "correctionOrComment": "Die Umwandlung\\/bzw. Interpretation eines Werts eines Datentypen in einen äquivalenten Werte eines anderen Datentypen.",
          "answerCategory": "correct"
        },
        {
          "text": "Das erzwingen von dem Werte eines Datentypes in einen anderen Datentyp",
          "id": "b51d18b551043c1f145f22dbde6f8531faeaf68c54ed9dd79ce24d17",
          "correctionOrComment": "Das erzwingen von dem Werte eines Datentypes in einen anderen Datentyp",
          "answerCategory": "correct"
        },
        {
          "text": "Typecasting ist die Umwandlung des Datentyps.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Typecasting ist die Umwandlung des Datentyps.",
          "answerCategory": "correct"
        },
        {
          "text": "Unter Typecasting versteht man die Umwandlung von einem in einen anderen Datentyp.",
          "id": "f09265efb456b0336079ad5b238daa1e38a11b1d71cc0e1a4e8edd56",
          "correctionOrComment": "Unter Typecasting versteht man die Umwandlung von einem in einen anderen Datentyp.",
          "answerCategory": "correct"
        },
        {
          "text": "Das wandeln von einem Datentypen in einen anderen.",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c",
          "correctionOrComment": "Das wandeln von einem Datentypen in einen anderen.",
          "answerCategory": "correct"
        },
        {
          "text": "Einen Datentyp casten und ihn dann so interpretieren",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Einen Datentyp casten und ihn dann so interpretieren",
          "answerCategory": "binary_correct"
        },
        {
          "text": "Die Umwandlung von einem Datentyp zu einem anderen.",
          "id": "b8607e0369fbf3e33bc0e358f840915d8c085d1496097351913c0122",
          "correctionOrComment": "Die Umwandlung von einem Datentyp zu einem anderen.",
          "answerCategory": "correct"
        },
        {
          "text": "Ein Objekt einer Klasse in eien andere umwandeln",
          "id": "ae8820303e493738a211ebb2ae3a2f90b286f20f767609beb77522c0",
          "correctionOrComment": "Ein Objekt einer Klasse in eien andere umwandeln",
          "answerCategory": "missconception"
        },
        {
          "text": "Umwandeln eines Wertes von einem Datentyp in einen anderen",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Umwandeln eines Wertes von einem Datentyp in einen anderen",
          "answerCategory": "correct"
        },
        {
          "text": "Typecast teilt mit, dass das Objekt zu einem bestimmten Typ gehört.",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c",
          "correctionOrComment": "Typecast teilt mit, dass das Objekt zu einem bestimmten Typ gehört.",
          "answerCategory": "binary_correct"
        },
        {
          "text": "Datentyp eines Wertes wir in anderen Datentypen umgewandelt",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Datentyp eines Wertes wir in anderen Datentypen umgewandelt",
          "answerCategory": "correct"
        },
        {
          "text": "verschiedene Datentypen umwandeln",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "verschiedene Datentypen umwandeln",
          "answerCategory": "correct"
        }
      ]
    },
    {
      "text": "Was repräsentiert der Datentyp Char?",
      "id": 50713,
      "title": "Datentyp Char",
      "type": "definition",
      "simple": true,
      "referenceAnswer": {
        "text": "Der Datentyp Char repräsentiert einzelne Zeichen.",
        "aspects": [
          {
            "text": "Der Datentyp Char repräsentiert einzelne Zeichen",
            "elements": [
              [
                0,
                48
              ]
            ]
          }
        ]
      },
      "answersAnnotation": [
        {
          "text": "ein beliebiges zeichen inkl, Ziffern Buchstaben sonderzeichen...",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "ein beliebiges zeichen inkl, Ziffern Buchstaben sonderzeichen...",
          "answerCategory": "correct"
        },
        {
          "text": "Der Datentyp Char repräsentiert Zeichen (englisch: character), wie beispielsweise Buchstaben, Ziffern oder auch Sonderzeichen.",
          "id": "8bbd52208353c14f154f1402cebf5829afb1708d06b5dc25064dff23",
          "correctionOrComment": "Der Datentyp Char repräsentiert Zeichen (englisch: character), wie beispielsweise Buchstaben, Ziffern oder auch Sonderzeichen.",
          "answerCategory": "correct"
        },
        {
          "text": "ein Zeichen",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "ein Zeichen",
          "answerCategory": "correct"
        },
        {
          "text": "Der Datentyp char repräsentiert und speichern einzelne Zeichen.",
          "id": "756c8bb0587e8f047fc555ff8a6379ac8af40d1e3ebcb178dcbe87d5",
          "correctionOrComment": "Der Datentyp char repräsentiert und speichern einzelne Zeichen.",
          "answerCategory": "correct"
        },
        {
          "text": "Er repräsentiert einen charakter, das heißt ein Zeichen wird gespeichert bzw ausgegeben o.ä.",
          "id": "8a217ea5f39d0f20db42ef9bcb667eacd060a40b50a18655172ec4b8",
          "correctionOrComment": "Er repräsentiert einen charakter, das heißt ein Zeichen wird gespeichert bzw ausgegeben o.ä.",
          "answerCategory": "correct"
        },
        {
          "text": "Char dient zur Speicherung und Darstellung eines einzelnen Zeichens, wobei ein Zeichen ein Buchstabe,eine Zahl oder ein Sonderzeichen sein kann.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Char dient zur Speicherung und Darstellung eines einzelnen Zeichens, wobei ein Zeichen ein Buchstabe,eine Zahl oder ein Sonderzeichen sein kann.",
          "answerCategory": "correct"
        },
        {
          "text": "Der Datentyp char steht für die Daten von Zeichen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Der Datentyp char steht für die Daten von Zeichen.",
          "answerCategory": "correct"
        },
        {
          "text": "Der Datentyp repräsentiert ein Zeichen.",
          "id": "1e2c3eb4744dbc36de4e827f187dd2a073d91b8790a2ff117694dd7b",
          "correctionOrComment": "Der Datentyp repräsentiert ein Zeichen.",
          "answerCategory": "correct"
        },
        {
          "text": "Der Datentyp char stellt einzelne Zeichen, wie Buchstaben, Sonderzeichen oder Ziffern im Unicode dar.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Der Datentyp char stellt einzelne Zeichen, wie Buchstaben, Sonderzeichen oder Ziffern im Unicode dar.",
          "answerCategory": "correct"
        },
        {
          "text": "Ein einzelnen Zeichen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Ein einzelnen Zeichen.",
          "answerCategory": "correct"
        },
        {
          "text": "ein ascii zeichen mit speichergröße von 16 bit",
          "id": "c1b8144ee1a30244a571c3d9b48b2c394a7489065d2565968f521645",
          "correctionOrComment": "ein ascii zeichen mit speichergröße von 16 bit",
          "answerCategory": "correct"
        },
        {
          "text": "Ein einzelnes Zeichen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Ein einzelnes Zeichen.",
          "answerCategory": "correct"
        },
        {
          "text": "ein char representiert ein Zeichen aus der ASCII-Tabelle.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "ein char representiert ein Zeichen aus der ASCII-Tabelle.",
          "answerCategory": "correct"
        },
        {
          "text": "Ein Zeichen der Tastatur diesem Zeichen ist eine Zahl hinterlegt(siehe ACCII Tabelle",
          "id": "ea674ab55536a8b603be44d13510e32c7aab02088bf48c2802e4febd",
          "correctionOrComment": "Ein Zeichen der Tastatur diesem Zeichen ist eine Zahl hinterlegt(siehe ACCII Tabelle",
          "answerCategory": "binary_correct"
        },
        {
          "text": "Der Datentyp char repräsentiert Zeichen, wie zB Buchstaben und Satzzeichen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Der Datentyp char repräsentiert Zeichen, wie zB Buchstaben und Satzzeichen.",
          "answerCategory": "correct"
        },
        {
          "text": "Char repräsentiert Zeichen",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Char repräsentiert Zeichen",
          "answerCategory": "correct"
        },
        {
          "text": "Er repräsentiert Sonderzeichen, Zeichen, Buchstaben, Zahlen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Er repräsentiert Sonderzeichen, Zeichen, Buchstaben, Zahlen.",
          "answerCategory": "correct"
        },
        {
          "text": "Der Datentyp Char repräsentiert ein Zeichen.",
          "id": "408f0afbe2440a4383a1e75b7d5b0b4202c7f7131a9acf9bd70492f3",
          "correctionOrComment": "Der Datentyp Char repräsentiert ein Zeichen.",
          "answerCategory": "correct"
        },
        {
          "text": "Der Datentyp Char repräsentiert Zeichen wie 'a' oder 'o'",
          "id": "0ce8152aa92136af039b687c01c7dccfcb271f3db2d0ddcb3cfdd3e6",
          "correctionOrComment": "Der Datentyp Char repräsentiert Zeichen wie 'a' oder 'o'",
          "answerCategory": "correct"
        },
        {
          "text": "binäre Darstellung (16 bits) Symbole zb Buchstaben, Zeichen",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "binäre Darstellung (16 bits) Symbole zb Buchstaben, Zeichen",
          "answerCategory": "correct"
        },
        {
          "text": "Der Datentyp Char repräsentiert ein einzelnes Zeichen einer Zeichenkette.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "correctionOrComment": "Der Datentyp Char repräsentiert ein einzelnes Zeichen einer Zeichenkette.",
          "answerCategory": "partially_correct"
        },
        {
          "text": "Speicherung eines einzelnen Zeichens",
          "id": "8a1c55283fd2fc15f72ad8c88c9dcc447f528814a41bf2a7ab51950a",
          "correctionOrComment": "Speicherung eines einzelnen Zeichens",
          "answerCategory": "correct"
        },
        {
          "text": "Alle Zeichen, also Buchstaben, Ziffern oder Satzzeichen",
          "id": "6332531eeafc6e0ede272192be898f549950fb32b209d04f0a98306a",
          "correctionOrComment": "Alle Zeichen, also Buchstaben, Ziffern oder Satzzeichen",
          "answerCategory": "correct"
        },
        {
          "text": "Der Datentyp Char repräsentiert ein Zeichen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Der Datentyp Char repräsentiert ein Zeichen.",
          "answerCategory": "correct"
        },
        {
          "text": "Datentyp char repräsentiert alle Zeichen, Buchstaben und Ziffern",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Datentyp char repräsentiert alle Zeichen, Buchstaben und Ziffern",
          "answerCategory": "correct"
        },
        {
          "text": "Der Datentyp Char repräsentiert Zeichen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Der Datentyp Char repräsentiert Zeichen.",
          "answerCategory": "correct"
        },
        {
          "text": "Char repräsentieren alle Buchstaben, Zahlen, Symbole und Zeichen die es gibt und in der ASCII-Tabelle beschrieben sind.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Char repräsentieren alle Buchstaben, Zahlen, Symbole und Zeichen die es gibt und in der ASCII-Tabelle beschrieben sind.",
          "answerCategory": "correct"
        },
        {
          "text": "Variablen der Größe 16 bit",
          "id": "271f93f45e9b4067327ed5c8cd30a034730aaace4382803c3e1d6c2f",
          "correctionOrComment": "Variablen der Größe 16 bit",
          "answerCategory": "missconception"
        },
        {
          "text": "ein einzelnes zeichen",
          "id": "de0a13aab90b285db3fde617643bd713b7ae7e35a3792c5f539c98b8",
          "correctionOrComment": "ein einzelnes zeichen",
          "answerCategory": "correct"
        },
        {
          "text": "Er repräsentiert ein einzelnes Zeichen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Er repräsentiert ein einzelnes Zeichen.",
          "answerCategory": "correct"
        },
        {
          "text": "Mithilfe char kann man alle möglichen Zeichen speichern, wie zum Beispiel Buchstaben. Ziffern kann man auch speichern, allerdings sind das dann nur die syntaktischen Ziffernzeichen und nicht der Wert dahinter, der gespeichert wird.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6",
          "correctionOrComment": "Mithilfe char kann man alle möglichen Zeichen speichern, wie zum Beispiel Buchstaben. Ziffern kann man auch speichern, allerdings sind das dann nur die syntaktischen Ziffernzeichen und nicht der Wert dahinter, der gespeichert wird.",
          "answerCategory": "correct"
        },
        {
          "text": "In ihm kann man einzelne Zeichen speichern",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "In ihm kann man einzelne Zeichen speichern",
          "answerCategory": "correct"
        },
        {
          "text": "Ein einzelnes Zeichen.",
          "id": "f09265efb456b0336079ad5b238daa1e38a11b1d71cc0e1a4e8edd56",
          "correctionOrComment": "Ein einzelnes Zeichen.",
          "answerCategory": "correct"
        },
        {
          "text": "Einen einzelnen Buchstaben, kodiert in der ASCII-Tabelle (auf Wunsch auch UTF-8). Es können damit auch Zahlen und andere Zeichen dargestellt werden. Ein char kann auch als int interpretiert werden, wodurch man den Wert des Buchstabens erhält.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6",
          "correctionOrComment": "Einen einzelnen Buchstaben, kodiert in der ASCII-Tabelle (auf Wunsch auch UTF-8). Es können damit auch Zahlen und andere Zeichen dargestellt werden. Ein char kann auch als int interpretiert werden, wodurch man den Wert des Buchstabens erhält.",
          "answerCategory": "correct"
        },
        {
          "text": "ein Symbolzeichen",
          "id": "53750c72b7bb26cb6ff7115e383ca150d5a632a909a7f79e2f5274a4",
          "correctionOrComment": "ein Symbolzeichen",
          "answerCategory": "correct"
        },
        {
          "text": "Ein einzelnes Zeichen der ASCII-Tabelle",
          "id": "8416c38cc898f1ac7cc9d64e89dab1f70f5ddab002a5b2a1713f93f5",
          "correctionOrComment": "Ein einzelnes Zeichen der ASCII-Tabelle",
          "answerCategory": "correct"
        },
        {
          "text": "Den Index eines Zeichens aus der AscII-Tabelle",
          "id": "7ba019a2553e1137a4bbb8d3c779a48e5ceb2ca3a162e6e0a945ef0f",
          "correctionOrComment": "Den Index eines Zeichens aus der AscII-Tabelle",
          "answerCategory": "correct"
        },
        {
          "text": "Der Datentyp 'char' präsentiert eine Ziffer.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "correctionOrComment": "Der Datentyp 'char' präsentiert eine Ziffer.",
          "answerCategory": "missconception"
        },
        {
          "text": "Der Datentyp Char repräsentiert einzelne Symbole, also Buchstaben, Zahlen oder Zeichen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Der Datentyp Char repräsentiert einzelne Symbole, also Buchstaben, Zahlen oder Zeichen.",
          "answerCategory": "correct"
        },
        {
          "text": "Repräsentiert den Speicherbereich für ein Zeichen.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "correctionOrComment": "Repräsentiert den Speicherbereich für ein Zeichen.",
          "answerCategory": "correct"
        },
        {
          "text": "Der Datentyp char repräsentiert verschiedene einzelne Zeichen, wie z.B. A, B +,...",
          "id": "b51d18b551043c1f145f22dbde6f8531faeaf68c54ed9dd79ce24d17",
          "correctionOrComment": "Der Datentyp char repräsentiert verschiedene einzelne Zeichen, wie z.B. A, B +,...",
          "answerCategory": "correct"
        },
        {
          "text": "char ist eine Variable der Größe 16 bit und repräsentiert ein Zeichen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "char ist eine Variable der Größe 16 bit und repräsentiert ein Zeichen.",
          "answerCategory": "correct"
        },
        {
          "text": "char definiert Werte als Asci zeichen",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c",
          "correctionOrComment": "char definiert Werte als Asci zeichen",
          "answerCategory": "correct"
        },
        {
          "text": "Buchstaben",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Buchstaben",
          "answerCategory": "partially_correct"
        },
        {
          "text": "Er repräsentiert einzelne Zeichen.",
          "id": "b8607e0369fbf3e33bc0e358f840915d8c085d1496097351913c0122",
          "correctionOrComment": "Er repräsentiert einzelne Zeichen.",
          "answerCategory": "correct"
        },
        {
          "text": "Zeichen",
          "id": "ae8820303e493738a211ebb2ae3a2f90b286f20f767609beb77522c0",
          "correctionOrComment": "Zeichen",
          "answerCategory": "correct"
        },
        {
          "text": "Der Datentyp char speichert einzelne Zeichen",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Der Datentyp char speichert einzelne Zeichen",
          "answerCategory": "correct"
        },
        {
          "text": "einzelne Zeichen",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "einzelne Zeichen",
          "answerCategory": "correct"
        },
        {
          "text": "Einen einzigen Character, also ein ASCII-Zeichen.",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c",
          "correctionOrComment": "Einen einzigen Character, also ein ASCII-Zeichen.",
          "answerCategory": "correct"
        },
        {
          "text": "einzelne Buchstaben oder Zeichen",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "einzelne Buchstaben oder Zeichen",
          "answerCategory": "correct"
        }
      ]
    },
    {
      "text": "Warum ergibt die Operation 'a' + 'b' 195 und nicht \"ab\"",
      "id": 50715,
      "title": "Addition von Chars",
      "type": "reason",
      "referenceAnswer": {
        "text": "Chars sind intern als 16 bit Binärzahlen repräsentiert. Bei einer Rechenoperation mit Chars werden diese als Integer interpretiert.",
        "aspects": [
          {
            "text": "Chars sind intern als 16 bit Binärzahlen repräsentiert",
            "elements": [
              [
                0,
                54
              ]
            ]
          },
          {
            "text": "Bei einer Rechenoperation mit Chars werden diese als Integer interpretiert",
            "elements": [
              [
                56,
                130
              ]
            ]
          }
        ]
      },
      "answersAnnotation": [
        {
          "text": "weil a und b in ziffern umgewandelt werden vgl ascii tabelle",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "weil a und b in ziffern umgewandelt werden vgl ascii tabelle",
          "answerCategory": "correct"
        },
        {
          "text": "Diese Operation ergibt 195, da dies die Summe der den chars 'a' und 'b' zugeordneten Werte in der ASCII Tabelle ist. Um die beiden Werte hintereinander zu drucken müsste es a + b heißen. Die Anführungszeichen ' ' verweisen auf besagten Wert anstatt auf die Buchstaben.",
          "id": "8bbd52208353c14f154f1402cebf5829afb1708d06b5dc25064dff23",
          "correctionOrComment": "Diese Operation ergibt 195, da dies die Summe der den chars 'a' und 'b' zugeordneten Werte in der ASCII Tabelle ist. Um die beiden Werte hintereinander zu drucken müsste es a + b heißen. Die Anführungszeichen ' ' verweisen auf besagten Wert anstatt auf die Buchstaben.",
          "answerCategory": "correct"
        },
        {
          "text": "Weil die zu den Zeichen gehörenden Zahlenwerte addiert und nicht die Zeichen verkettet werden.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Weil die zu den Zeichen gehörenden Zahlenwerte addiert und nicht die Zeichen verkettet werden.",
          "answerCategory": "correct"
        },
        {
          "text": "Da der Char a den Wert 97 und b den Wert 98 repräsentiert.",
          "id": "4cfc3a1811fe40afa401b25ef7fa0379f1f7c1930a04f8755d678474",
          "correctionOrComment": "Da der Char a den Wert 97 und b den Wert 98 repräsentiert.",
          "answerCategory": "correct"
        },
        {
          "text": "Da hinter den Buchstaben einzelne Zahlenwerte stecken und diese werden dann verrechnet. Dies bezweckt das Ausrufungszeichen.",
          "id": "8a217ea5f39d0f20db42ef9bcb667eacd060a40b50a18655172ec4b8",
          "correctionOrComment": "Da hinter den Buchstaben einzelne Zahlenwerte stecken und diese werden dann verrechnet. Dies bezweckt das Ausrufungszeichen.",
          "answerCategory": "binary_correct"
        },
        {
          "text": "Da bei der Operation die ASCII-Werte 97 und 98 der Zeichen verrechnet werden.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Da bei der Operation die ASCII-Werte 97 und 98 der Zeichen verrechnet werden.",
          "answerCategory": "correct"
        },
        {
          "text": "weil das '  den Asci-Code nimmt um dem Zeichen einen Int-Wert zuzuordnen.",
          "id": "1e2c3eb4744dbc36de4e827f187dd2a073d91b8790a2ff117694dd7b",
          "correctionOrComment": "weil das ' den Asci-Code nimmt um dem Zeichen einen Int-Wert zuzuordnen.",
          "answerCategory": "correct"
        },
        {
          "text": "Weil auch chars wie Ziffern miteinander addiert werden können, da ihnen im Unicode ein Wert\\/ eine Zahl zugewiesen ist.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Weil auch chars wie Ziffern miteinander addiert werden können, da ihnen im Unicode ein Wert\\/ eine Zahl zugewiesen ist.",
          "answerCategory": "correct"
        },
        {
          "text": "ascii code",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "ascii code",
          "answerCategory": "partially_correct"
        },
        {
          "text": "weil die position in dem ascii alphabet des chars ausgegeben wird( zeichen werden wie ints behandelt)",
          "id": "c1b8144ee1a30244a571c3d9b48b2c394a7489065d2565968f521645",
          "correctionOrComment": "weil die position in dem ascii alphabet des chars ausgegeben wird( zeichen werden wie ints behandelt)",
          "answerCategory": "binary_correct"
        },
        {
          "text": "Da der ASCII Wert hinter den chars addiert wird und nicht nicht die zwei chars an sich addiert\\/ hinter einander geschrieben werden.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Da der ASCII Wert hinter den chars addiert wird und nicht nicht die zwei chars an sich addiert\\/ hinter einander geschrieben werden.",
          "answerCategory": "correct"
        },
        {
          "text": "Da jedem Zeichen ein 16 Bit langer Binärwert zugewiesen ist und dieser bei der Operation + addiert wird, nicht aber die Zeichen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Da jedem Zeichen ein 16 Bit langer Binärwert zugewiesen ist und dieser bei der Operation + addiert wird, nicht aber die Zeichen.",
          "answerCategory": "correct"
        },
        {
          "text": "da die char a und b in der ASCII tabelle bestimmten Zahlen zugewiesen sind, das Programm addiert diese und nicht die Zeichen",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "da die char a und b in der ASCII tabelle bestimmten Zahlen zugewiesen sind, das Programm addiert diese und nicht die Zeichen",
          "answerCategory": "correct"
        },
        {
          "text": "Wenn chars addiert werden wird die ACCII zahl dahinter addiert.",
          "id": "ea674ab55536a8b603be44d13510e32c7aab02088bf48c2802e4febd",
          "correctionOrComment": "Wenn chars addiert werden wird die ACCII zahl dahinter addiert.",
          "answerCategory": "correct"
        },
        {
          "text": "Die Operation ergibt 195, da die ASCII-Werte der Zeichen addiert werden.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Die Operation ergibt 195, da die ASCII-Werte der Zeichen addiert werden.",
          "answerCategory": "correct"
        },
        {
          "text": "Jeder character besitzt eine bit Referenz. Bei der oben genannten Operation wird die bit referenz, nicht die zeichen an sich addiert.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Jeder character besitzt eine bit Referenz. Bei der oben genannten Operation wird die bit referenz, nicht die zeichen an sich addiert.",
          "answerCategory": "binary_correct"
        },
        {
          "text": "Weil 'a' und 'b' chars sind und ihr Wert aus der ASCII Tabelle addiert wird.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Weil 'a' und 'b' chars sind und ihr Wert aus der ASCII Tabelle addiert wird.",
          "answerCategory": "correct"
        },
        {
          "text": "Weil zwischen zwei Apostrophe man Char schreibt und ein Char repräsentiert zwar ein Zeichen, ist aber als Zahl gespeichert, die ASCII-Code enthält.",
          "id": "408f0afbe2440a4383a1e75b7d5b0b4202c7f7131a9acf9bd70492f3",
          "correctionOrComment": "Weil zwischen zwei Apostrophe man Char schreibt und ein Char repräsentiert zwar ein Zeichen, ist aber als Zahl gespeichert, die ASCII-Code enthält.",
          "answerCategory": "partially_correct"
        },
        {
          "text": "Weil Java immer automatisch alle Zeichen als Integer versteht, sofern nicht ausdrücklich gesagt wird, dass sie z.B. Chars sind. Die Zahl 195 sind die ASCII Werte, die hinter jedem einzelnen Zeichen auf der Tastatur stehen.",
          "id": "0ce8152aa92136af039b687c01c7dccfcb271f3db2d0ddcb3cfdd3e6",
          "correctionOrComment": "Weil Java immer automatisch alle Zeichen als Integer versteht, sofern nicht ausdrücklich gesagt wird, dass sie z.B. Chars sind. Die Zahl 195 sind die ASCII Werte, die hinter jedem einzelnen Zeichen auf der Tastatur stehen.",
          "answerCategory": "binary_correct"
        },
        {
          "text": "weil es nur ' ' sind und nicht  ",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "weil es nur ' ' sind und nicht ",
          "answerCategory": "irrelevant"
        },
        {
          "text": "Weil beide Zeichen als Char dargestellt sind und in der Addition zu Ints getypcasted werden.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "correctionOrComment": "Weil beide Zeichen als Char dargestellt sind und in der Addition zu Ints getypcasted werden.",
          "answerCategory": "binary_correct"
        },
        {
          "text": "weil die ACSI Tabellenwerte zusammengerechnet werden",
          "id": "8a1c55283fd2fc15f72ad8c88c9dcc447f528814a41bf2a7ab51950a",
          "correctionOrComment": "weil die ACSI Tabellenwerte zusammengerechnet werden",
          "answerCategory": "correct"
        },
        {
          "text": "Weil hinter jedem Char eine Zahl steht und die Zahlen addiert werden",
          "id": "6332531eeafc6e0ede272192be898f549950fb32b209d04f0a98306a",
          "correctionOrComment": "Weil hinter jedem Char eine Zahl steht und die Zahlen addiert werden",
          "answerCategory": "correct"
        },
        {
          "text": "Da, die Zeichen a und b jeweils für bestimmte Werte stehen und somit im Datentyp int diese Werte miteinander multipliziert werden.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Da, die Zeichen a und b jeweils für bestimmte Werte stehen und somit im Datentyp int diese Werte miteinander multipliziert werden.",
          "answerCategory": "correct"
        },
        {
          "text": "da durch die Anführungszeichen mit den Werten, die hinter den Zeichen stehen gearbeitet wird und nicht mit dem Buchstaben",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "da durch die Anführungszeichen mit den Werten, die hinter den Zeichen stehen gearbeitet wird und nicht mit dem Buchstaben",
          "answerCategory": "correct"
        },
        {
          "text": "'a' und 'b' sind jeweils Chars. Jedem Char ist ein bestimmter Wert der ASCII Tabelle zugeordnet. Wenn man Chars verrechnet werden nicht die einzelnen Zeichen zusammenefügt, sondern die ASCII Werte verrechnet.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "'a' und 'b' sind jeweils Chars. Jedem Char ist ein bestimmter Wert der ASCII Tabelle zugeordnet. Wenn man Chars verrechnet werden nicht die einzelnen Zeichen zusammenefügt, sondern die ASCII Werte verrechnet.",
          "answerCategory": "correct"
        },
        {
          "text": "'a' und 'b' stellen char da, keine Strings! Und jedem char ist eine Zahl (ASCII-Tabelle) zugeordnet. So dem 'a' die 97 und dem 'b' die 98. Summiert man diese beiden Zahlen ist das Ergebnis 195.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "'a' und 'b' stellen char da, keine Strings! Und jedem char ist eine Zahl (ASCII-Tabelle) zugeordnet. So dem 'a' die 97 und dem 'b' die 98. Summiert man diese beiden Zahlen ist das Ergebnis 195.",
          "answerCategory": "correct"
        },
        {
          "text": "Ascii werte werde addiert",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Ascii werte werde addiert",
          "answerCategory": "correct"
        },
        {
          "text": "weil den Variablen 'a' und 'b' scheinbar die Zahlenwerte dementsprechend zugeordnet worden sind und verrechnet werden",
          "id": "271f93f45e9b4067327ed5c8cd30a034730aaace4382803c3e1d6c2f",
          "correctionOrComment": "weil den Variablen 'a' und 'b' scheinbar die Zahlenwerte dementsprechend zugeordnet worden sind und verrechnet werden",
          "answerCategory": "binary_correct"
        },
        {
          "text": "Wenn man chars mit einander verrechnet, verrechnet man den ASCII Wert der beiden Zeichen!",
          "id": "de0a13aab90b285db3fde617643bd713b7ae7e35a3792c5f539c98b8",
          "correctionOrComment": "Wenn man chars mit einander verrechnet, verrechnet man den ASCII Wert der beiden Zeichen!",
          "answerCategory": "correct"
        },
        {
          "text": "Durch den + Operator werden chars nicht zu einem String konkateniert sondern die Ordnungszahlen die den chars zugeordnet sind werden addiert.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Durch den + Operator werden chars nicht zu einem String konkateniert sondern die Ordnungszahlen die den chars zugeordnet sind werden addiert.",
          "answerCategory": "binary_correct"
        },
        {
          "text": "Nicht die Character-Zeichen werden addiert, sondern die binären Werte, die hinter den Zeichen stecken. Nach der Addition wird das Zeichen, das dem Ergebnis zugeordnet ist, ausgegeben.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6",
          "correctionOrComment": "Nicht die Character-Zeichen werden addiert, sondern die binären Werte, die hinter den Zeichen stecken. Nach der Addition wird das Zeichen, das dem Ergebnis zugeordnet ist, ausgegeben.",
          "answerCategory": "missconception"
        },
        {
          "text": "Da die ASCII Werte von a und b addiert werden.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Da die ASCII Werte von a und b addiert werden.",
          "answerCategory": "correct"
        },
        {
          "text": "Weil hier die Werte der Variablen a und b addiert werden und diese keine Chars sind.",
          "id": "f09265efb456b0336079ad5b238daa1e38a11b1d71cc0e1a4e8edd56",
          "correctionOrComment": "Weil hier die Werte der Variablen a und b addiert werden und diese keine Chars sind.",
          "answerCategory": "partially_correct"
        },
        {
          "text": "Weil die chars 'a' und 'b' als ints interpretiert werden und somit einfach nur deren Werte addiert werden. Dies könnte auch einen anderen char ergeben (TypeCast notwending!)...",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6",
          "correctionOrComment": "Weil die chars 'a' und 'b' als ints interpretiert werden und somit einfach nur deren Werte addiert werden. Dies könnte auch einen anderen char ergeben (TypeCast notwending!)...",
          "answerCategory": "correct"
        },
        {
          "text": "Weil die ASCII Werte der beiden buchstaden summiert werden und nicht die zeichen aneinander gehängt werden",
          "id": "53750c72b7bb26cb6ff7115e383ca150d5a632a909a7f79e2f5274a4",
          "correctionOrComment": "Weil die ASCII Werte der beiden buchstaden summiert werden und nicht die zeichen aneinander gehängt werden",
          "answerCategory": "correct"
        },
        {
          "text": "?",
          "id": "8416c38cc898f1ac7cc9d64e89dab1f70f5ddab002a5b2a1713f93f5",
          "correctionOrComment": "?",
          "answerCategory": "none"
        },
        {
          "text": "mkmkmkm",
          "id": "192f56eb9bd894a72b30c303247b107be2c4591f310dd69a67927f48",
          "correctionOrComment": "mkmkmkm",
          "answerCategory": "none"
        },
        {
          "text": "Die Zeichen a und b werden zu integers umgewandelt und addiert.",
          "id": "7ba019a2553e1137a4bbb8d3c779a48e5ceb2ca3a162e6e0a945ef0f",
          "correctionOrComment": "Die Zeichen a und b werden zu integers umgewandelt und addiert.",
          "answerCategory": "correct"
        },
        {
          "text": "Es ist der ASCII-Wert.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "correctionOrComment": "Es ist der ASCII-Wert.",
          "answerCategory": "partially_correct"
        },
        {
          "text": "Weil a und b als integer interpretiert werden, und nicht als character. Der Compiler wandelt die Symbole in die dazugehörigen ASCII Werte um und addiert diese.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Weil a und b als integer interpretiert werden, und nicht als character. Der Compiler wandelt die Symbole in die dazugehörigen ASCII Werte um und addiert diese.",
          "answerCategory": "correct"
        },
        {
          "text": "Dies liegt daran, dass + als Verknüpfung für Integer aufgefasst wird. Die Zeichen a und b werden also als Integer addiert.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "correctionOrComment": "Dies liegt daran, dass + als Verknüpfung für Integer aufgefasst wird. Die Zeichen a und b werden also als Integer addiert.",
          "answerCategory": "binary_correct"
        },
        {
          "text": "Der plus Operator kann die character so nicht addieren, daher addiert ihr ihre werte der ASCII Tabelle",
          "id": "b51d18b551043c1f145f22dbde6f8531faeaf68c54ed9dd79ce24d17",
          "correctionOrComment": "Der plus Operator kann die character so nicht addieren, daher addiert ihr ihre werte der ASCII Tabelle",
          "answerCategory": "missconception"
        },
        {
          "text": "Die Anführungszeichen sind ausschlaggebend. Hier wird die char summe gebildet.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Die Anführungszeichen sind ausschlaggebend. Hier wird die char summe gebildet.",
          "answerCategory": "partially_correct"
        },
        {
          "text": "weil hinter den Buchstaben dezimale Werte stecken und die Buchstaben nur eine Asci representation sind",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c",
          "correctionOrComment": "weil hinter den Buchstaben dezimale Werte stecken und die Buchstaben nur eine Asci representation sind",
          "answerCategory": "partially_correct"
        },
        {
          "text": "Weil es binärwerte sind",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Weil es binärwerte sind",
          "answerCategory": "partially_correct"
        },
        {
          "text": "Ascii Tabellen Werte",
          "id": "ae8820303e493738a211ebb2ae3a2f90b286f20f767609beb77522c0",
          "correctionOrComment": "Ascii Tabellen Werte",
          "answerCategory": "partially_correct"
        },
        {
          "text": "Als chars werden a und b in 16 bit codiert und diese bit darstellungen werden durch + addiert",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Als chars werden a und b in 16 bit codiert und diese bit darstellungen werden durch + addiert",
          "answerCategory": "correct"
        },
        {
          "text": "chars sind als Binärzahlen definiert",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "chars sind als Binärzahlen definiert",
          "answerCategory": "partially_correct"
        },
        {
          "text": "Weil dort die ASII-Werte addiert werden.",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c",
          "correctionOrComment": "Weil dort die ASII-Werte addiert werden.",
          "answerCategory": "binary_correct"
        },
        {
          "text": "weil diese Summe zu einem Integer gecastet wurde. char summe = (int) ('a'+'b')",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "weil diese Summe zu einem Integer gecastet wurde. char summe = (int) ('a'+'b')",
          "answerCategory": "missconception"
        }
      ]
    },
    {
      "text": "Was ist der konzeptuelle Unterschied zwischen dem Wert einer String Variablen und dem eines primitiven Datentyps?",
      "id": 50717,
      "title": "Wert von Objecten vs primitiven Datentypen",
      "type": "comparison",
      "referenceAnswer": {
        "text": "Die Variable eines primitiven Datentyps speichert den Inhalt an sich. Die Variable eines Strings hat als Wert eine Referenz auf den eigentlichen Inhalt im Speicher.",
        "aspects": [
          {
            "text": "Die Variable eines primitiven Datentyps speichert den Inhalt an sich",
            "elements": [
              [
                0,
                68
              ]
            ]
          },
          {
            "text": "Die Variable eines Strings hat als Wert eine Referenz auf den eigentlichen Inhalt im Speicher",
            "elements": [
              [
                70,
                163
              ]
            ]
          }
        ]
      },
      "answersAnnotation": [
        {
          "text": "stringvariablen sind zeichenketten, primitive datentypen sind zifernketten",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "stringvariablen sind zeichenketten, primitive datentypen sind zifernketten",
          "answerCategory": "missconception"
        },
        {
          "text": "primitive Datendypen benötigen mmer gleich viel Speicherplatz. Bei Strings hängt das von der Länge ab, Daher wird ihr Speicher dynamisch reserviert.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "primitive Datendypen benötigen mmer gleich viel Speicherplatz. Bei Strings hängt das von der Länge ab, Daher wird ihr Speicher dynamisch reserviert.",
          "answerCategory": "correct"
        },
        {
          "text": "Der Wert eines Strings stellt lediglich eine Referenz dar.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Der Wert eines Strings stellt lediglich eine Referenz dar.",
          "answerCategory": "partially_correct"
        },
        {
          "text": "k",
          "id": "8a217ea5f39d0f20db42ef9bcb667eacd060a40b50a18655172ec4b8",
          "correctionOrComment": "k",
          "answerCategory": "none"
        },
        {
          "text": "Wert eines Strings ist seine Referenz, prim datentyp ist eine Binärzahl",
          "id": "c1b8144ee1a30244a571c3d9b48b2c394a7489065d2565968f521645",
          "correctionOrComment": "Wert eines Strings ist seine Referenz, prim datentyp ist eine Binärzahl",
          "answerCategory": "binary_correct"
        },
        {
          "text": "Auf Objekten können Operationen ausgeführt werden. Auf primitiven Datentypen nicht.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Auf Objekten können Operationen ausgeführt werden. Auf primitiven Datentypen nicht.",
          "answerCategory": "missconception"
        },
        {
          "text": "Bei einfachen Datentypen wird direkt der Wert in einer Variable gespeichert, bei Objektvariablen wie Strings wird nur eine Referenz auf den eigentlichen String gespeichert.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Bei einfachen Datentypen wird direkt der Wert in einer Variable gespeichert, bei Objektvariablen wie Strings wird nur eine Referenz auf den eigentlichen String gespeichert.",
          "answerCategory": "correct"
        },
        {
          "text": "primitiver Daten typ = call by value String = call by reference",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "primitiver Daten typ = call by value String = call by reference",
          "answerCategory": "missconception"
        },
        {
          "text": "Strings werden durch Referenzen gespeichert.",
          "id": "ea674ab55536a8b603be44d13510e32c7aab02088bf48c2802e4febd",
          "correctionOrComment": "Strings werden durch Referenzen gespeichert.",
          "answerCategory": "partially_correct"
        },
        {
          "text": "Werden Strings verwendet, so werden nicht die Daten an sich aufgerufen, sondern deren Referenz. Bei primitiven Datentypen verwendet man die Daten an sich.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Werden Strings verwendet, so werden nicht die Daten an sich aufgerufen, sondern deren Referenz. Bei primitiven Datentypen verwendet man die Daten an sich.",
          "answerCategory": "correct"
        },
        {
          "text": "primitive Datentypen haben eine feste Größe und können deshalb direkt gespeichert werden. String variablen hingegen haben keine festgelegte Größe weshalb unklar ist wie viel Speicher man braucht. Deshalb wird in diesem Fall mit einem extra Speicherplatz gearbeitet, welcher mit einem Identifier versehen wird. In der variable selbst wird die Referenz zu diesem Speicherplatz gespeichert.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "primitive Datentypen haben eine feste Größe und können deshalb direkt gespeichert werden. String variablen hingegen haben keine festgelegte Größe weshalb unklar ist wie viel Speicher man braucht. Deshalb wird in diesem Fall mit einem extra Speicherplatz gearbeitet, welcher mit einem Identifier versehen wird. In der variable selbst wird die Referenz zu diesem Speicherplatz gespeichert.",
          "answerCategory": "correct"
        },
        {
          "text": "Eine String Variable enthält stets nur eine Referenz auf die Speicher, in der sich eine Zeichenkette befindet. Primitive Datentypen wie Integer enthalten deren Wert.",
          "id": "408f0afbe2440a4383a1e75b7d5b0b4202c7f7131a9acf9bd70492f3",
          "correctionOrComment": "Eine String Variable enthält stets nur eine Referenz auf die Speicher, in der sich eine Zeichenkette befindet. Primitive Datentypen wie Integer enthalten deren Wert.",
          "answerCategory": "correct"
        },
        {
          "text": "Ein String stellt immer eine Zeichenkette dar.",
          "id": "0ce8152aa92136af039b687c01c7dccfcb271f3db2d0ddcb3cfdd3e6",
          "correctionOrComment": "Ein String stellt immer eine Zeichenkette dar.",
          "answerCategory": "irrelevant"
        },
        {
          "text": "Speicherplatzgröße Referenz",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Speicherplatzgröße Referenz",
          "answerCategory": "partially_correct"
        },
        {
          "text": "Der String wird als Objekt angelegt, bei primitiven Datentypen ist dies nicht der Fall.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "correctionOrComment": "Der String wird als Objekt angelegt, bei primitiven Datentypen ist dies nicht der Fall.",
          "answerCategory": "partially_correct"
        },
        {
          "text": "Der Wert des Strings ist die Zuordnung im Speicher, nicht der Inhalt der Variable selbst.",
          "id": "58b2aaa0bfae7acc021b3260e941117b529b2e69de878fd7d45c61a9",
          "correctionOrComment": "Der Wert des Strings ist die Zuordnung im Speicher, nicht der Inhalt der Variable selbst.",
          "answerCategory": "partially_correct"
        },
        {
          "text": "Strings werden mit Referenzen aufgerufen und primitive Datentypen mit ihrem Wert",
          "id": "6332531eeafc6e0ede272192be898f549950fb32b209d04f0a98306a",
          "correctionOrComment": "Strings werden mit Referenzen aufgerufen und primitive Datentypen mit ihrem Wert",
          "answerCategory": "correct"
        },
        {
          "text": "der Unterschied ist dass bei einem String mit Ketten von Zeichen oder Ziffern gearbeitet wird während bei primitiven Datentypen mit einzelnen Zahlen, Ziffern oder Zeichen gearbeitet wird",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "der Unterschied ist dass bei einem String mit Ketten von Zeichen oder Ziffern gearbeitet wird während bei primitiven Datentypen mit einzelnen Zahlen, Ziffern oder Zeichen gearbeitet wird",
          "answerCategory": "partially_correct"
        },
        {
          "text": "Bei einem primitiven Datentypen wird bei der Initialisierung ein fester Speicherbereich dafür angelegt. Bei Strings funktioniert das nicht, da diese keine festgelegte Länge haben. Daher werden Strings mit Referenzen gespeichert. Es wird ein fester Speicherbereich angelegt, der lediglich die Referenz auf ein Stringobjekt speichert, welches allerdings woanders im Speicher liegt.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Bei einem primitiven Datentypen wird bei der Initialisierung ein fester Speicherbereich dafür angelegt. Bei Strings funktioniert das nicht, da diese keine festgelegte Länge haben. Daher werden Strings mit Referenzen gespeichert. Es wird ein fester Speicherbereich angelegt, der lediglich die Referenz auf ein Stringobjekt speichert, welches allerdings woanders im Speicher liegt.",
          "answerCategory": "correct"
        },
        {
          "text": "-",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "-",
          "answerCategory": "none"
        },
        {
          "text": "Stings sind Arrays, also Listen von Chars",
          "id": "271f93f45e9b4067327ed5c8cd30a034730aaace4382803c3e1d6c2f",
          "correctionOrComment": "Stings sind Arrays, also Listen von Chars",
          "answerCategory": "irrelevant"
        },
        {
          "text": "Die String Variable speichert eine Referenz auf ein Objekt. Ein primitiver Datentyp wird nicht durch eine Referenz, sonder direkt gespeichert.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Die String Variable speichert eine Referenz auf ein Objekt. Ein primitiver Datentyp wird nicht durch eine Referenz, sonder direkt gespeichert.",
          "answerCategory": "correct"
        },
        {
          "text": "Strings sind, im Gegensatz zu primitiven Datentypen, Objekte. Das heißt, sie speichern einen Wert bzw. Zeichenkette nicht direkt, sondern verweisen auf den Speicherplatz.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6",
          "correctionOrComment": "Strings sind, im Gegensatz zu primitiven Datentypen, Objekte. Das heißt, sie speichern einen Wert bzw. Zeichenkette nicht direkt, sondern verweisen auf den Speicherplatz.",
          "answerCategory": "correct"
        },
        {
          "text": "Eine String Variable ist ein Objekt und speichert nicht die Daten selber sondern die Referenz auf die Daten.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Eine String Variable ist ein Objekt und speichert nicht die Daten selber sondern die Referenz auf die Daten.",
          "answerCategory": "correct"
        },
        {
          "text": "Ein String ist eine eigene Klasse mit Attributen und Methoden und nutzt zum speichern der Informationen selbst primitive datatypes. Ein primitive datatype hat keine Methoden, sondern stellt selbst direkt seinen Wert dar. Zudem ist in Java ein Array kein primitive datatype, da diese in eine wrapper-class mit dessen Länge eingebettet ist - anders als in C++, wo bei einem Array nur die primitive datatypes hintereinander im Speicher abgelegt werden.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6",
          "correctionOrComment": "Ein String ist eine eigene Klasse mit Attributen und Methoden und nutzt zum speichern der Informationen selbst primitive datatypes. Ein primitive datatype hat keine Methoden, sondern stellt selbst direkt seinen Wert dar. Zudem ist in Java ein Array kein primitive datatype, da diese in eine wrapper-class mit dessen Länge eingebettet ist - anders als in C++, wo bei einem Array nur die primitive datatypes hintereinander im Speicher abgelegt werden.",
          "answerCategory": "partially_correct"
        },
        {
          "text": "ein String wird als Objekt im Speicher gespeichert, es wird nur mit einer referenz auf ihn verwiesen nicht mit dem Inhalt selbst gerechnet",
          "id": "53750c72b7bb26cb6ff7115e383ca150d5a632a909a7f79e2f5274a4",
          "correctionOrComment": "ein String wird als Objekt im Speicher gespeichert, es wird nur mit einer referenz auf ihn verwiesen nicht mit dem Inhalt selbst gerechnet",
          "answerCategory": "partially_correct"
        },
        {
          "text": "Ein String ist eine Verkettung verschiedener Zeichen, ein primitiver Datentyp hat nur einen Wert",
          "id": "8416c38cc898f1ac7cc9d64e89dab1f70f5ddab002a5b2a1713f93f5",
          "correctionOrComment": "Ein String ist eine Verkettung verschiedener Zeichen, ein primitiver Datentyp hat nur einen Wert",
          "answerCategory": "partially_correct"
        },
        {
          "text": "jijijij",
          "id": "192f56eb9bd894a72b30c303247b107be2c4591f310dd69a67927f48",
          "correctionOrComment": "jijijij",
          "answerCategory": "none"
        },
        {
          "text": "Strings sind Objekte mit bestimmten Attributen und Operationen.",
          "id": "7ba019a2553e1137a4bbb8d3c779a48e5ceb2ca3a162e6e0a945ef0f",
          "correctionOrComment": "Strings sind Objekte mit bestimmten Attributen und Operationen.",
          "answerCategory": "irrelevant"
        },
        {
          "text": "Strings sind objektorientiert.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "correctionOrComment": "Strings sind objektorientiert.",
          "answerCategory": "irrelevant"
        },
        {
          "text": "Der Wert einer String variable wird in einem seperaten Speicherplatz verwaltet und der String selbst speichert nur die Referenz auf diesen Speicherplatz",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Der Wert einer String variable wird in einem seperaten Speicherplatz verwaltet und der String selbst speichert nur die Referenz auf diesen Speicherplatz",
          "answerCategory": "partially_correct"
        },
        {
          "text": "Der String speichert nur die Referenz auf den Wert, in einem primitiven Datentypen ist der Wert direkt gespeichert.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "correctionOrComment": "Der String speichert nur die Referenz auf den Wert, in einem primitiven Datentypen ist der Wert direkt gespeichert.",
          "answerCategory": "correct"
        },
        {
          "text": "Bei primitiven Datentypen wird der Wert direkt in dem Datentypen gespeichert. Springs werden in Referenzen gespeichert, die auf den String verweisen.",
          "id": "b51d18b551043c1f145f22dbde6f8531faeaf68c54ed9dd79ce24d17",
          "correctionOrComment": "Bei primitiven Datentypen wird der Wert direkt in dem Datentypen gespeichert. Springs werden in Referenzen gespeichert, die auf den String verweisen.",
          "answerCategory": "correct"
        },
        {
          "text": "Eine String Variable verweist nur auf auf ein Objekt.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Eine String Variable verweist nur auf auf ein Objekt.",
          "answerCategory": "partially_correct"
        },
        {
          "text": "Werte von Strings werden als Referenzen gespeichert (call-by-reference), Werte von Datentypen als einzelne Werte (call-by-value).",
          "id": "f09265efb456b0336079ad5b238daa1e38a11b1d71cc0e1a4e8edd56",
          "correctionOrComment": "Werte von Strings werden als Referenzen gespeichert (call-by-reference), Werte von Datentypen als einzelne Werte (call-by-value).",
          "answerCategory": "binary_correct"
        },
        {
          "text": "Die String variable ist eine Referenz auf einen im Speicher stehenden Wertes.",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c",
          "correctionOrComment": "Die String variable ist eine Referenz auf einen im Speicher stehenden Wertes.",
          "answerCategory": "partially_correct"
        },
        {
          "text": "x",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "x",
          "answerCategory": "none"
        },
        {
          "text": "Die String Variable speichert eine Referenz auf den Wert, primitive Datentypen speichern den Wert an sich.",
          "id": "b8607e0369fbf3e33bc0e358f840915d8c085d1496097351913c0122",
          "correctionOrComment": "Die String Variable speichert eine Referenz auf den Wert, primitive Datentypen speichern den Wert an sich.",
          "answerCategory": "correct"
        },
        {
          "text": "Wert zeigt auf die Referenz",
          "id": "ae8820303e493738a211ebb2ae3a2f90b286f20f767609beb77522c0",
          "correctionOrComment": "Wert zeigt auf die Referenz",
          "answerCategory": "irrelevant"
        },
        {
          "text": "Primitive Datentypen speichern den Wert selbst, Strings sind Objekte und enthalten eine Referenz auf das eigentliche Objekt",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Primitive Datentypen speichern den Wert selbst, Strings sind Objekte und enthalten eine Referenz auf das eigentliche Objekt",
          "answerCategory": "correct"
        },
        {
          "text": "Strings speichern Referenz zu Objekt",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Strings speichern Referenz zu Objekt",
          "answerCategory": "partially_correct"
        },
        {
          "text": "Bei primitven Datentypen werden die Werte direkt in dem reservierten Speicherplatz gespeichert, beim String wird eine Referenz auf einen Speicherplatz gespeichert, in dem dann wirklich die Daten stehen.",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c",
          "correctionOrComment": "Bei primitven Datentypen werden die Werte direkt in dem reservierten Speicherplatz gespeichert, beim String wird eine Referenz auf einen Speicherplatz gespeichert, in dem dann wirklich die Daten stehen.",
          "answerCategory": "correct"
        },
        {
          "text": "Speicherplatz",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Speicherplatz",
          "answerCategory": "irrelevant"
        }
      ]
    },
    {
      "text": "Wie ist es möglich, dass inhaltsgleiche Strings vom Vergleichsoperator `==` als ungleich bewertet werden?",
      "id": 50719,
      "title": "Vergleichen von Strings",
      "type": "reason",
      "referenceAnswer": {
        "text": "Der Vergleichsoperator '==' vergleicht den Wert von Variablen. Strings enthalten als Wert eine Referenz auf die Zeichenkette. Dementsprechend wird die Referenz und nicht die Zeichenkette verglichen.",
        "aspects": [
          {
            "text": "Der Vergleichsoperator '==' vergleicht den Wert von Variablen",
            "elements": [
              [
                0,
                61
              ]
            ],
            "implied": true
          },
          {
            "text": "Strings enthalten als Wert eine Referenz auf die Zeichenkette",
            "elements": [
              [
                63,
                124
              ]
            ],
            "implied": true
          },
          {
            "text": "Dementsprechend wird die Referenz und nicht die Zeichenkette verglichen",
            "elements": [
              [
                126,
                197
              ]
            ]
          }
        ]
      },
      "answersAnnotation": [
        {
          "text": "sie verweisen auf unterschiedliche referenzen",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "sie verweisen auf unterschiedliche referenzen",
          "answerCategory": "correct"
        },
        {
          "text": "Mit dem Vergleichsoperator ' == ' werden die Referenzen verglichen, auf die die beiden Strings verweisen, nicht die Strings selbst.",
          "id": "8bbd52208353c14f154f1402cebf5829afb1708d06b5dc25064dff23",
          "correctionOrComment": "Mit dem Vergleichsoperator ' == ' werden die Referenzen verglichen, auf die die beiden Strings verweisen, nicht die Strings selbst.",
          "answerCategory": "correct"
        },
        {
          "text": "Es wird die Objektreferenz\\/Adresse verglichen. Es handelt sich um 2 verschiedene Objekte.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Es wird die Objektreferenz\\/Adresse verglichen. Es handelt sich um 2 verschiedene Objekte.",
          "answerCategory": "correct"
        },
        {
          "text": "Da die Referenz verglichen wird und diese verschieden sein kann",
          "id": "8a217ea5f39d0f20db42ef9bcb667eacd060a40b50a18655172ec4b8",
          "correctionOrComment": "Da die Referenz verglichen wird und diese verschieden sein kann",
          "answerCategory": "correct"
        },
        {
          "text": "PaCo legt beim Erstellen eines neuen Strings eine neue Referenz an. Diese Referenzen werden dann verglichen, welche trotz gleichem Inhalts unterschiedlich sind.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "PaCo legt beim Erstellen eines neuen Strings eine neue Referenz an. Diese Referenzen werden dann verglichen, welche trotz gleichem Inhalts unterschiedlich sind.",
          "answerCategory": "correct"
        },
        {
          "text": "Der Vergleichsoperator vergleicht die Referenzen der Strings.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Der Vergleichsoperator vergleicht die Referenzen der Strings.",
          "answerCategory": "correct"
        },
        {
          "text": "Weil die Referenz verglichen wird, nicht der Inhalt.",
          "id": "1e2c3eb4744dbc36de4e827f187dd2a073d91b8790a2ff117694dd7b",
          "correctionOrComment": "Weil die Referenz verglichen wird, nicht der Inhalt.",
          "answerCategory": "correct"
        },
        {
          "text": "da ihr Wert auf verschiedene Referenzen zeigt.",
          "id": "c1b8144ee1a30244a571c3d9b48b2c394a7489065d2565968f521645",
          "correctionOrComment": "da ihr Wert auf verschiedene Referenzen zeigt.",
          "answerCategory": "correct"
        },
        {
          "text": "Da als Wert die Referenz auf den Inhalt gespeichert wird. So werden die Referenzen und nicht die Inhalte miteinander verglichen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Da als Wert die Referenz auf den Inhalt gespeichert wird. So werden die Referenzen und nicht die Inhalte miteinander verglichen.",
          "answerCategory": "correct"
        },
        {
          "text": "Da hierbei nicht der Inhalt der Strings verglichen wird, sondern die Referenzen die auf die Strings verweisen, diese können ungleich sein auch wenn der String denselben Inhalt hat.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Da hierbei nicht der Inhalt der Strings verglichen wird, sondern die Referenzen die auf die Strings verweisen, diese können ungleich sein auch wenn der String denselben Inhalt hat.",
          "answerCategory": "correct"
        },
        {
          "text": "Ja, es werden nur die Referenzen verglichen und unterschiedliche Arten des erstellens, können zwei Strings mit den gleichen Werten unterschiedliche Referenzen haben",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Ja, es werden nur die Referenzen verglichen und unterschiedliche Arten des erstellens, können zwei Strings mit den gleichen Werten unterschiedliche Referenzen haben",
          "answerCategory": "correct"
        },
        {
          "text": "Weil nur die Referenz verglichen wird.",
          "id": "ea674ab55536a8b603be44d13510e32c7aab02088bf48c2802e4febd",
          "correctionOrComment": "Weil nur die Referenz verglichen wird.",
          "answerCategory": "correct"
        },
        {
          "text": "Als Wert wird jeweils eine Referenz gespeichert, welche sich unterscheiden kann.",
          "id": "7ba019a2553e1137a4bbb8d3c779a48e5ceb2ca3a162e6e0a945ef0f",
          "correctionOrComment": "Als Wert wird jeweils eine Referenz gespeichert, welche sich unterscheiden kann.",
          "answerCategory": "correct"
        },
        {
          "text": "Ja, wenn sie verschiedene Referenzen haben, die den gleichen (nicht den selben!) Inhalt haben.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Ja, wenn sie verschiedene Referenzen haben, die den gleichen (nicht den selben!) Inhalt haben.",
          "answerCategory": "correct"
        },
        {
          "text": "Es werden die Referenzen, nicht der Inhalt verglichen",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Es werden die Referenzen, nicht der Inhalt verglichen",
          "answerCategory": "correct"
        },
        {
          "text": "Es werden die Referenzen verglichen und nicht die Inhalte des Strings.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Es werden die Referenzen verglichen und nicht die Inhalte des Strings.",
          "answerCategory": "correct"
        },
        {
          "text": "Es werden die Referenzen verglichen, nicht das Inhalt, auf das sie zeigen.",
          "id": "408f0afbe2440a4383a1e75b7d5b0b4202c7f7131a9acf9bd70492f3",
          "correctionOrComment": "Es werden die Referenzen verglichen, nicht das Inhalt, auf das sie zeigen.",
          "answerCategory": "correct"
        },
        {
          "text": "Jedes Mal, wenn ein neuer String angelegt wird, wird eine neue Referenz erstellt.  Der Vergleichsoperator vergleicht im Fall von Strings die Referenzen und nicht den Inhalt.",
          "id": "0ce8152aa92136af039b687c01c7dccfcb271f3db2d0ddcb3cfdd3e6",
          "correctionOrComment": "Jedes Mal, wenn ein neuer String angelegt wird, wird eine neue Referenz erstellt. Der Vergleichsoperator vergleicht im Fall von Strings die Referenzen und nicht den Inhalt.",
          "answerCategory": "correct"
        },
        {
          "text": "Mit dem operator == wird nur die Referenz der Strings überprüft. mit .equals()wird der Inhalt überprüft. (Call by reference!)",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Mit dem operator == wird nur die Referenz der Strings überprüft. mit .equals()wird der Inhalt überprüft. (Call by reference!)",
          "answerCategory": "correct"
        },
        {
          "text": "Bei Strings werden beim Vergleichsoperator `==` nur der Pointer betrachtet.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "correctionOrComment": "Bei Strings werden beim Vergleichsoperator `==` nur der Pointer betrachtet.",
          "answerCategory": "correct"
        },
        {
          "text": "Er erden die Referenzen zweier Strings verglichen, nicht der Inhalt der Strings.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Er erden die Referenzen zweier Strings verglichen, nicht der Inhalt der Strings.",
          "answerCategory": "correct"
        },
        {
          "text": "Verglichen wird die Referenz im Pseicher. Diese sind ungleich bei verschieden angelegten Strings.",
          "id": "58b2aaa0bfae7acc021b3260e941117b529b2e69de878fd7d45c61a9",
          "correctionOrComment": "Verglichen wird die Referenz im Pseicher. Diese sind ungleich bei verschieden angelegten Strings.",
          "answerCategory": "correct"
        },
        {
          "text": "Bei Strings werden die Referenzen verglichen und nicht der Inhalt",
          "id": "6332531eeafc6e0ede272192be898f549950fb32b209d04f0a98306a",
          "correctionOrComment": "Bei Strings werden die Referenzen verglichen und nicht der Inhalt",
          "answerCategory": "correct"
        },
        {
          "text": "Referenz",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Referenz",
          "answerCategory": "partially_correct"
        },
        {
          "text": "wenn man zwei gleiche Strings mit == vergleicht, kann es sein das ungleich herauskommt, da die Referenz auf den Speicherplatz verglichen wird",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "wenn man zwei gleiche Strings mit == vergleicht, kann es sein das ungleich herauskommt, da die Referenz auf den Speicherplatz verglichen wird",
          "answerCategory": "correct"
        },
        {
          "text": "Wenn sich die Referenzen unterscheiden.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Wenn sich die Referenzen unterscheiden.",
          "answerCategory": "binary_correct"
        },
        {
          "text": "Die Referenzen der jeweiligen Strings sind andere.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Die Referenzen der jeweiligen Strings sind andere.",
          "answerCategory": "binary_correct"
        },
        {
          "text": "verschiedene Objektreferenzen",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "verschiedene Objektreferenzen",
          "answerCategory": "binary_correct"
        },
        {
          "text": "Wenn sie verschiedene Speicherreferenzen haben",
          "id": "271f93f45e9b4067327ed5c8cd30a034730aaace4382803c3e1d6c2f",
          "correctionOrComment": "Wenn sie verschiedene Speicherreferenzen haben",
          "answerCategory": "binary_correct"
        },
        {
          "text": "Falls sie eine unterschiedliche Referenz speichern.",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c",
          "correctionOrComment": "Falls sie eine unterschiedliche Referenz speichern.",
          "answerCategory": "binary_correct"
        },
        {
          "text": "Da die Referenz verglichen wird und nicht der eigentliche String.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Da die Referenz verglichen wird und nicht der eigentliche String.",
          "answerCategory": "correct"
        },
        {
          "text": "Der Vergleichsoperator vergleicht bei Objekten wie Strings nicht den eigentlichen Inhalt der Strings, sondern die Referenz, die die beiden Objekte speichern.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6",
          "correctionOrComment": "Der Vergleichsoperator vergleicht bei Objekten wie Strings nicht den eigentlichen Inhalt der Strings, sondern die Referenz, die die beiden Objekte speichern.",
          "answerCategory": "correct"
        },
        {
          "text": "Da Strings die Referenz auf den Inhalt gespeichert werden und diese unterschiedlich sein kann bei gleichem Inhalt.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Da Strings die Referenz auf den Inhalt gespeichert werden und diese unterschiedlich sein kann bei gleichem Inhalt.",
          "answerCategory": "binary_correct"
        },
        {
          "text": "Wie bereits geschrieben: Bei Pointern (= auch strings) wird nur geprüft, ob die Refernzen gleich sind und weniger ob der Inhalt der gleiche ist!",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6",
          "correctionOrComment": "Wie bereits geschrieben: Bei Pointern (= auch strings) wird nur geprüft, ob die Refernzen gleich sind und weniger ob der Inhalt der gleiche ist!",
          "answerCategory": "binary_correct"
        },
        {
          "text": "Der Vergleichsoperator vergleicht nur die Referenzen, nicht den Inhalt",
          "id": "53750c72b7bb26cb6ff7115e383ca150d5a632a909a7f79e2f5274a4",
          "correctionOrComment": "Der Vergleichsoperator vergleicht nur die Referenzen, nicht den Inhalt",
          "answerCategory": "correct"
        },
        {
          "text": "Der Wert eines Strings ist die Referenz im Speicher und die unterscheidet sich bei verschiedenen Strings, auch wenn der inhalt gleich ist.",
          "id": "8416c38cc898f1ac7cc9d64e89dab1f70f5ddab002a5b2a1713f93f5",
          "correctionOrComment": "Der Wert eines Strings ist die Referenz im Speicher und die unterscheidet sich bei verschiedenen Strings, auch wenn der inhalt gleich ist.",
          "answerCategory": "correct"
        },
        {
          "text": "lmlmlm",
          "id": "192f56eb9bd894a72b30c303247b107be2c4591f310dd69a67927f48",
          "correctionOrComment": "lmlmlm",
          "answerCategory": "none"
        },
        {
          "text": "Es werden die Verweise verglichen nicht der Inhalt.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "correctionOrComment": "Es werden die Verweise verglichen nicht der Inhalt.",
          "answerCategory": "correct"
        },
        {
          "text": "Wenn die Strings auf unterschiedliche Speicherplätze verweisen, da einer mit einem New-Operator initialisiert wurde, ist dies der fall.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26",
          "correctionOrComment": "Wenn die Strings auf unterschiedliche Speicherplätze verweisen, da einer mit einem New-Operator initialisiert wurde, ist dies der fall.",
          "answerCategory": "partially_correct"
        },
        {
          "text": "Ja, der Vergleichsoperator vergleicht die Referenzen der Springs, also ob es sich um denselben String handelt und nicht den Inhalt. dafür muss z.B s.equals(t) genutzt werden",
          "id": "b51d18b551043c1f145f22dbde6f8531faeaf68c54ed9dd79ce24d17",
          "correctionOrComment": "Ja, der Vergleichsoperator vergleicht die Referenzen der Springs, also ob es sich um denselben String handelt und nicht den Inhalt. dafür muss z.B s.equals(t) genutzt werden",
          "answerCategory": "correct"
        },
        {
          "text": "Weil damit nur der Wert, nicht aber der Inhalt verglichen wird.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Weil damit nur der Wert, nicht aber der Inhalt verglichen wird.",
          "answerCategory": "correct"
        },
        {
          "text": "Das ist möglich, da Strings beim Anlegen eine Referenz bekommen. Legt man einen leeren String an und gibt diesem erst später einen Wert, so wird die Referenz nicht verändert, auch wenn es bereits eine Referenz mit jenem Inhalt gibt.",
          "id": "f09265efb456b0336079ad5b238daa1e38a11b1d71cc0e1a4e8edd56",
          "correctionOrComment": "Das ist möglich, da Strings beim Anlegen eine Referenz bekommen. Legt man einen leeren String an und gibt diesem erst später einen Wert, so wird die Referenz nicht verändert, auch wenn es bereits eine Referenz mit jenem Inhalt gibt.",
          "answerCategory": "partially_correct"
        },
        {
          "text": "das liegt daran, das diese als Referenz auf zwei verschieden Positionen im Speicher zeigen",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c",
          "correctionOrComment": "das liegt daran, das diese als Referenz auf zwei verschieden Positionen im Speicher zeigen",
          "answerCategory": "binary_correct"
        },
        {
          "text": "Es wird nur die referenz verglichen. Mit equals() wird der inhalt verglichen",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Es wird nur die referenz verglichen. Mit equals() wird der inhalt verglichen",
          "answerCategory": "correct"
        },
        {
          "text": "Es werden die Referenzen, nicht die Werte verglichen.",
          "id": "b8607e0369fbf3e33bc0e358f840915d8c085d1496097351913c0122",
          "correctionOrComment": "Es werden die Referenzen, nicht die Werte verglichen.",
          "answerCategory": "correct"
        },
        {
          "text": "HIer werden die Referenzen verglichen.",
          "id": "ae8820303e493738a211ebb2ae3a2f90b286f20f767609beb77522c0",
          "correctionOrComment": "HIer werden die Referenzen verglichen.",
          "answerCategory": "correct"
        },
        {
          "text": "Der Operator vergleicht die in den Strins abgelegten Referenzen und nicht die Objekte auf die sie verweisen",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Der Operator vergleicht die in den Strins abgelegten Referenzen und nicht die Objekte auf die sie verweisen",
          "answerCategory": "correct"
        },
        {
          "text": "Strings speichern Referanz und nicht Inhalt selbst",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "Strings speichern Referanz und nicht Inhalt selbst",
          "answerCategory": "binary_correct"
        },
        {
          "text": "weil sie unterschiedliche Referenzen haben",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614",
          "correctionOrComment": "weil sie unterschiedliche Referenzen haben",
          "answerCategory": "binary_correct"
        }
      ]
    },
    {
      "text": "Was passiert bei der Wertzuweisung von einer String-Variablen zu einer Anderen?",
      "id": 50720,
      "title": "Wertzuweisung zwischen Strings",
      "type": "procedure",
      "referenceAnswer": {
        "text": "Die Referenz wird kopiert. Anschließend zeigen beide Variablen auf dieselbe Zeichenkette.",
        "aspects": [
          {
            "text": "Die Referenz wird kopiert",
            "elements": [
              [
                0,
                25
              ]
            ]
          },
          {
            "text": "Anschließend zeigen beide Variablen auf dieselbe Zeichenkette",
            "elements": [
              [
                27,
                95
              ]
            ],
            "implied": true
          }
        ]
      },
      "answersAnnotation": [
        {
          "text": "die referenzen werden gleich gesetzt, ändert man nun den wert der einen ndert sich die andere automatisch mit",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Die Referenz, auf die die erste Variable verweist, wird bei der Wertzuweisung von einer String-Variablen zu einer anderen an besagte andere übergeben.",
          "id": "8bbd52208353c14f154f1402cebf5829afb1708d06b5dc25064dff23"
        },
        {
          "text": "Es wird ein neuer String (Objekt) mit dem zugewisenen Inhalt erzeugt.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "In der Variable wird dann die Referenz gespeichert",
          "id": "8a217ea5f39d0f20db42ef9bcb667eacd060a40b50a18655172ec4b8"
        },
        {
          "text": "Die Referenz wird kopiert und der anderen Variable zugewiesen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Die Referenzen werden zugewiesen. Es wird kein neues Objekt erzeugt.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "die andere übernimmt die Referenz und die vorherige wird gelöscht",
          "id": "c1b8144ee1a30244a571c3d9b48b2c394a7489065d2565968f521645"
        },
        {
          "text": "Die Referenz wird übergeben.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Hierbei wird nur die Referenz des String kopiert und so verweist die neue Variable auf denselben String wie die vorherige.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Die beiden zeigen nun auf die gleiche Referenz, Ändert man nun etwas im ursprünglichem String, verändert sich dies auch im neu zugewiesenem",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Sie behalten verschiedene Referenzen aber beide Referenzen zeigen nun auf den gleichen Speicherbereich.",
          "id": "ea674ab55536a8b603be44d13510e32c7aab02088bf48c2802e4febd"
        },
        {
          "text": "Es wird die Referenz auf diesen String gespeichert.",
          "id": "7ba019a2553e1137a4bbb8d3c779a48e5ceb2ca3a162e6e0a945ef0f"
        },
        {
          "text": "Die Referenz wird geändert. Der alte String existiert noch, ist jedoch im Speicher verschollen, da er nicht referenziert wird.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Sie bekommt die gleiche Referenz zugewiesen und verweist somit auf den gleichen String.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Es wird die Referenz des Strings zugewiesen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Die Andere zeigt danach auf die selbe Kette, d.h. auf den selben Speicherplatz, der die Kette enthält.",
          "id": "408f0afbe2440a4383a1e75b7d5b0b4202c7f7131a9acf9bd70492f3"
        },
        {
          "text": "Die Referenz der ersten String-Variablen wird auch die der zweiten.",
          "id": "0ce8152aa92136af039b687c01c7dccfcb271f3db2d0ddcb3cfdd3e6"
        },
        {
          "text": "die Referenz der 1. Variable ist nun die Referenz der 2. variable. beide variablen zeigen auf den Inhalt der 2. variable.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Die Referenz der String-Variablen wird übernommen.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Die Referenz des Speicherortes wird neu zugeordnet.",
          "id": "58b2aaa0bfae7acc021b3260e941117b529b2e69de878fd7d45c61a9"
        },
        {
          "text": "Die eine bekommt die Referenz der anderen übergeben",
          "id": "6332531eeafc6e0ede272192be898f549950fb32b209d04f0a98306a"
        },
        {
          "text": "referenz wird übergeben",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "es wird eine neue Variable angelegt in der die Referenz der ersten String-Variable gespeichert wird",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Es wird die Referenz kopiert, der ursprüngliche String bleibt allerdings erhalten, allerdings ohne Referenz, sodass er im Speicher nicht mehr auffindbar ist.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Die Referenz der einen wird kopiert, sodass beide Variablen auf denselben String verweisen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Eine neue Referenz wird erstellt",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Der Wert auf dem String wird überschrieben, die Referenz bleibt gleich",
          "id": "271f93f45e9b4067327ed5c8cd30a034730aaace4382803c3e1d6c2f"
        },
        {
          "text": "Es wird in dem aufnehmenden String die Referenz des anderen gespeichert.",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "Die Referenz der einen wird in der anderen gespeichert.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Es wird nur die Referenz auf den eigentlichen Inhalt übergeben.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "Die Referenz wird überschrieben.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Danach verweisen beide Strings auf die gleiche Referenz.",
          "id": "f09265efb456b0336079ad5b238daa1e38a11b1d71cc0e1a4e8edd56"
        },
        {
          "text": "Es wird die Refernz des originalen Objeltes geupdated - erst bei einer Änderung wird das interne char-array des strings geklont.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "EIn weiterer Verweis von neuer Variablen auf Objekt, auf das String verweist",
          "id": "53750c72b7bb26cb6ff7115e383ca150d5a632a909a7f79e2f5274a4"
        },
        {
          "text": "Ein neuer Speicherbereich mit dem neuen String wird angelegt und die Referent im Wert des Strings wird entsprechend überschrieben.",
          "id": "8416c38cc898f1ac7cc9d64e89dab1f70f5ddab002a5b2a1713f93f5"
        },
        {
          "text": "okokok",
          "id": "192f56eb9bd894a72b30c303247b107be2c4591f310dd69a67927f48"
        },
        {
          "text": "Es wird lediglich der Verweis geändert.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Die Referenz wird kopiert. Sie verweisen jetzt auf den selben Speicherbereich.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Sie wird gecastet",
          "id": "b51d18b551043c1f145f22dbde6f8531faeaf68c54ed9dd79ce24d17"
        },
        {
          "text": "Die Referenz wird kopiert.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Die Referenzen werden ersetzt.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "es taucht ein Fehler auf.",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "die referenz wird zugewiesen",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Referenz wird kopiert und zeigt anschließend auf das gleiche Objekt.",
          "id": "b8607e0369fbf3e33bc0e358f840915d8c085d1496097351913c0122"
        },
        {
          "text": "Die Referenz wird kopiert und beide verweisen anschließend auf die gleiche Zeichenkette",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Die beiden Referanzen verweisen auf selben Inhalt im Speicher",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "die referenz wird zugewiesen",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        }
      ]
    },
    {
      "text": "Was passiert bei der Anweisung new String()?",
      "id": 50721,
      "title": "Keyword 'new'",
      "type": "procedure",
      "referenceAnswer": {
        "text": "Das Keyword 'new' erzeugt einen leeren String im Speicher und gibt anschließend die Referenz auf diesen String zurück.",
        "aspects": [
          {
            "text": "Das Keyword 'new' erzeugt einen leeren String im Speicher",
            "elements": [
              [
                0,
                57
              ]
            ]
          },
          {
            "text": "und gibt anschließend die Referenz auf diesen String zurück",
            "elements": [
              [
                58,
                117
              ]
            ],
            "implied": true
          }
        ]
      },
      "answersAnnotation": [
        {
          "text": "Es wird eine neue Referenz erstellt",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Mit der Anweisung new String() wird ein neuer Speicherort für einen neuen String angelegt.",
          "id": "8bbd52208353c14f154f1402cebf5829afb1708d06b5dc25064dff23"
        },
        {
          "text": "Ein String wird neu in einer Referenz gespeichert.",
          "id": "4cfc3a1811fe40afa401b25ef7fa0379f1f7c1930a04f8755d678474"
        },
        {
          "text": "Es wird ein neuer String (Objekt) mit dem übergebenen Inhalt erzeugt.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "bei new String() wird ein neuer String erstellt, versehen mit der referenz und einer 0",
          "id": "8a217ea5f39d0f20db42ef9bcb667eacd060a40b50a18655172ec4b8"
        },
        {
          "text": "Es wird ein inhaltsloser String erstellt, also nur eine Referenz für den String. Der Inhalt ist dann null.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Es wird ein neues Objekt erzeugt.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Ein neues Objekt der Klasse String wird angelegt.",
          "id": "1e2c3eb4744dbc36de4e827f187dd2a073d91b8790a2ff117694dd7b"
        },
        {
          "text": "ein neues objekt vom typ string wird instanziert",
          "id": "c1b8144ee1a30244a571c3d9b48b2c394a7489065d2565968f521645"
        },
        {
          "text": "Es wird ein neues Objekt des Typs String erstellt.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Eine neue Referenz für einen String wird erstellt und in dieser kann dann ein String zugewiesen werden.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "ein neuer leerer String wird erstellt und seine Referenz wird zurück gegeben",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Es wird eine Referenz angelegt, die momentan auf nichts zeigt. Also null ist.",
          "id": "ea674ab55536a8b603be44d13510e32c7aab02088bf48c2802e4febd"
        },
        {
          "text": "Es wird ein neues Objekt der Klasse String erstellt. Dieses ist leer.",
          "id": "7ba019a2553e1137a4bbb8d3c779a48e5ceb2ca3a162e6e0a945ef0f"
        },
        {
          "text": "Eine neue Variable für einen String wird angelegt. Sie enthält zunächst die Referenz NUL",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Es wird ein neuer String angelegt",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Es wird ein neuer String erschaffen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Eine neue leere Zeichenkette wird gespeichert und die Variable wird auf sie zeigen,",
          "id": "408f0afbe2440a4383a1e75b7d5b0b4202c7f7131a9acf9bd70492f3"
        },
        {
          "text": "Ein neuer, noch leerer String wird erstellt (und eine neue Referenz).",
          "id": "0ce8152aa92136af039b687c01c7dccfcb271f3db2d0ddcb3cfdd3e6"
        },
        {
          "text": "es wird nicht überprüft ob es schon einen string mit dem gleichen inhalt gibt, sondern ein neuer speicher mit einer neuen Referenz für den String erstellt.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Ein neuer leerer String wird initialisiert.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Ein neues Objekt des Typs String wird erzeugt.",
          "id": "58b2aaa0bfae7acc021b3260e941117b529b2e69de878fd7d45c61a9"
        },
        {
          "text": "Ein neuer leerer String wird angelegt",
          "id": "6332531eeafc6e0ede272192be898f549950fb32b209d04f0a98306a"
        },
        {
          "text": "neuer speicherplatz wird angelegt und konstruktor von der klasse string wird ausgeführt",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "es wird ein neuer String angelegt mit der Referenz null da dem String noch kein Wert zugewiesen wurde",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Ein neues Stringobjekt wird angelegt. Wenn nicht direkt ein bestimmter Inhalt zugewiesen wird, existiert nur die Referenz die auf Null zeigt.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Ein neuer, leerer String wird initalisiert.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Neues Objekt erstellt auf das referenziert wird",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Es wird eine neue String Operation erstellt",
          "id": "271f93f45e9b4067327ed5c8cd30a034730aaace4382803c3e1d6c2f"
        },
        {
          "text": "Es wird ein leerer String erzeugt, dessen Referenz keine von schon vorhandenen Strings ist.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Es wird ein neues Objekt vom Typ String erstellt.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "Es wird im Speicher Platz für einen neuen String erstellt.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Es wird intern ein Pointer auf eine neue Instanz der string-class erstellt. In Java wird einfach ein neues Objekt erzeugt.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "Es wird eine neue leere Zeichenkette erstellt",
          "id": "53750c72b7bb26cb6ff7115e383ca150d5a632a909a7f79e2f5274a4"
        },
        {
          "text": "neuer speicherbereich wird angelegt",
          "id": "8416c38cc898f1ac7cc9d64e89dab1f70f5ddab002a5b2a1713f93f5"
        },
        {
          "text": "jojiji",
          "id": "192f56eb9bd894a72b30c303247b107be2c4591f310dd69a67927f48"
        },
        {
          "text": "Es wird eine neue Referenz erzeugt.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Dem String wird ein (leerer) Speicherbereich zugewiesen\\/ eine Referenz auf diesen Bereich.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Ein neues Objekt der Klasse string wird erstellt",
          "id": "b51d18b551043c1f145f22dbde6f8531faeaf68c54ed9dd79ce24d17"
        },
        {
          "text": "Ein neuer String wird initialisiert.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Ein neuer String mit neuer Referenz wird angelegt.",
          "id": "f09265efb456b0336079ad5b238daa1e38a11b1d71cc0e1a4e8edd56"
        },
        {
          "text": "es wird ein neuer Leerer String erstellt und somit schon mal die Adresse im Speicher reserviert",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "ein neuer String wird erstellt (neue referenz)",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Es wird ein neuer leerer String im Speicher erstellt. Anschließend zeigt die Variable auf diesen Speicherplatz.",
          "id": "b8607e0369fbf3e33bc0e358f840915d8c085d1496097351913c0122"
        },
        {
          "text": "Es wird ein neuer Speicherplatz angelegt, auf den der String verweist, wessen Referenz gespeichert wird.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Ein neuer leerer String wird erstellt und eine Referenz die darauf zeigt wird gespeichert",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Ein neuer String wird angelegt.",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "ein neuer leerer String wird erstellt, die Referanz zeigt auf Inhalt im Speicher",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "eine neue Referenz wird erschaffen",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        }
      ]
    },
    {
      "text": "Was ist ein Array?",
      "id": 50722,
      "title": "Datenstruktur Array",
      "type": "definition",
      "referenceAnswer": {
        "text": "Ein Array ist eine Datenstruktur, die eine Sequenz von Variablen gleichen Typs enthält.",
        "aspects": [
          {
            "text": "Ein Array ist eine Datenstruktur",
            "elements": [
              [
                0,
                32
              ]
            ]
          },
          {
            "text": "die eine Sequenz von Variablen gleichen Typs enthält",
            "elements": [
              [
                34,
                86
              ]
            ]
          }
        ]
      },
      "answersAnnotation": [
        {
          "text": "ein array ist ein Feld in dem Daten gespeichert werden",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Ein Array dient zur Speicherung mehrerer Elemente eines bestimmten Datentyps. Seine Länge ist konstant und wird bei seiner Erstellung festgelegt. Arrays können auch andere Arrays enthalten, dabei spricht man von mehrdimensionalen Arrays.",
          "id": "8bbd52208353c14f154f1402cebf5829afb1708d06b5dc25064dff23"
        },
        {
          "text": "Ein Array ist ein Datentyp, der zur Speicherung und Verwendung mehrerer Werte eines Typs dient.",
          "id": "4cfc3a1811fe40afa401b25ef7fa0379f1f7c1930a04f8755d678474"
        },
        {
          "text": "Ein Feld von Daten des gleichen Typs. Die Elemente folgen unmittelbar aufeinander und können über einen Index adressiert werden.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "In einem array können Werte gespeichert werden er kann auch mehrdemensional sein",
          "id": "8a217ea5f39d0f20db42ef9bcb667eacd060a40b50a18655172ec4b8"
        },
        {
          "text": "Ein Array ist ein Objekt, welches eine Reihe von Elementen beinhalten kann. Bei bestimmten Datentypen-Arrays können nur Elemente dieses Datentyps enthalten sein.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Ein Array kann Daten eines gleichen Typs speichern. Die Länge eines Arrays ist fest. Die Daten können durch einen Index aufgerufen werden.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "k",
          "id": "c1b8144ee1a30244a571c3d9b48b2c394a7489065d2565968f521645"
        },
        {
          "text": "Ist eine Gruppe von Objekten mit denselben Attributen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Ein Array ist ein Objekt indem eine Sequenz von Daten gespeichert werden kann, welche dann mit Zahlenindexen referenziert werden.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Ein Datentyp in welchem eine Art von Daten in einer Reihenfolge gespeichert und durchlaufen werden können. Die größe wird vorher festgelegt.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Es ähnelt vom Aufbau einem String.",
          "id": "ea674ab55536a8b603be44d13510e32c7aab02088bf48c2802e4febd"
        },
        {
          "text": "Ein Array ist ein Datentyp, bei dem mehrer Daten aneinandergereiht werden können.",
          "id": "7ba019a2553e1137a4bbb8d3c779a48e5ceb2ca3a162e6e0a945ef0f"
        },
        {
          "text": "Ein Array ist eine Anreihung von Daten.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "ein array ist eine datenstruktur die sequenz von variablen gleichen typs enthält. einzelne einträge werden durchnummeriert",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "ein Array ist eine KEtte von Zahlen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Eine Datenstruktur, die eine Menge, die unterschiedlich groß und unterschiedlich strukturiert sein kann, vom gleichen Datentyp (Integer, Char...) speichert.",
          "id": "408f0afbe2440a4383a1e75b7d5b0b4202c7f7131a9acf9bd70492f3"
        },
        {
          "text": "Ein Array ist ein Datentyp, der eine Reihe von Werten hintereinander speichern kann.  Man kann seine einzelnen Positionen abfragen, aber nicht mit dem Array an sich z.B. rechnen oder ihn ausgeben.",
          "id": "0ce8152aa92136af039b687c01c7dccfcb271f3db2d0ddcb3cfdd3e6"
        },
        {
          "text": "kann mehrdimensional sein. Speichert einzelne primitive Datentypen in einer Reihenfolge und versieht sie mit Indizes, leichter zugriff. feste größe.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Ein Array ist eine Liste von beliebigen Daten. Auf diese können via deren Index zugegruffen werden.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Datentyp der eine Sequenz von Werten den gleichen Datentyps speichert",
          "id": "8a1c55283fd2fc15f72ad8c88c9dcc447f528814a41bf2a7ab51950a"
        },
        {
          "text": "Ein Array ist eine Datenstruktur, die es ermöglicht iterative auf Datensätze gleichen Types zuzugreifen. Ein Array, kann mehrere Dimensionen besitzen.",
          "id": "58b2aaa0bfae7acc021b3260e941117b529b2e69de878fd7d45c61a9"
        },
        {
          "text": "Eine Datenstruktur zur Speicherung von gleichartigen Werten",
          "id": "6332531eeafc6e0ede272192be898f549950fb32b209d04f0a98306a"
        },
        {
          "text": "ein datentyp",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Array ist ein Datentyp in dem Ziffern oder Zeichen gespeichert und worauf mit Hilfe von Indices zugegriffen werden kann",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Eine Array ist Objekt, in dem eine Sequenz von Variablen gleichen Typs gespeichert werden.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Einen Reihung von gleichen Datentypen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Indizierte liste",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Ein Array ist eine Aneinanderreihung von verschiedenen Werten",
          "id": "271f93f45e9b4067327ed5c8cd30a034730aaace4382803c3e1d6c2f"
        },
        {
          "text": "Ein Objekt, dass viele Werte eines einzigen Datentyps speichert.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "Ein Array ist ein Datentyp der mehrere Daten eines Datentypes abspeichert.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Ein Array ist eine Reihe von Variablen gleichen Typs.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Eine lineare Anordnung an Daten im Speicher. Dies können auch Pointer-Arrays sein (Refernzen).",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "Ein Objekt mit Integer Werten, die unter Index gespeichert werden",
          "id": "53750c72b7bb26cb6ff7115e383ca150d5a632a909a7f79e2f5274a4"
        },
        {
          "text": "Eine Reihe gleicher Datentypen",
          "id": "8416c38cc898f1ac7cc9d64e89dab1f70f5ddab002a5b2a1713f93f5"
        },
        {
          "text": "mkmkmk",
          "id": "192f56eb9bd894a72b30c303247b107be2c4591f310dd69a67927f48"
        },
        {
          "text": "Ein Array ist ein statischer Datentyp. Er wird mit einer bestimmten Länge festgelegt und kann Werte eines bestimmten Datentyps speichern.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Ein Array ist ein Objekt, dass über die Referenz auf einen Speicherbereich, mehrere Werte eines Datentyps in einer Reihenfolge speichert.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Datenstruktur, die eine Sequenz von Variablen gleichen Typs enthält",
          "id": "b51d18b551043c1f145f22dbde6f8531faeaf68c54ed9dd79ce24d17"
        },
        {
          "text": "Ein Array ist eine Datenstruktur, die eine Sequenz von Variablen des gleichen Typs enthält.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Ein Array ist Sammlung von Werten. Jeder Wert hat einen Index, unter dem er im Array gespeichert wird und abgerufen werden kann, ähnlich einer Tabelle.",
          "id": "f09265efb456b0336079ad5b238daa1e38a11b1d71cc0e1a4e8edd56"
        },
        {
          "text": "Speichersequenz von gleichen Datentypen",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Ist eine Anreihung von Werten eines Datentyps ohne für jeden Wert eine neue deklaration zu definieren",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "Datenstruktur",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Ein Array ist eine durchnummerierte Ansammlung von Daten eines Typs.",
          "id": "b8607e0369fbf3e33bc0e358f840915d8c085d1496097351913c0122"
        },
        {
          "text": "Eine Datenstruktur, die eine festbestimmte Größe hat und auf mehrere Objekte durch Referenzen verweisen kann.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "In einem Array können mehrere Werte des gleichen Typs gespeichert werden.",
          "id": "0aebf04a018e3de3078a2580a53f660b420bea77865d71caed9f8690"
        },
        {
          "text": "Im übertragenen Sinn ein Vektor (bei mehrdimensionalen Arrays eine Matrix). Man kann auf jede Position des Array zugreifen.",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "Matrix, die Reihe von Werten des gleichen Datentyps speichert",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "index zeichenkette",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        }
      ]
    },
    {
      "text": "Wodurch wird gewährleistet, dass in einem Array auf einzelne Element zugegriffen werden kann? Wie erfolgt der Zugriff?",
      "id": 50723,
      "title": "Array Zugriff",
      "simple": true,
      "type": "definition",
      "referenceAnswer": {
        "text": "Die einzelnen Einträge sind durchnummeriert. Man kann durch die Angabe ihres Indices auf sie zugreifen.",
        "aspects": [
          {
            "text": "Die einzelnen Einträge sind durchnummeriert",
            "elements": [
              [
                0,
                43
              ]
            ]
          },
          {
            "text": "Man kann durch die Angabe ihres Indices auf sie zugreifen",
            "elements": [
              [
                45,
                102
              ]
            ]
          }
        ]
      },
      "answersAnnotation": [
        {
          "text": "die elemente werden mit leerzeichen oder kommata getrennt eingegeben. der zugriff erfolgt über die position, als die länge des arrays",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Es wird ein Name für das Array angegeben und in eckigen Klammern der Index dazu aufgezeigt.",
          "id": "4cfc3a1811fe40afa401b25ef7fa0379f1f7c1930a04f8755d678474"
        },
        {
          "text": "Die Stellen in einem Array, an welcher Stelle welche Zahl o.ä. steht wird von 0 durchnummeriert und durch den Namen des arrays eckige klammern kann auf bestimmte Zahlen zugegriffen werden",
          "id": "8a217ea5f39d0f20db42ef9bcb667eacd060a40b50a18655172ec4b8"
        },
        {
          "text": "Jedem Element wird eine Position (Index) zugewiesen, beginnend mit der 0. Der Zugriff erfolgt dann über den Namen des Arrays und [i], wobei i für den Index steht.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Der Zugriff erfolgt über einen Index.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Über die Indizes.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Durch Indices die den einzelnen Werten im Array zugewiesen werden.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Jede Position in der eine Variable gespeichert wird, wird mit einem indice versehen.   Array a[]; a[2] = 5 zB",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Die Speicherplätze im Array sind ab 0 durchnummeriert. So kann mann in den Array klammern die Stelle auf die man zugreifen will angeben.",
          "id": "ea674ab55536a8b603be44d13510e32c7aab02088bf48c2802e4febd"
        },
        {
          "text": "Der Array ist indiziert, somit hat jeder Wert einen zugehörigen Index. Auf diesen kann durch array[index] zugegriffen werden.",
          "id": "7ba019a2553e1137a4bbb8d3c779a48e5ceb2ca3a162e6e0a945ef0f"
        },
        {
          "text": "d",
          "id": "c1b8144ee1a30244a571c3d9b48b2c394a7489065d2565968f521645"
        },
        {
          "text": "Die Elemente sind mit Indicees versehen. Der Zugriff erfolgt durch array[x][y].",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Duch Indices.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Der Zugriff erfolgt durch Positionen im Array.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Die einzelnen Teilnehmer werder nummeriert. Dann kann man mit array[nummer] auf einen Element zugreifen.",
          "id": "408f0afbe2440a4383a1e75b7d5b0b4202c7f7131a9acf9bd70492f3"
        },
        {
          "text": "Der Zugriff erfolgt mit einer for-Schleife, die bis zur Länge des Arrays hochzählt und jede Position ausgeben kann.",
          "id": "0ce8152aa92136af039b687c01c7dccfcb271f3db2d0ddcb3cfdd3e6"
        },
        {
          "text": "die Elemente des arrays sind durchnummeriert, dh jedes element hat einen index.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Auf einzelne Elemente wird via deren Index zugegriffen. Bsp: array[5] verweist auf das sechste Element.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Die Elemente sind eindeutig durch ihren Index gekennzeichnet. Der Zugriff erfolgt iterativ.",
          "id": "58b2aaa0bfae7acc021b3260e941117b529b2e69de878fd7d45c61a9"
        },
        {
          "text": "Jedes einzelne Element hat ein Index i, Zugriff durch array[i]",
          "id": "6332531eeafc6e0ede272192be898f549950fb32b209d04f0a98306a"
        },
        {
          "text": "privtate",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "jedem Element eine Arrays wird ein Index zugewiesen, das erste Element bekommt den Index 0, das zweite 1, usw. bis n-1. Mithilfe dieser Indices kann dann auf einzelne Elemente zugegriffen werden, dafür wird in eckigen Klammern hinter den Namen des Arrays der Index des gewünschten Elements geschrieben",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Die einzelnen Variablen im Array sind durchnummerriert. Man kann auf sie mit Hilfe ihrer Indices zugreifen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Jedes Feld eines Arrays erhält einen Index. Darüber kann auf die einzelnen Werte im Array zugegriffen werden.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Der Inhalt indiziierugen",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Über den Aufruf mit [], die Stelle, an der der aufzurufende Wert zu finden ist steht in den Klammern",
          "id": "271f93f45e9b4067327ed5c8cd30a034730aaace4382803c3e1d6c2f"
        },
        {
          "text": "Die einzelnen Elemente sind mit einem Index gekennzeichnet. Über diesen Index kann auf das Element zugegriffen werden.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "In einem Array werden alle Daten unter einem Indize gespeichret. Zugriff: >ArrayName<[>Indiz<]",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Es wird dadurch gewährleistet, dass jeder Eintrag einen Index hat. Der Zugriff erfolgt durch die Operation nameDesArray[Index].",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Man kann via dem []-Operator auf einzelne Elemnte zugreifen. Das Offset des gesuchten Eintrages lässt sich dabei mit n*[Datentypelänge] berechnen. Java prüft zusätzlich ob n >= der Länge ist und wirft dann eine NULL-Pointer-Exception. Man beginnt bei 0 zu zählen.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "Array besitzt Index, somit kann auf das Element im Araay an einer bestimmten Stelle zugegriffen werden.",
          "id": "53750c72b7bb26cb6ff7115e383ca150d5a632a909a7f79e2f5274a4"
        },
        {
          "text": "Jedes Element bekommt einen Index von 0 bis Länge - 1, dieser ist einduetig",
          "id": "8416c38cc898f1ac7cc9d64e89dab1f70f5ddab002a5b2a1713f93f5"
        },
        {
          "text": "njnjnjn",
          "id": "192f56eb9bd894a72b30c303247b107be2c4591f310dd69a67927f48"
        },
        {
          "text": "Der Zugriff erfolgt in den eckigen Klammern.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Im Array wird eine Indizierte Sequenz gespeichert, auf deren Felder über die Indizes zugegriffen werden kann.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Durch die Indexe der verschiedenen Zellen kann auf die Variablen in diesen Zugegriffen werden. Zugriff auf Element mit dem Index i. feld[i]",
          "id": "b51d18b551043c1f145f22dbde6f8531faeaf68c54ed9dd79ce24d17"
        },
        {
          "text": "Die Länge des Arrays muss bei der Erzeugung angegeben werden. Somit hat jeder Wert einen Index, auf den mit der Anweisung array[index] zugegriffen werden kann.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Der Zugriff erfolgt über Indizes, die die Elemente durchnummerieren. Diese beginnen bei 0 bis n, wobei n die Anzahl der Elemente -1.",
          "id": "f09265efb456b0336079ad5b238daa1e38a11b1d71cc0e1a4e8edd56"
        },
        {
          "text": "ein Array muss eine Feste größe haben und der Zugriff erfolgt per [] Klammern",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "jeder Wert hat eine Referenz",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Alle Elemente eines Arrays sind durchnummeriert. Durch die Indices kann auf sie zugegriffen werden.",
          "id": "b8607e0369fbf3e33bc0e358f840915d8c085d1496097351913c0122"
        },
        {
          "text": "Der Zugriff erfolgt erneut über Referenzen. Die Elemente in einem Array werden je mit einem bestimmten Index verbunden, durch welche sie aufgerufen werden können.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Die Elemente sind durchnummeriert, über die Indices kann auf sie zugegriffen werden",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "durchnummeriert, Indices",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "durch indices",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        }
      ]
    },
    {
      "text": "Wie ist ein Rechenschritt definiert?",
      "id": 50725,
      "title": "Definition Rechenschritt",
      "type": "definition",
      "referenceAnswer": {
        "text": "Ein einzelner Rechenschritt hat einen Zeitaufwand von konstanter Größe.",
        "aspects": [
          {
            "text": "Ein einzelner Rechenschritt hat einen Zeitaufwand von konstanter Größe",
            "elements": [
              [
                0,
                70
              ]
            ]
          }
        ]
      },
      "answersAnnotation": [
        {
          "text": "Die Rechnung wird in Abhängigkeit der Eingabegröße ausgeführt.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Ein Abschnitt beim Rechnen",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Er hat eine konstante Größe",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Ein Rechenschritt ist ein Vergleich oder eine Veränderung einer Variablen.",
          "id": "7ba019a2553e1137a4bbb8d3c779a48e5ceb2ca3a162e6e0a945ef0f"
        },
        {
          "text": "ein elementarer vorgang(z.b. rechnungen",
          "id": "c1b8144ee1a30244a571c3d9b48b2c394a7489065d2565968f521645"
        },
        {
          "text": "Ein Rechenschritt beinhaltet eine Handlung.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Ein Rechenschritt ist definiert als eine Operation die der Compiler ausführen muss.",
          "id": "0ce8152aa92136af039b687c01c7dccfcb271f3db2d0ddcb3cfdd3e6"
        },
        {
          "text": "Ein Rechenschritt ist eine klar abgegrenzte Operation.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Ein Rechenschritt ist zum Beispiel eine Addition, also eine Operation, die in einer konstanten Zeicht durchgeführt werden kann.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "ein Rechenschritt ist der Vorgang bei dem einer Variable ein neuer Wert zugewiesen wird durch Verrechnung zweier anderer Variablen oder Werte",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "...",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Er braucht konstante Zeit.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Eine oder meherere nacheinander durchzuführende Operationen, die von dem Zustand des System äbhängig werden und den Zustand ändern können.",
          "id": "408f0afbe2440a4383a1e75b7d5b0b4202c7f7131a9acf9bd70492f3"
        },
        {
          "text": "eine Operation deren Laufzeit bekannt ist",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Eine Anweisung.",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "Zum Beispiel ein Durchgang bei einer Schleife",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "Als eine konstante Zeiteinheit (IF muss zwei Werte lesen, vergleichen und zurückgeben - mehr Einsicht bietet hier Assembler).",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "Als grundlegene Operation, wie z.B. einfache Rechenzeichen, Operationsaufrufe, etc.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "O(1)",
          "id": "53750c72b7bb26cb6ff7115e383ca150d5a632a909a7f79e2f5274a4"
        },
        {
          "text": "Ein Rechenschritt ist die einmalige Ausführung eines Programmteils mit konstanter und beschränkter Laufzeit.",
          "id": "8416c38cc898f1ac7cc9d64e89dab1f70f5ddab002a5b2a1713f93f5"
        },
        {
          "text": "okok",
          "id": "192f56eb9bd894a72b30c303247b107be2c4591f310dd69a67927f48"
        },
        {
          "text": "Ein Rechenschritt ist eine Anweisung im Programm.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Ein Rechenschritt entspricht einer Elementaroperation, die in endlicher Zeit ausgeführt wird.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Ein Rechenschritt benötigt eine konstante zeit.      Anweisungen\\/Rechenschritte werden in einer begrenzten Anzahl an Operationen durchgeführt. Eine Anweisung, Zeile im Programm?",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Eine Ausführung auf einem Element. z.B. ein Vergleich, eine Addition...",
          "id": "f09265efb456b0336079ad5b238daa1e38a11b1d71cc0e1a4e8edd56"
        },
        {
          "text": "ist das ausführen einer Operation",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "x",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Ein Rechenschritt braucht immer eine konstante Zeit unabhängig von der Eingabe.",
          "id": "b8607e0369fbf3e33bc0e358f840915d8c085d1496097351913c0122"
        },
        {
          "text": "eine Aufgabe",
          "id": "ae8820303e493738a211ebb2ae3a2f90b286f20f767609beb77522c0"
        },
        {
          "text": "Ein Rechenschritt benötigt eine konstante Zeit",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        }
      ]
    },
    {
      "text": "Warum ist die Laufzeit für das Sortieren von Strings im Gegensatz zu Integern nicht allein von der Anzahl der zu sortierenden Elemente abhängig?",
      "id": 50726,
      "title": "Komplexität Sortieren von Strings",
      "type": "reason",
      "referenceAnswer": {
        "text": "Weil die Länge eines Strings theoretisch nicht beschränkt ist. Die Laufzeit für den Vergleich von zwei Strings ist daher nicht konstant wie bei Integern.",
        "aspects": [
          {
            "text": "Weil die Länge eines Strings theoretisch nicht beschränkt ist",
            "elements": [
              [
                0,
                61
              ]
            ]
          },
          {
            "text": "Die Laufzeit für den Vergleich von zwei Strings ist daher nicht konstant wie bei Integern",
            "elements": [
              [
                63,
                152
              ]
            ]
          }
        ]
      },
      "answersAnnotation": [
        {
          "text": "strings selber können nochmal unterschiedlich groß sein und damit unterschiedlich viele Rechenschritte brauchen",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Weil Strings einen größeren Speicherbedarf haben.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Da Strings mit Referenzen arbeiten.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Es ist auch von der länge der Strings abhängig",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Wegen Typecasts.",
          "id": "7ba019a2553e1137a4bbb8d3c779a48e5ceb2ca3a162e6e0a945ef0f"
        },
        {
          "text": "we",
          "id": "c1b8144ee1a30244a571c3d9b48b2c394a7489065d2565968f521645"
        },
        {
          "text": "Ist der String ungünstig sortiert, müssen mehr Tauschaktionen durchgeführt werden, als wenn er zb schon sortiert ist.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Weil es auch von den Referenzen der Strings abhängt.",
          "id": "0ce8152aa92136af039b687c01c7dccfcb271f3db2d0ddcb3cfdd3e6"
        },
        {
          "text": "Strings können in ihrer Länge variieren, was bei der Sortierung beachtet werden muss. Integer haben eine feste Größe.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Weil Strings aufwändiger sortiert werden müssen, da sie nicht so einfach zu vergleichen sind.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Weil Strings Referenzen besitzen. Das heißt zusätzlicher Speicher wird benötigt. Das Sortieren geschieht nicht insitu.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Weil die Strings eine theoretisch unedliche Länge haben können, während die größe von Integer begrenzt ist.",
          "id": "408f0afbe2440a4383a1e75b7d5b0b4202c7f7131a9acf9bd70492f3"
        },
        {
          "text": "Weil es auch auf die Länge der einzelnen Strings ankommt",
          "id": "271f93f45e9b4067327ed5c8cd30a034730aaace4382803c3e1d6c2f"
        },
        {
          "text": "Es hängt auch noch von der Länge der Strings ab. Außerdem muss ja die Referenz verglichen werden.",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "Die einzelnen Zeichen eines Strings müssen erst in Integer umgewandelt werden, bevor sie sortiert werden können.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "Weil Strings wiederrum verschiedene Längen haben - diese sind wiederrum nichts anderes als Arrays mit chars und einer eigenen Länge.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "Weil jeder einzelne String aus mehreren chars besteht und Integer keine solche Eigenschaft haben.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Weil die größe der zu sortierenden Strings variabel ist",
          "id": "53750c72b7bb26cb6ff7115e383ca150d5a632a909a7f79e2f5274a4"
        },
        {
          "text": "In einem Integer muss nur der Wert des Ints vergleichen werden, bei einem String muss der ganze String durchlaufen und jedes Zeichen verglichen werden.",
          "id": "8416c38cc898f1ac7cc9d64e89dab1f70f5ddab002a5b2a1713f93f5"
        },
        {
          "text": "njnjni",
          "id": "192f56eb9bd894a72b30c303247b107be2c4591f310dd69a67927f48"
        },
        {
          "text": "Bei Strings werden immer die Objekte angesprochen und deswegen ist dies nicht allein von den sortierten Elementen abhängig.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Strings repräsentieren Zeichenkette, haben also auch eine variable Eingabegröße in sich.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Ein String hat keine obere schranke für seine länge, die als konstante genommen werden kann (vereinfacht nach oben abgeschätzt), auch von der länge der strings abhängig",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Weil in Strings der Inhalt der Referenzen verglichen werden muss.",
          "id": "f09265efb456b0336079ad5b238daa1e38a11b1d71cc0e1a4e8edd56"
        },
        {
          "text": "x",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Anders als Integer können Strings eine unendliche Länge haben.",
          "id": "b8607e0369fbf3e33bc0e358f840915d8c085d1496097351913c0122"
        },
        {
          "text": "Es werden unterschiedlichviele Vergleiche benötigt",
          "id": "ae8820303e493738a211ebb2ae3a2f90b286f20f767609beb77522c0"
        },
        {
          "text": "Da für das Sortieren auch die einzelnen Symbole der Sstrings relevant sind, ist die Laufzeit ebenso davon abhängig, wieviele Zeichen die Strings ausmachen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Da die Länge eines Strings nicht festgelegt ist, anders als die eines Ints,",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Strings sind nicht wirklich nach oben beschränkt, es kommt also auf Inhalt an",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        }
      ]
    },
    {
      "text": "Was bedeutet eine Laufzeitangabe von O(1)?",
      "id": 50728,
      "title": "O(1)",
      "simple": true,
      "type": "definition",
      "referenceAnswer": {
        "text": "Die Rechenzeit ist unabhängig von der Eingabe. Der Algorithmus benötigt eine beschränkte Anzahl an Schritten.",
        "aspects": [
          {
            "text": "Die Rechenzeit ist unabhängig von der Eingabe",
            "elements": [
              [
                0,
                45
              ]
            ],
            "implied": true
          },
          {
            "text": "Der Algorithmus benötigt eine beschränkte Anzahl an Schritten",
            "elements": [
              [
                47,
                108
              ]
            ]
          }
        ]
      },
      "answersAnnotation": [
        {
          "text": "Das eine konstante Zeit zur Durchführung benötigt wird, unabhängig von der Eingabe",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Eine Operation benötigt einen Schritt, um zum Ergebnis zu gelangen.",
          "id": "4cfc3a1811fe40afa401b25ef7fa0379f1f7c1930a04f8755d678474"
        },
        {
          "text": "Die Laufzeit des Algorithmus ist von konstanter Zeit (relativ schnell).",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Die Dauer des Algorithmus beträgt eine konstante Zeit. (wird einmal aufgerufen)",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Das die obere Schranke der Laufzeit konstant ist",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Dass es eine konstante obere Schranke für die Laufzeit gibt.",
          "id": "7ba019a2553e1137a4bbb8d3c779a48e5ceb2ca3a162e6e0a945ef0f"
        },
        {
          "text": "Eine konstante Laufzeit.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "konstante Laufzeit",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Die Laufzeit ist kontant.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "operation wird in konstanter Zeit ausgeführt",
          "id": "c1b8144ee1a30244a571c3d9b48b2c394a7489065d2565968f521645"
        },
        {
          "text": "Dass der Schritt konstante Zeit braucht.",
          "id": "0ce8152aa92136af039b687c01c7dccfcb271f3db2d0ddcb3cfdd3e6"
        },
        {
          "text": "Die Laufzeitangabe von O(1) bedeutet das der Algorithmus unabhängig von der Eingabegröße eine konstante Zeit benötigt.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Dass das Programm eine konstante Laufzeit braucht.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "O(1) bedeutet das die Laufzeit des Algorithmus konstant ist, das heißt egal wie groß die Eingabe ist, es braucht max. O(1) Zeit den Algorithmus auszuführen",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Eine Laufzeit von konstanter Größe.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Die Zeit ist durch eine Konstante beschränkt.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Konstante Laufzeit, unabhängig von der Eingabegröße.",
          "id": "408f0afbe2440a4383a1e75b7d5b0b4202c7f7131a9acf9bd70492f3"
        },
        {
          "text": "Konstant",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Dass exakt ein Durchlauf nötig ist, ergo die Laufzeit unabhängig der Eingabe konstant ist",
          "id": "271f93f45e9b4067327ed5c8cd30a034730aaace4382803c3e1d6c2f"
        },
        {
          "text": "Die obere Schranke für den Algorithmus dauert konstante Zeit 1. Die Laufzeit des Algorithmus nähert sich asymptotisch der 1.",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "Die Laufzeit ist konstant",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "das bedeutetet konstante Zeit.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Konstante Laufzeit. Unabhängig von Eingabemengen oder deren Wert.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "Dass die Laufzeit konstant ist.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "eine konstante Laufzeit",
          "id": "53750c72b7bb26cb6ff7115e383ca150d5a632a909a7f79e2f5274a4"
        },
        {
          "text": "Konstante Leufzeit",
          "id": "8416c38cc898f1ac7cc9d64e89dab1f70f5ddab002a5b2a1713f93f5"
        },
        {
          "text": "nknkn",
          "id": "192f56eb9bd894a72b30c303247b107be2c4591f310dd69a67927f48"
        },
        {
          "text": "Es ist ein einzelner Rechenschritt im Programm oder es durchläuft eine Anweisung in konstanter Zeit.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Der Rechenschritt benötigt nur eine konstante Zeit und ist unabhängig von der Eingabegröße in konstanter Zeit zu erreichen.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "die Laufzeit ist konstant und nicht von der Eingabegröße n abhängig",
          "id": "b51d18b551043c1f145f22dbde6f8531faeaf68c54ed9dd79ce24d17"
        },
        {
          "text": "Der Algorithmus benötigt einen Durchlauf. Die Laufzeit verändert sich bei verdoppelter Eingabegröße nicht (wesentlich).",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "unabhängig von der eingabe größe braucht der Algorithmus eine konstante maximale zeit   Der Algorithmus braucht im schlechtesten fall eine konstante zeit (nicht abhängig von eingabegröße?)",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Die Laufzeit ist konstat, die Wachstumsrate eine Gerade.",
          "id": "f09265efb456b0336079ad5b238daa1e38a11b1d71cc0e1a4e8edd56"
        },
        {
          "text": "Konstante Zeit und abhängig von den eingegebenen Daten",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "Das es egal bei welcher eingabe eine konstante laufzeit benötigt",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Konstante Laufzeit.",
          "id": "b8607e0369fbf3e33bc0e358f840915d8c085d1496097351913c0122"
        },
        {
          "text": "Das Programm besitzt eine konstante Laufzeit, unabhängig der Eingabelänge.",
          "id": "ae8820303e493738a211ebb2ae3a2f90b286f20f767609beb77522c0"
        },
        {
          "text": "Ünabhängig von der Eingabegröße wird eine konstante Zeit benötigt",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        }
      ]
    },
    {
      "text": "Was ist der Vorteil einer Angabe in Rechenschritten gegenüber einer Angabe in Sekunden oder der Zahl der Maschinenbefehle?",
      "id": 50729,
      "title": "Rechenschritte vs Sekunden",
      "type": "reason",
      "referenceAnswer": {
        "text": "Die Angabe in Rechenschritten ist unabhängig von der jeweiligen Umsetzung und der Hardware eines Computers.",
        "aspects": [
          {
            "text": "Die Angabe in Rechenschritten ist unabhängig von der jeweiligen Umsetzung",
            "elements": [
              [
                0,
                73
              ]
            ]
          },
          {
            "text": "Die Angabe in Rechenschritten ist unabhängig von ;; der Hardware eines Computer",
            "elements": [
              [
                0,
                48
              ],
              [
                78,
                106
              ]
            ]
          }
        ]
      },
      "answersAnnotation": [
        {
          "text": "Sie ist unabhängig von Betriebssystem, Prozessor, Hintergrundprogrammen usw.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Der Algorithmus kann für verschiedene Datentypen mehr oder weniger Sekunden benötigen und Maschinenbefehle besitzen unterschiedliche Zeiten für die Ausführung.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Da die Anzahl an Rechenschritten unabhängig von anderen beeinflussenden Faktoren ist. Und bestimmt die Laufzeit so genauer.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Letzteres ist abhängig von der Maschiene auf der sie ausgeführt wird, Rechenschritte allgemeiner und man kann mit ihnen systemunabhängig Vergleiche machen",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Die genannten Alternativen wären von der Hardware abhängig.",
          "id": "7ba019a2553e1137a4bbb8d3c779a48e5ceb2ca3a162e6e0a945ef0f"
        },
        {
          "text": "Eine Angabe in Rechenschritten ist unabhängig von der Hardware und von dem, was auf dem Computer im Hintergrund geschieht. Außerdem ist sie unabhängig von der Programmiersprache.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Zahl der Maschinenbefehle ist nicht aussagekräftig, da zeitaufwand nicht von der menge der befehle abhängt. sekunden wäre zu zeitaufwendig und teilweise unmöglich, da manche algorithmen unendlich viel zeit laufen",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "dadurch muss man keine rücksicht auf die rechenleistung des rechners nehmen,",
          "id": "c1b8144ee1a30244a571c3d9b48b2c394a7489065d2565968f521645"
        },
        {
          "text": "Dass man so die Zeit abhängig von Eingaben messen kann.",
          "id": "0ce8152aa92136af039b687c01c7dccfcb271f3db2d0ddcb3cfdd3e6"
        },
        {
          "text": "Die Geschwindigkeit und Anzahl der Maschienenbefehle können variieren.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Es ist leichter vergleichbar. Wenn man die Laufzeit in Sekunden angäbe, wäre dies zu ungenau, da ein und dasselbe Programm auf verschiedenen Computer unterschiedlich lange dauert kann.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Unabhängig von Computer, äußeren Bedingungen,...",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Ist von der Platform und von dem Zustand des Rechners und Systems unabhängig.",
          "id": "408f0afbe2440a4383a1e75b7d5b0b4202c7f7131a9acf9bd70492f3"
        },
        {
          "text": "Unterschiedliche vergleiche, umweltbedingungen haben einflüsse",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Es macht die Programme vergleichbarer. Bei zeitlichen Messungen könnte es zu Abweichungen je nach Compiler, Laufwerk etc. kommen, wäre also ungenauer",
          "id": "271f93f45e9b4067327ed5c8cd30a034730aaace4382803c3e1d6c2f"
        },
        {
          "text": "Weil ein Algorithmus auf unterschiedlichen Systemen eine unterschiedliche absolute Zeit benötigt.",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "Je nachdem wie schnell der Computer ist, braucht er zum Ausführen mehr oder weniger Zeit als andere Computer, obwohl es derselbe Code ist.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "Unabhängig von weiteren Faktoren, wie zB Betriebssystem.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Nun diese variieren nicht, so treten bei Sekundenangaben oder Maschinenbefehlen gerätespezifische Fluktuationen auf.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "Das macht die Angabe besser vergleichbar, da sie dann unabhängig von der tatsächlich verwendeten Maschine macht.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "unabhängig von System etc.",
          "id": "53750c72b7bb26cb6ff7115e383ca150d5a632a909a7f79e2f5274a4"
        },
        {
          "text": "die Angabe in Rechenschritten ist unabhängig von der Programmiersprache oder den Rechenkapazitäten des Computers",
          "id": "8416c38cc898f1ac7cc9d64e89dab1f70f5ddab002a5b2a1713f93f5"
        },
        {
          "text": "klmlkmlml",
          "id": "192f56eb9bd894a72b30c303247b107be2c4591f310dd69a67927f48"
        },
        {
          "text": "Vorteile sind, dass es unabhängig von Prozessor, Hardware und Betriebssystem gemessen wird. Das ganze macht das Programm vergleichbarer.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Diese Angabe ist Hard-\\/Software unabhängig. Äußere Umstände werden also nicht miteinbezogen.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "So weiß man für jede Eingabegröße n, wie sich diese auf die Laufzeit auswirkt. Wenn man die Laufzeit in Sekunden angibt, hat man keinen Maßstab um welchen Faktor sich die Laufzeit in Abhängigkeit einer anderen Eingabegröße verändert",
          "id": "b51d18b551043c1f145f22dbde6f8531faeaf68c54ed9dd79ce24d17"
        },
        {
          "text": "Die Zeit variiert je nach Gerät usw.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Die Sekunden sind abhängig von anderen (nicht so wichtigen und schwierig abzuschätzenden Faktoren wie hardware und Betriebssystem). Maschinenbefehle sind abhängig von Programmiersprache..",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Die tatsächlich benötigte Zeit ist abhängig von anderen Faktoren z.B. der Hardware. Das heißt das selbe Programm kann auf verschiedenen Computern unterschiedliche Laufzeiten haben. Um das zu vermeiden gibt man die Laufzeit nur auf das Programm bezogen an: In Rechenschritten.",
          "id": "f09265efb456b0336079ad5b238daa1e38a11b1d71cc0e1a4e8edd56"
        },
        {
          "text": "Diese Angabe ist Maschinenunabhängig und muss so nicht an jede Architektur angepasst werden",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "Rechenschritte hängen nicht von externen faktoren ab",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Unabhängig von Programmiersprache oder Hardwarebedingungen.",
          "id": "b8607e0369fbf3e33bc0e358f840915d8c085d1496097351913c0122"
        },
        {
          "text": "Unterschiedliche Computer, mit unterschiedlichen Rechensystemen brauchen unterschiedlich lange",
          "id": "ae8820303e493738a211ebb2ae3a2f90b286f20f767609beb77522c0"
        },
        {
          "text": "Die Angabe entspricht einer generellen Angabe",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Unabhängigkeit von Hardware, Software usw",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "gleich, unabhängig von Programmiersprache und Hardware",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        }
      ]
    },
    {
      "text": "Beschreibe das Vorgehen bei der lineare Suche.",
      "id": 50730,
      "title": "Lineare Suche",
      "type": "procedure",
      "referenceAnswer": {
        "text": "Jedes Element der zu durchsuchenden Menge wird der Reihe nach mit dem gesuchten Element verglichen.",
        "aspects": [
          {
            "text": "Jedes Element der zu durchsuchenden Menge wird der Reihe nach mit dem gesuchten Element verglichen",
            "elements": [
              [
                0,
                98
              ]
            ]
          }
        ]
      },
      "answersAnnotation": [
        {
          "text": "alle elemente werden nacheinander geprüft bis das gesuchte element gefunden ist oder keine elemente mehr übrig sind",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Es wird ein Array durchlaufen, wobei array[i] (Wert des Elements an Position i) mit dem gesuchten Element verglichen wird.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Jedes Element des Arrays wird nach einander mit dem gesuchten Element verglichen. Bis dieses gefunden wurde oder das Array bis zum Ende durchlaufen wurde.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Wir haben ein Array, welches von einem Stepper durchlaufen wird und jedes Element mit dem Gesuchten vergleicht, wenn  das Element im Array dem Gesuchten entspricht, wird wird der index als int gespeichert und ausgegeben",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Die Werte werden der Reihe nach durchlaufen, solgane bis der gesuchte Wert gefunden wurde.",
          "id": "7ba019a2553e1137a4bbb8d3c779a48e5ceb2ca3a162e6e0a945ef0f"
        },
        {
          "text": "Bei der linearen Suche wird ein Array mit Daten von vorne bis hinten durchgegangen und mit dem gesuchten Element verglichen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Man geht gegebene Werte durch und vergeicht sie mit dem gesuchten wert.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Man prüft für jede Zahl, ob diese Zahl die gesuchte ist.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "man vergleicht immer nacheinander die zahlen eines arrays mit dem gesuchten",
          "id": "c1b8144ee1a30244a571c3d9b48b2c394a7489065d2565968f521645"
        },
        {
          "text": "Bei der linearen Suche wird ein Array von vorne bis hinten durchgegangen um nach einer Zahl zu suchen.",
          "id": "0ce8152aa92136af039b687c01c7dccfcb271f3db2d0ddcb3cfdd3e6"
        },
        {
          "text": "Man geht die gegebene Liste Schritt für Schritt durch und überprüft ob man das gesuchte Element gefunden hat.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Das Array, oder die Zahlenkette wird Schritt für Schritt von links nach rechts durchlaufen und jede Zahl wird mit der gesuchten Zahl verglichen. Man kann den Prozess abbrechen, sobald die Zahl gefunden wurde.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "bei der linearen Suche wird nach einem bestimmten Element gesucht. Dafür wird das Array einmal komplett durchgegangen und jedes Element darauf gecheckt ob es das gesuchte Element ist",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Es wird ein Array von vorne bis hinten durchgelaufen und bei jedem Wert kontrolliert, ob es dem gesuchten Wert entspricht.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "wir laufen den datensatz von vorne bis hinten ab und vergleichen das gesuchte element mit dem aktuellen (wenn wir das gesuchte haben brechen wir evtl ab, wenn wir es bis zum ende nicht gefunden haben, ist es nicht im datensatz und wir brechen trotzdem ab)",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Ein Element wird in einem Array gesucht. Dabei wird vorne angefangen und immer das nächste Element betrachtet .",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Die Kette wird vom Anfang bis Ende durchgesucht und jedes Element nach dem anderen mit dem gesuchten verglichen.",
          "id": "408f0afbe2440a4383a1e75b7d5b0b4202c7f7131a9acf9bd70492f3"
        },
        {
          "text": "durchgehen von Anfang bis ende",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Man untersucht jedes Element in der Reihe und vergleicht es mit dem gesuchten",
          "id": "271f93f45e9b4067327ed5c8cd30a034730aaace4382803c3e1d6c2f"
        },
        {
          "text": "das zu durchsuchende (sortierte) Array wird in der Mitte geteilt. In jedem Schritt wird entschieden, ob die gesuchte Zahl (wenn die in dem Array enthalten ist) in der rechten oder linken Seite sein muss. So wird das zu durchsuchende Teilstück des Arrays immer halbiert.",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "Die Elemente werden nacheinander durchgegangen, bis das aktuelle Element mit dem Gesuchten übereinstimmt.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "Das Array wird einfach durchgelaufen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Vom ersten bis zum letzten Element durchgehen und prüfen, ob das aktuelle Element das Gesuchte ist. Ab Ende wird NULL zurückgegeben, wenn es nicht gefunden werden konnte....",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "Man braucht einen gesuchten Wert und ein Array in dem gesucht werden soll. Jetzt wird bei jedem Index des Arrays geprüft ob es dem gesuchten Wert entspricht. Falls ein Eintrag dem gesuchten Wert entspricht kann true und der Index zurück gegeben werden. Falls alle Einträge durchlaufen werden und der Wert nicht gefunden wird ist er nicht im Array enthalten.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Man vergleicht nacheinander jedes Element mit dem gesuchten, durch Abbruchbedingung bei Finden, lässt sich Laufzeit verkürzen",
          "id": "53750c72b7bb26cb6ff7115e383ca150d5a632a909a7f79e2f5274a4"
        },
        {
          "text": "Ein Datensatz wird Eintrag für eintrag mit dem zu suchenden Element verglichen. wenn das Element gefunden wurde,",
          "id": "8416c38cc898f1ac7cc9d64e89dab1f70f5ddab002a5b2a1713f93f5"
        },
        {
          "text": "b",
          "id": "192f56eb9bd894a72b30c303247b107be2c4591f310dd69a67927f48"
        },
        {
          "text": "Es wird jedes Element einzeln durchsucht, also linear. Die O-Notation ist hier O(n).",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Bei der linearen Suche wird ein Array systematisch Durchlaufen.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Ich habe ein Element Gesucht. Ich Durchlaufe meinen Datensatz systematisch und vergleiche jedes Element mit meinen Element gesucht.",
          "id": "b51d18b551043c1f145f22dbde6f8531faeaf68c54ed9dd79ce24d17"
        },
        {
          "text": "Die lineare Suche wird in deinem unsortierten Datensatz durchgeführt. Der Datensatz wird systematisch durchladen und dabei jedes Element mit dem gesuchten Element verglichen. Es gibt eine Abbruchbedingung.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Bei der linearen Suche wird ein Array der Reihe nach durchgegangen und jedes Element nacheinander mit dem gesuchten verglichen. Die Suche endet, wenn das gesuchte Element gefunden wurde.",
          "id": "f09265efb456b0336079ad5b238daa1e38a11b1d71cc0e1a4e8edd56"
        },
        {
          "text": "Bei der linearen Suche werden alle Elemente mit dem zu suchenden Element verglichen",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "Es wird einmal komplett durch die Liste von vorne nach hinten gelaufen & jedes Element wird verglichen",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Jedes Element wird der Reihe nach mit dem gesuchten Element verglichen.",
          "id": "b8607e0369fbf3e33bc0e358f840915d8c085d1496097351913c0122"
        },
        {
          "text": "Man geht die Eingabe, der Reihe nach ab und schaut ob das Objekt, das gesuchte ist",
          "id": "ae8820303e493738a211ebb2ae3a2f90b286f20f767609beb77522c0"
        },
        {
          "text": "Das größte Objekt wird herausgesucht und nach hinten getauscht, wiederhole für n-1",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        }
      ]
    },
    {
      "text": "Beschreibe das Vorgehen bei der binären Suche.",
      "id": 50731,
      "title": "Binäre Suche",
      "type": "procedure",
      "referenceAnswer": {
        "text": "Es wird immer nur das mittlere Element der Menge mit dem gesuchten Element verglichen. Das Ergebnis des Vergleichs bestimmt die neue noch zu durchsuchende Menge.",
        "aspects": [
          {
            "text": "Es wird immer nur das mittlere Element der Menge mit dem gesuchten Element verglichen",
            "elements": [
              [
                0,
                85
              ]
            ]
          },
          {
            "text": "Das Ergebnis des Vergleichs bestimmt die neue noch zu durchsuchende Menge",
            "elements": [
              [
                87,
                160
              ]
            ]
          }
        ]
      },
      "answersAnnotation": [
        {
          "text": "die elemente müssen vorsortiert sein, es wird immer das mittlere element verglichen und dann in der entsprechenden hälfte weitergesucht",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Da das Array bei der binären Suche sortiert ist, wird dieses in zwei Hälften aufgeteilt und das Array so verkleinert, bis der gesuchte Wert gefunden ist. Hierbei kann natürlich auch der Anfang, das Ende oder die Mitte der gesuchte Wert sein.",
          "id": "4cfc3a1811fe40afa401b25ef7fa0379f1f7c1930a04f8755d678474"
        },
        {
          "text": "Anders als bei der linearen Suche, wird hier das Intervall halbiert, sodass die Chance besteht das gesuchte Element schneller zu finden.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Ein vergleich Element wird ungefähr in der Mitte des Arrays bestimmt. Anschließend wird das gesuchte Element mit diesem verglichen und geguckt ob die Elemente gleich sind. Oder das gesuchte Element kleiner oder größer ist. Ist der gesuchte Wert größer wird Start auf vergleich + 1 gesetzt. Ist der gesuchte Wert kleiner wird Ende auf vergeleich - 1 gesetzt. Dies wird so lange wiederholt bis das gesuchte Element gefunden wurde oder Start > Ende.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Bei der Binären Suche betrachten wir drei Punkte im Array, Ende, Start und den Vergleichswert. Entspricht der vergleichswert dem gesuchten wird sein index ausgegeben. ist der vergleichswert größer wird er zum neuen Ende, wenn kleicher zum neuen start. so halbieren wir pro Runde die länge der zu durchlaufenden elemente",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Es wird immer der mittlere Wert zwischen Start und Ende mit dem gesuchten Wert verglichen. Ist dieser größer, wird der Vergleichswert zum neuen Startwert, sonst zum Endwert.",
          "id": "7ba019a2553e1137a4bbb8d3c779a48e5ceb2ca3a162e6e0a945ef0f"
        },
        {
          "text": "Bei der binären Suche liegt ein vorsortiertes Array vor. Man arbeitet mit einem Index Start und einem Index Ende. Das Element in der Mitte wird betrachtet. Ist es kleiner als gesucht, wird Ende auf den aktuellen Index gesetzt, ist es größer als gesucht, wird Start auf den aktuellen Index gesetzt.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Es wird ein start, ein ende und ein vergleichselement festgelegt. anschließend wird das gesuchte element mit dem vergleichselement verglichen. ist es das gesuchte element bricht die suche ab und die lösung wird ausgegeben. ist der verglichene wert größer als der gesuchte, wird ende = vergleich-1 gesetzt. ist der verglichene wert kleiner als der gesuchte wird start = x+1 gesetzt.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Das sortierte Array wird in zwei Teile aufgeteilt. Bei der Mitte wird geguckt, ob das gesuchte Element größer, kleiner oder gleich die Mitte ist. JE nach Antwort wird dann in diesem Teil des Arrays weiter gesucht.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "das gesuchte gibt an, ob man in der hinteren oder vorderen hälfte des arrays sucht und so immer weiter",
          "id": "c1b8144ee1a30244a571c3d9b48b2c394a7489065d2565968f521645"
        },
        {
          "text": "Bei der binären Suche wird der Array mittels der Indizes immer halbiert und das gesuchte Element mit dem Mittelwert verglichen. Ist es größer, sucht man nur in der zweiten Hälfte weiter, ist es kleiner, nur in der ersten.",
          "id": "0ce8152aa92136af039b687c01c7dccfcb271f3db2d0ddcb3cfdd3e6"
        },
        {
          "text": "Bei der binären Suche halbiert man den Bereich den man durchsucht jeden Schritt. Bei jedem Schritt wird überprüft, ob das aktuelle Element das gesuchte Element ist. Wenn nicht, schaut man ob es kleiner ist als das gesuchte Element. Falls es kleiner ist, setzt man den Suchbereich auf die obere Hälfte des Suchbereich, sonst auf die untere Hälfte.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Die Menge an Zahlen muss sortiert sein, dann wird das mittlere Element betrachtet und mit der gesuchten Zahl verglichen. Wenn die Zahl gleich der gesuchten Zahl ist, ist das Programm fertig. Wenn die gesuchte Zahl größer ist, werden anschließend nur noch die Elemente rechts von der Mitte betrachtet, wenn die gesuchte Zahl kleiner ist nur noch die linke Hälfte. Dann wird das Verfahren für diese Teilarrays wiederholt.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "bei der binären Suche wird das Array zunächst halbiert und das Element in der Mitte mit dem gesuchten verglichen. Ist das gesuchte Element größer als das Element Mitte wird im nächsten Schritt nur die zweite Hälfte des Arrays angeguckt, ist das gesuchte Element kleiner als das Element Mitte wird nur die vordere Hälfte des Arrays auf das gesuchte Element untersucht.  Dann wird das Teilarray wieder halbiert, die Mitte mit dem gesuchten Element verglichen und der Vorgang immer weiter wiederholt.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Bei der binären Suche ist es wichtig, dass die zu durchsuchende Menge vorsortiert ist. Diese wird in zwei Teile geteilt : Start bis Mitte und Mitte+1 bis Ende. Es wird nach und nach verglichen, ob der gesuchte Wert größer oder kleiner als die Mitte ist. Solange er kleiner ist, wird Ende auf Mitte gesetzt, wenn er größer ist wird Start auf Mitte gesetzt. Wenn er gleich dem Wert der Mitte ist, ist der Wert gefunden.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "In einem Sortierten Datensatz grenzen wir nach und nach den Bereich ein in dem das gesuchte element liegen kann. Ein vergleichselement auf der hälfte des infrage kommenden Bereichs wird mit dem dem gesuchten element verglichen. wenn das gesuchte element größer als das vergleichselement ist, liegt es zwischen vergleich und ende, sonst zwischen start und ende!",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Es wird in der Mitte begonnen und immer geschaut, ob das gesuchte Element kleiner oder größer ist. Solange bis ende < start oder gesucht gefunden wurde.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Die aufsteigend vorsortierte durchsuchende Menge wird halbiert, das Element in der Mitte wird mit dem gesuchten Wert verglichen, wenn entspricht, dann sind wir fertig, wenn nicht und das gesuchte Element größer ist, suchen wir in der oberen Häfte, sonst in der unteren. Usw. bis wir finden oder nicht finden (die duchsuchende Hälfte ist leer).",
          "id": "408f0afbe2440a4383a1e75b7d5b0b4202c7f7131a9acf9bd70492f3"
        },
        {
          "text": "immer wieder halbieren des suchbereiches und links und recht davon wird geschaut",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Es wird zunächst sortiert und anschließend in Abschnitte geteilt, bei denen verglichen wird, ob das gesuchte Element größer oder kleiner als das Vergleichselement ist. Je nachdem geht der Algorithmus links (wenn kleiner) oder rechts (wenn größer) weiter oder beendet, wenn das gesuchte Element gefunden wurde",
          "id": "271f93f45e9b4067327ed5c8cd30a034730aaace4382803c3e1d6c2f"
        },
        {
          "text": "das zu durchsuchende (sortierte) Array wird in der Mitte geteilt. In jedem Schritt wird entschieden, ob die gesuchte Zahl (wenn die in dem Array enthalten ist) in der rechten oder linken Seite sein muss. So wird das zu durchsuchende Teilstück des Arrays immer halbiert.",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "Die binäre Suche funktioniert nur bei einer sortierten Menge an Elementen. Bei jedem Durchgang wird ein Vergleichselement aus der Mitte herausgepickt und mit dem gesuchten Element verglichen.  Es werden drei Fälle unterschieden:  Stimmt das Vergleichselement mit dem gesuchten überein, wird die Schleife beendet. Ist das gesuchte Element kleiner als das Vergleichselement, wird nun der bisherige Vorgang im Bereich links neben dem Vergleichselement durchgeführt. Ist das gesuchte Element größer als das Vergleichselement, wird der bisherige Vorgang im Bereich rechts neben dem Vergleichselement durchgeführt.  Die letzten beiden Fälle werden so oft durchgeführt, bis das gesuchte Element mit dem Vergleichselement übereinstimmt.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "Ein vorsortierter Array. Mittleres Element wird mit gesuchten Element verglichen. Ist das gesuchte Element größer, wird das Mittlerem Element zu Ende",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Man teilt die Menge der zu durchsuchenden Menge an Daten in einen Teil, der größer und einen der kleiner als das geuchte Element ist ein. Dann entscheidet man sich in welchen der beiden Teile weitergesucht wird - so lange bis man es gefunden hat, oder man keine zu durchsuchenden Element mehr hat. Dafür muss eben diese Menge bereits vorsortiert sein oder irgendwie gewichtbar sein.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "Man schaut sich den mittleren Wert einer sortierten (Teil-)Menge an und prüft, ob das der gesuchte Wert ist. Falls ja hat man ihn gefunden. Falls nicht, dann wiederholt man den Schritt in der Teilmenge mit den kleineren Einträgen, falls der gesuchte Wert kleiner als der geprüfte Wert ist und sonst in der Teilmenge mit den größeren Einträgen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Das Array wird vorsortiert. Das gesuchte Element wird mit dem Mittleren Element verglichen, Suchbereich wird verändert, je nachdem ob gesuchtes Element größer oder kleiner ist als Mitte",
          "id": "53750c72b7bb26cb6ff7115e383ca150d5a632a909a7f79e2f5274a4"
        },
        {
          "text": "Das zu suchende Element wird mit dem mittleren Element des sortierten Datensatzes verglichen. Ist es größer, wird das mittlere Element zur linken, ist es kleiner zur rechten Grenze des neuen zu durchsuchenden Intervalls.",
          "id": "8416c38cc898f1ac7cc9d64e89dab1f70f5ddab002a5b2a1713f93f5"
        },
        {
          "text": "h",
          "id": "192f56eb9bd894a72b30c303247b107be2c4591f310dd69a67927f48"
        },
        {
          "text": "Bei der Binären Suche wird nicht linear vorgegangen, sondern das Array immer geschickt aufgeteilt, sodass die Laufzeit gegenüber der linearen Suche verbessert werden kann.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Die binäre Suche läuft auf einem sortierten Array. Hier wird ein Vergleichswert mit dem gesuchten ELement verglichen. Je nach Resultat, kann das Element als gefunden angesehen, bzw. der Suchbereich verkürzt (meist halbiert) werden. Nach einer Endlichen Zahl von Halbierungen(Ologn) und Vergleichen wird klar, ob das Element enthalten ist, oder nicht.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Ich habe ein Element Gesucht. Ich habe Start und Ende des Datensatzes.  Ich halbiere den Datensatz. Ich erhalte das Element Vergleich. Ich Vergleiche Vergleich mit Gesucht, ist das Element gefunden gebe ich es zurück. Je nachdem ob Gesucht größer oder kleiner Vergleich ist, suche ich in der obere oder unteren hälfte des Datensatzes weiter.  Die wiederhole ich, bis gesucht gefunden ist, oder Start > Ende.",
          "id": "b51d18b551043c1f145f22dbde6f8531faeaf68c54ed9dd79ce24d17"
        },
        {
          "text": "Die binäre Suche wird in einem sortierten Datensatz durchgeführt. Es wird geprüft, ob das gesuchte Element gefunden wurde. Dazu wird zuerst das mittlere Element des Intervalls mit dem gesuchten Element verglichen. Wenn es nicht das gesuchte Element ist, wird geprüft, ob das gesuchte Element kleiner oder größer als das mittlere Element ist. Ist es kleiner, wird ende=vergleich gesetzt, ist es größer wird start=vergleich gesetzt. Es wird also jeweils in der entsprechenden Hälfte des Intervalls weitergesucht und dort erneut anhand des mittleren Wertes verglichen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Die binäre Suche sucht in einem sortierten Array. Sie beginnt in der Mitte (start+ende\\/2) und prüft, ob das aktuelle Element gleich, größer oder kleiner als das gesuchte ist. Entsprechend werden start oder ende neu gesetzte und die Suche nur in der entsprechenden Hälfte weiterdurchgeführt.",
          "id": "f09265efb456b0336079ad5b238daa1e38a11b1d71cc0e1a4e8edd56"
        },
        {
          "text": "bei der binären Suche wird der Suchbereich in einem geordneten Array in zwei bereiche aufgeteilt und je nachdem ob der Wert kleiner ist als der mittlere Wert des sortierten Arrays dann links oder rechts von dem Vergleichsindex weiter gesucht. Dann werden die Start und End indizies angepasst und das selbe nochmal durchgeführt.",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "Es wird immer in die hälfte geteilt & dann geguckt ob es größer oder kleiner ist & dann wieder das gleiche",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Es wird jeweils nur das mittlere Element mit dem gesuchten Element verglichen. Je nachdem ob es größer oder kleiner ist, bildet es die neue vordere oder hintere Intervallsgrenze.",
          "id": "b8607e0369fbf3e33bc0e358f840915d8c085d1496097351913c0122"
        },
        {
          "text": "Immer das mittlere Elemente wird mit dem gesuchten Element verglichen, entsprechend des Verhältnisses des gesuchten zur Mitte wird danach nur eine der Hälften betrachtet",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        }
      ]
    },
    {
      "text": "Welches Kriterium muss eine Menge von Elementen erfüllen, damit die binäre Suche angewandt werden kann?",
      "id": 50732,
      "title": "Kriterium für binäre Suche",
      "simple": true,
      "type": "description",
      "referenceAnswer": {
        "text": "Die Menge muss sortiert sein.",
        "aspects": [
          {
            "text": "Die Menge muss sortiert sein",
            "elements": [
              [
                0,
                38
              ]
            ]
          }
        ]
      },
      "answersAnnotation": [
        {
          "text": "Die Elemente müssen der größe nach sortiert sein",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Das Array muss bereits sortiert sein.",
          "id": "4cfc3a1811fe40afa401b25ef7fa0379f1f7c1930a04f8755d678474"
        },
        {
          "text": "Die Menge muss sortiert sein.",
          "id": "756c8bb0587e8f047fc555ff8a6379ac8af40d1e3ebcb178dcbe87d5"
        },
        {
          "text": "Es muss eine endliche Menge sein.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Die Elemente müssen auf- oder absteigend sortiert sein.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "sie muss sortiert sein",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Die Elemente müssen der Größe nach sortiert sein.",
          "id": "7ba019a2553e1137a4bbb8d3c779a48e5ceb2ca3a162e6e0a945ef0f"
        },
        {
          "text": "Es muss sortiert sein.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Sortiert",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Es muss sortiert sein.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "muss sortiert sein",
          "id": "c1b8144ee1a30244a571c3d9b48b2c394a7489065d2565968f521645"
        },
        {
          "text": "Sie müssen schon vorsortiert sein.",
          "id": "0ce8152aa92136af039b687c01c7dccfcb271f3db2d0ddcb3cfdd3e6"
        },
        {
          "text": "Die Menge von Elementen muss sortiert sein.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Die Menge von Elementen muss sortiert sein.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Die Menge muss vorsortiert sein.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "sortierter datensatz",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Es muss vorsortiert sein.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Sie muss vorsortiert sein.",
          "id": "408f0afbe2440a4383a1e75b7d5b0b4202c7f7131a9acf9bd70492f3"
        },
        {
          "text": "mindestens 3 elemente",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Der Größe nach sortiert",
          "id": "271f93f45e9b4067327ed5c8cd30a034730aaace4382803c3e1d6c2f"
        },
        {
          "text": "Sie muss sortiert vorliegen.",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "Sie muss vorher sortiert worden sein.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "vorsortiert, element enthalten",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "SORTIERT SEIN.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "Sie muss sortiert sein.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Sie muss vorsortiert sein",
          "id": "53750c72b7bb26cb6ff7115e383ca150d5a632a909a7f79e2f5274a4"
        },
        {
          "text": "Die Menge muss sortiert sein.",
          "id": "8416c38cc898f1ac7cc9d64e89dab1f70f5ddab002a5b2a1713f93f5"
        },
        {
          "text": "k",
          "id": "192f56eb9bd894a72b30c303247b107be2c4591f310dd69a67927f48"
        },
        {
          "text": "Es muss mindestens zwei Elemente geben.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Die MEnge der Element muss sortiert sein.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Die Menge von Elementen muss vorsortiert sein.",
          "id": "b51d18b551043c1f145f22dbde6f8531faeaf68c54ed9dd79ce24d17"
        },
        {
          "text": "Der Datensatz muss sortiert sein.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Sie muss sortiert sein.",
          "id": "f09265efb456b0336079ad5b238daa1e38a11b1d71cc0e1a4e8edd56"
        },
        {
          "text": "die Menge an Elementen muss sortiert sein",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "Sie müssen sortiert sein",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Die Menge muss sortiert sein.",
          "id": "b8607e0369fbf3e33bc0e358f840915d8c085d1496097351913c0122"
        },
        {
          "text": "Sie muss vorsortiert sein.",
          "id": "ae8820303e493738a211ebb2ae3a2f90b286f20f767609beb77522c0"
        },
        {
          "text": "Die Menge muss sortiert sein",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        }
      ]
    },
    {
      "text": "Warum ist die binäre Suche der linearen vorzuziehen?",
      "id": 50733,
      "title": "Vorteil der binären Suche",
      "simple": true,
      "type": "reason",
      "referenceAnswer": {
        "text": "Die binäre Suche hat eine deutlich geringere Laufzeit.",
        "aspects": [
          {
            "text": "Die binäre Suche hat eine deutlich geringere Laufzeit",
            "elements": [
              [
                0,
                53
              ]
            ]
          }
        ]
      },
      "answersAnnotation": [
        {
          "text": "Sie benötigt weniger Rechenschritt und hat folglich eine kürzere Laufzeit",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Da die Laufzeit bei der binären Suche geringer ist.",
          "id": "4cfc3a1811fe40afa401b25ef7fa0379f1f7c1930a04f8755d678474"
        },
        {
          "text": "Die binäre Suche hat eine deutlich geringere Laufzeit.",
          "id": "756c8bb0587e8f047fc555ff8a6379ac8af40d1e3ebcb178dcbe87d5"
        },
        {
          "text": "Weil sie nur die Hälfte der Laufzeit braucht.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Da sie weniger Zeit benötigt.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Ihre Laufzeit ist kürzer. Linear O(n^2), Binär O(logn)",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Weil sie eine geringe asymptotische Laufzeit hat.",
          "id": "7ba019a2553e1137a4bbb8d3c779a48e5ceb2ca3a162e6e0a945ef0f"
        },
        {
          "text": "Es müssen nicht alle Elemente geprüft werden, sondern es kann immer eine Hälfte des übrigen Arrays ausgeschlossen werden.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "bessere laufzeit",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Es gibt dadurch eine kürzere Laufzeit.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "kürzere Laufzeit",
          "id": "c1b8144ee1a30244a571c3d9b48b2c394a7489065d2565968f521645"
        },
        {
          "text": "Weil sie eine kleinere Laufzeit hat, nämlich nur O(nlog(n)).",
          "id": "0ce8152aa92136af039b687c01c7dccfcb271f3db2d0ddcb3cfdd3e6"
        },
        {
          "text": "Die binäre Suche benötigt weniger Vergleiche als die lineare Suche.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Da sie durchschnittlich eine kürzere Laufzeit hat.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "da das Array immer halbiert wird, müssen nicht alle Elemente verglichen werden weshalb die Laufzeit der binären Suche deutlich kürzer ist als die der linearen Suche.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Da sie eine kürzere Average-Case Laufzeit hat, als die lineare Suche (O(log(n)) statt O(n)).",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "worst case Laufzeit o(log(n)), besser als O(n) bei linearer suche. allerdings bleibt da die zeit die für das Sortieren benötigt wurde nicht berücksichtigt. Lohnt sich also nur bei häufiger suche.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Sie benötigt weniger Zeit.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Weil ihr Worst-Case-Laufzeit kleiner ist. Und zwar O(log n), anstatt O(n)",
          "id": "408f0afbe2440a4383a1e75b7d5b0b4202c7f7131a9acf9bd70492f3"
        },
        {
          "text": "Schneller im worst case",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Geht schneller, da in Abschnitten gearbeitet werden kann und nicht jedes Element einzeln abgearbeitet werden muss",
          "id": "271f93f45e9b4067327ed5c8cd30a034730aaace4382803c3e1d6c2f"
        },
        {
          "text": "Die Anzahl der Vergleiche ist deutlich geringer.",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "Da sie im Durchschnitt deutlich weniger Vergleiche benötigt",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "weniger vergleiche, bessere Laufzeit",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Sie hat eine geringere Laufzeit von gerade mal O(log(n)) und nicht O(n).",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "Weil die Laufzeit \\/ Zeitkomplexität besser ist.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Kürzere Average Case Laufzeit, da unter bestimmten Bedingungen nicht gesamtes Array durchsucht werden muss, nur wenn gesuchte Zahl nicht enthalten ist",
          "id": "53750c72b7bb26cb6ff7115e383ca150d5a632a909a7f79e2f5274a4"
        },
        {
          "text": "Die binäre Suche hat eine Leufzeit von lon(n), die lineare Suche von n",
          "id": "8416c38cc898f1ac7cc9d64e89dab1f70f5ddab002a5b2a1713f93f5"
        },
        {
          "text": "lklk",
          "id": "192f56eb9bd894a72b30c303247b107be2c4591f310dd69a67927f48"
        },
        {
          "text": "Die binäre Suche hat eine kürzere Laufzeit.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Die lineare Suche hat in den meisten Fällen eine geringere Laufzeit.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Die Laufzeit der linearen Suche beträgt O(n), die Laufzeit der binären Suche beträgt O(log(n)). Die binäre Suche ist schneller.",
          "id": "b51d18b551043c1f145f22dbde6f8531faeaf68c54ed9dd79ce24d17"
        },
        {
          "text": "Weil die Laufzeit in der Regel kürzer ist.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Die binäre Suche vergleicht nicht alle Elemente, sondern halbiert die zu durchsuchende Menge mit jedem Schritt.",
          "id": "f09265efb456b0336079ad5b238daa1e38a11b1d71cc0e1a4e8edd56"
        },
        {
          "text": "Weil die Anzahl der Vergleich dadurch sinkt.",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "Weil sie schneller ist!",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Sie hat eine deutlich kürzere Laufzeit.",
          "id": "b8607e0369fbf3e33bc0e358f840915d8c085d1496097351913c0122"
        },
        {
          "text": "Schneller",
          "id": "ae8820303e493738a211ebb2ae3a2f90b286f20f767609beb77522c0"
        },
        {
          "text": "Deutlich geringere Laufzeit.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        }
      ]
    },
    {
      "text": "Was ist eine Operation?",
      "id": 50807,
      "title": "Definition Operation",
      "type": "definition",
      "referenceAnswer": {
        "text": "Eine Operation ist eine gruppierung von Anweisungen zu einem Ausführungskontext.",
        "aspects": [
          {
            "text": "Eine Operation ist eine gruppierung von Anweisungen zu einem Ausführungskontext",
            "elements": [
              [
                0,
                89
              ]
            ]
          }
        ]
      },
      "answersAnnotation": [
        {
          "text": "eine Operation\\/Methode ist ein Teilprogramm das aufgerufen werden kann",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Eine Operation stellt eine Funktionalität zur Verfügung, die von außen aufrufbar ist.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Eine Operation kann auf Objekten ausgeführt werden. SIe können das Verhalten von Objekten beeinflussen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Eine Operation tut etwas, wenn sie aufgerufen wird. Dabei können Daten übergeben und zurückgegeben werden.",
          "id": "7ba019a2553e1137a4bbb8d3c779a48e5ceb2ca3a162e6e0a945ef0f"
        },
        {
          "text": "Eine Operation ist eine Menge von Anweisungen mit einem bestimmten Ziel.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Methode, die einen Handlungsablauf beschreibt",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "d",
          "id": "c1b8144ee1a30244a571c3d9b48b2c394a7489065d2565968f521645"
        },
        {
          "text": "Eine Operation besteht aus einem Rückgabetyp, einem Namen und Parametern.",
          "id": "0ce8152aa92136af039b687c01c7dccfcb271f3db2d0ddcb3cfdd3e6"
        },
        {
          "text": "Eine Operation ist eine einzelne Anweisung.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "eine Operation oder auch Methode ist eine Ansammlung von Anweisungen, die auf einem Objekt ausgeführt werden können",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Eine Operation beschreibt, was man mit Objekten machen kann (addieren, subtrahieren, vergleichen etc.).",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Ein Block von Anweisungen in einem Kontext.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Ein Unterprogramm, das definierte Eingaben und Ausgabe hat und programmierte Befehle ausführt.",
          "id": "408f0afbe2440a4383a1e75b7d5b0b4202c7f7131a9acf9bd70492f3"
        },
        {
          "text": "Eine Operation ist ein abgeschlossener Programmabschnitt",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Eine Operation ist ein ausgelagerter Teil vom Quellcode, auf den durch andere Operationen zugegriffen werden kann (teilweise auch aus anderen Klassen).",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "Eine Liste an Kommandos, welche in einer best. Reihnfolge ausgeführt werden. Ist ebenfalls eine Methode.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "methode ausf[hrbar sammlung von anweisungen",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "Eine Operation ist eine Sammlung an Anweisungen, die zusammengefasst wurden.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Eine Operation ist ein aufrufbarer Programmteil außerhalb der Main",
          "id": "8416c38cc898f1ac7cc9d64e89dab1f70f5ddab002a5b2a1713f93f5"
        },
        {
          "text": "methoden einer Klasse, die an den Attributen der Klasse (static) oder des jeweilig zu bearbeitenden Objekts ausgeführt wird",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "j",
          "id": "192f56eb9bd894a72b30c303247b107be2c4591f310dd69a67927f48"
        },
        {
          "text": "Eine Operation sind mehrere Anweisung in einer Methode zusammengefasst. Die Operation\\/ Methode kann später in der Main-Methode genutzt werden.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Eine Operation ist ein Codeabschnitt, der von außen augerufen werden kann und bestimmte Rechenschritte durchführt. Die Operationen beschreiben das Verhalten einer Klasse.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Eine Operation beschreibt was ein Objekt kann",
          "id": "b51d18b551043c1f145f22dbde6f8531faeaf68c54ed9dd79ce24d17"
        },
        {
          "text": "Eine Operation ist ein Programmblock, der einen bestimmte Aufgabe durchführt.",
          "id": "f09265efb456b0336079ad5b238daa1e38a11b1d71cc0e1a4e8edd56"
        },
        {
          "text": "Eine operation erledigt eine oder mehrer Teilaufgaben.",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "Eine Methode.",
          "id": "ae8820303e493738a211ebb2ae3a2f90b286f20f767609beb77522c0"
        },
        {
          "text": "Eine gebündelte Sammlung von Anweisungen.",
          "id": "b8607e0369fbf3e33bc0e358f840915d8c085d1496097351913c0122"
        },
        {
          "text": "eine Funktion oder eine Methode innerhalb einer KLasse",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "Operation ist eine zusammenfassung von Anweisungen",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        }
      ]
    },
    {
      "text": "Wozu dienen Operationen?",
      "id": 50808,
      "title": "Funktion von Operationen",
      "type": "description",
      "referenceAnswer": {
        "text": "Operationen können wiederverwendet werden und ersparen somit Code. Sie strukturieren den Code außerdem in semantisch zusammenhängende Teilabschnitte.",
        "aspects": [
          {
            "text": "Operationen können wiederverwendet werden und ersparen somit Code",
            "elements": [
              [
                0,
                65
              ]
            ]
          },
          {
            "text": "Operationen können wiederverwendet werden und ersparen somit Code",
            "elements": [
              [
                67,
                148
              ]
            ]
          }
        ]
      },
      "answersAnnotation": [
        {
          "text": "Das Hauptprogramm bleibt übersichtlich, da viele schritte outgesourct werden",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Operationen können von außen aufgerufen werden, um in einer Klasse verschiedene Werte auf dieser Operation ausführen zu können.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Strukturierung, Vermeidung von duplicate code, Übersichtlichkeit",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Sie machen den Code überischlicher und sorgen für weniger Fehler.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Sie verändern Variablen.",
          "id": "7ba019a2553e1137a4bbb8d3c779a48e5ceb2ca3a162e6e0a945ef0f"
        },
        {
          "text": "Operationen dienen der Übersichtlichkeit eines Programms und sie machen das Programm kürzer, da von verschiedenen Stellen des Programmablaufs auf sie zugegriffen werden kann.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "bessere unterteilung der programmabschnitte",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "s",
          "id": "c1b8144ee1a30244a571c3d9b48b2c394a7489065d2565968f521645"
        },
        {
          "text": "Operationen sind dafür da, Programme auszuführen und auch mit Parametern, die aus anderen Operationen übergeben wurden weitere Operationen ausführen zu können.",
          "id": "0ce8152aa92136af039b687c01c7dccfcb271f3db2d0ddcb3cfdd3e6"
        },
        {
          "text": "Operationen dienen zur Strukturierung von Programmen.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Operationen dienen dazu Programme in logische Abschnitte zu unterteilen und somit für Übersichtlichkeit und einfacherere Auseinandersetzung mit dem Prozess zu sorgen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Sie dienen zur Veränderung von Objekten.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Zur Einfachheit eines Quelltextes",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Zu Änderungen des Systems.",
          "id": "408f0afbe2440a4383a1e75b7d5b0b4202c7f7131a9acf9bd70492f3"
        },
        {
          "text": "Um den Code kürzer und übersichtlicher zu gestalten",
          "id": "271f93f45e9b4067327ed5c8cd30a034730aaace4382803c3e1d6c2f"
        },
        {
          "text": "Anweisungen werden ausgeführt und ein Rückgabewert ausgegeben",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Sie machen Quellcode übersichtlicher, zum Beispiel wenn derselbe Code mehrmals im Programm benötigt wird.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "Anweisungen zu bündeln. Übersichtlicher. Möglichkeit deren Sichtbarkeit einzustellen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Zum erledigen von Aufgaben in z.B. einem Programm.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "Wenn eine Operation ein Teilproblem korret löst kann die Operation einfach aufgerufen statt sich mehrere Male mit dem Teilproblem zu beschäftigen. Dadurch werden Problem durch Divide and Conquer leichter zu lösen und auch Quelltext wird übersichtlicher.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Dem bearbeiten von Werten",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "njn",
          "id": "192f56eb9bd894a72b30c303247b107be2c4591f310dd69a67927f48"
        },
        {
          "text": "Vermeidung von doppelten Code. Es kann in Gruppen gearbeitet werden. Jeder kümmert sich um eine bestimmte Operation.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Operationen dienen zur Kapselung von Programmabschnitte zu verschiedenen Ausführungskontexten. Es kann Speicherplatz gespart werden.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Die Operationen legen den Bauplan für ein Objekt fest und somit was dieses Objekt kann",
          "id": "b51d18b551043c1f145f22dbde6f8531faeaf68c54ed9dd79ce24d17"
        },
        {
          "text": "Operationen lassen Programme übersichtlicher sein.",
          "id": "f09265efb456b0336079ad5b238daa1e38a11b1d71cc0e1a4e8edd56"
        },
        {
          "text": "zum erledigen von Teilaufgaben",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "...",
          "id": "ae8820303e493738a211ebb2ae3a2f90b286f20f767609beb77522c0"
        },
        {
          "text": "Zur besseren Gliederung von Code.",
          "id": "b8607e0369fbf3e33bc0e358f840915d8c085d1496097351913c0122"
        },
        {
          "text": "um ausführungsanweisungen zu bündeln",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "Wiederverwendbar,",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        }
      ]
    },
    {
      "text": "Was gehört zu der Signatur einer Operation in Java?",
      "id": 50809,
      "title": "Signatur in Java",
      "type": "definition",
      "referenceAnswer": {
        "text": "Zur Signatur gehören der Name und die Parameter, insbesondere die Parameterzahl und Reihenfolge der Typen.",
        "aspects": [
          {
            "text": "Zur Signatur gehören der Name",
            "elements": [
              [
                0,
                29
              ]
            ]
          },
          {
            "text": "Zur Signatur gehören ;; die Parameter",
            "elements": [
              [
                0,
                20
              ],
              [
                34,
                47
              ]
            ],
            "implied": true
          },
          {
            "text": "Zur Signatur gehören ;; insbesondere die Parameterzahl und Reihenfolge der Typen",
            "elements": [
              [
                0,
                20
              ],
              [
                49,
                105
              ]
            ]
          }
        ]
      },
      "answersAnnotation": [
        {
          "text": "Ein Methodenkopf",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Der Name der Operation, Anzahl und Typ ihrer Parameter.",
          "id": "4cfc3a1811fe40afa401b25ef7fa0379f1f7c1930a04f8755d678474"
        },
        {
          "text": "Name der Operation, Parameter und Rückgabetyp.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Der Name und die Übergabeparameter.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Rückgabewert, Methodenname, Parameter",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Public oder private, die übergebenen Argumente und zurückgegebener Datentyp oder void.",
          "id": "7ba019a2553e1137a4bbb8d3c779a48e5ceb2ca3a162e6e0a945ef0f"
        },
        {
          "text": "Der Rückgabewert, die Sichtbarkeit und der Name.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "lol",
          "id": "c1b8144ee1a30244a571c3d9b48b2c394a7489065d2565968f521645"
        },
        {
          "text": "Die Sichtweise (public, private, protected etc).",
          "id": "0ce8152aa92136af039b687c01c7dccfcb271f3db2d0ddcb3cfdd3e6"
        },
        {
          "text": "Die Rückgabe und Eingabe der Operation.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Der Rückgabetyp, der Operationsname und die übergebenen Parameter.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "In die Signatur einer Operation gehören Name der Operation, Rückgabetyp und die Parameter, die der Operation übergeben werden sollen",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Öffentlichkeit \\/ statisch? \\/ Rückgabewert \\/ Name \\/ Parameter",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Name, Parameter.",
          "id": "408f0afbe2440a4383a1e75b7d5b0b4202c7f7131a9acf9bd70492f3"
        },
        {
          "text": "public private protected void dateneingabe",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Um die Operation dem Aufruf zuordnen zu können",
          "id": "271f93f45e9b4067327ed5c8cd30a034730aaace4382803c3e1d6c2f"
        },
        {
          "text": "Sichtbarkeit, Rückgabewert, name (parameter)",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Ein Methodenkopf, sowie Methodenrumpf. Im Methodenkopf steht der Name, der Operation, der Rückgabetyp, die zu übergebenen Parameter und die Sichtbarkeit.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "Funktionsname und deren Parameter. Nicht der Rückgabewert.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "Der Name der Operation und ihre Parameter.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "public <Rückgabetyp> <Name der Klasse> (PArameter)",
          "id": "53750c72b7bb26cb6ff7115e383ca150d5a632a909a7f79e2f5274a4"
        },
        {
          "text": "Sichtbarkeit, Rückgabewert, Name",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Sichtbarkeits dekalration: public, private, protected Wiedergabe Wert: void, Object, boolean etc. Name ggf: Parameter ggf static",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Der Kopf mit Rückgabeart und Parametern und der Rumpf mit dem Algorythmus",
          "id": "8416c38cc898f1ac7cc9d64e89dab1f70f5ddab002a5b2a1713f93f5"
        },
        {
          "text": "nnb",
          "id": "192f56eb9bd894a72b30c303247b107be2c4591f310dd69a67927f48"
        },
        {
          "text": "Rückgabewert + Methodenname + zu übergebene Parameter",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "In Java umfasst die Signatur Operationsname und Parameter.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Name, Parameter und Rückgabetyp",
          "id": "b51d18b551043c1f145f22dbde6f8531faeaf68c54ed9dd79ce24d17"
        },
        {
          "text": "Sichtbarkeit, Rückgabetyp, Name, evtl. Übergabewerte",
          "id": "f09265efb456b0336079ad5b238daa1e38a11b1d71cc0e1a4e8edd56"
        },
        {
          "text": "ein Funktionskopf (Rückgabewert Name und ggf. Übergabeparameter) und ein Funktionsrumpf die Ansammlung von Anweisungen.",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "Rückgabewert, Parameter und Datentyp",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Rückgabe, Parameter",
          "id": "ae8820303e493738a211ebb2ae3a2f90b286f20f767609beb77522c0"
        },
        {
          "text": "Der Name und der\\/die Parameter.",
          "id": "b8607e0369fbf3e33bc0e358f840915d8c085d1496097351913c0122"
        },
        {
          "text": "Rückgabetyp, Name und Variablen, die übergeben werden",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "Der Rückgabetyp einer Methode, der Name der Operation und möglichweise noch die Werte die der Operation beim Aufruf übergeben wird.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Name und Parameter.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "name, anzahl, typ der Parameter",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Es gehört die Sichtbarkeit, der Rückgabetyp, der Name und die Parameter dazu.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        }
      ]
    },
    {
      "text": "Wozu dient eine Signatur?",
      "id": 50810,
      "title": "Funktion der Signatur",
      "type": "description",
      "referenceAnswer": {
        "text": "Die Signatur dient zur eindeutigen Identifikation einer Operation.",
        "aspects": [
          {
            "text": "Die Signatur dient zur eindeutigen Identifikation einer Operation",
            "elements": [
              [
                0,
                75
              ]
            ]
          }
        ]
      },
      "answersAnnotation": [
        {
          "text": "Um verschiedene Werte auf dieser Operation ausführen zu können.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Die Signatur wird bei der Verwendung im Programm angegeben.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Zur Unterscheidung der einzelnen Methoden.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Zur Spezifizierung der Operation",
          "id": "7ba019a2553e1137a4bbb8d3c779a48e5ceb2ca3a162e6e0a945ef0f"
        },
        {
          "text": "Die Signatur dient zur Übergabe von Werten und anderen Daten.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Name, um eindeutig unterscheidbare Operationen zu haben Parameter, um festzulegen welche Werte die Operation übergeben bekommen muss um ausführbar zu sein",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "k",
          "id": "c1b8144ee1a30244a571c3d9b48b2c394a7489065d2565968f521645"
        },
        {
          "text": "Eine Signatur dient dazu, genau anzugeben, was der Sinn der Operation ist.",
          "id": "0ce8152aa92136af039b687c01c7dccfcb271f3db2d0ddcb3cfdd3e6"
        },
        {
          "text": "Die Signatur wird dazu verwendet um die Operation aufrufen zu können.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "eine Signatur dient zur eindeutigen Unterscheidung der einzelnen Operationen, insbesondere durch Namen der Operation und durch Reihenfolge und Art der Parameter",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Die Signatur dient zur Unterscheidung von Operationen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Zur wiederholbaren Ausführbarkeit",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "So wird definiert, wie man eine Methode aufrufen kann.",
          "id": "408f0afbe2440a4383a1e75b7d5b0b4202c7f7131a9acf9bd70492f3"
        },
        {
          "text": "Zugriffsfestlegung",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Damit die Operation weiß, was sie tun soll und welche Elemente sie verwenden darf",
          "id": "271f93f45e9b4067327ed5c8cd30a034730aaace4382803c3e1d6c2f"
        },
        {
          "text": "damit kann man die operation aufrufen",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Um genauere Angaben über eine Operation zur Verfügung zu stellen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Man kann mithilfe der Signatur von anderen Operationen aus auf die Operation zugreifen.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "Ausreichend, damit m",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Hiermit kann erkannt werden ob z.B. doSomething(a, b); die Version der Funktion mit (int, int) oder mit (int, string) meint. Somit wird die auszuführende Operatorenliste eingeschränkt.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "Um festzuhalten unter welchem Namen eine Operation aufruft und welche Argumente man dabei braucht. Außerdem um die Parameter für den Operationsrumpf zu bennenen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "UM Operationen mit ihrem Namen aufrufen zu können, je nach anzahl der PArameter werden unterschiedliche Operationen aufgerufen",
          "id": "53750c72b7bb26cb6ff7115e383ca150d5a632a909a7f79e2f5274a4"
        },
        {
          "text": "die parameter sind wichtig, da sie beim ausführen der operation zu den zu bearbeitenden argumenten werden, deren Ergebnisse (wenn nicht void) wieder in den Parametern gespeichert werden und der Rückgabetyp ist wichtig um zu wissen, welcher typ zurück gegeben wird",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Sie dient dazu, die Rückgabeart festzulegen, den Namen festlegen und die Parameter festzulegen(Typ, Anzahl, Reihenfolge)",
          "id": "8416c38cc898f1ac7cc9d64e89dab1f70f5ddab002a5b2a1713f93f5"
        },
        {
          "text": "hjg",
          "id": "192f56eb9bd894a72b30c303247b107be2c4591f310dd69a67927f48"
        },
        {
          "text": "Darunter kann später die Methode in der Main-Methode aufgerufen werden.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Zur eindeutigen Unterscheidung von verschiedenen Operationen.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Die Signatur zeigt einem auf den ersten Blick, was eine Operation zurückgibt und wer sie verwenden kann. Sie bildet den Kopf einer Operation und grenzt sie so von anderen Operationen ab.",
          "id": "f09265efb456b0336079ad5b238daa1e38a11b1d71cc0e1a4e8edd56"
        },
        {
          "text": "zur eindeutigen identifizierung der Methode",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "zum aufrufen und zum übergeben der Parameter",
          "id": "ae8820303e493738a211ebb2ae3a2f90b286f20f767609beb77522c0"
        },
        {
          "text": "Zur eindeutigen Identifikation von Operationen.",
          "id": "b8607e0369fbf3e33bc0e358f840915d8c085d1496097351913c0122"
        },
        {
          "text": "um die Operation genau zu spezifizieren, damit man sie richtig aufrufen kann",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "Einedeutige Identifizierung der Operation",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        }
      ]
    },
    {
      "text": "Was ist ein Parameter?",
      "id": 50811,
      "title": "Definition Parameter",
      "type": "definition",
      "referenceAnswer": {
        "text": "Ein Parameter ist eine lokale Variable einer Operation, die beim Aufruf von außen mit einem Wert versehen werden kann.",
        "aspects": [
          {
            "text": "Ein Parameter ist eine lokale Variable einer Operation",
            "elements": [
              [
                0,
                54
              ]
            ]
          },
          {
            "text": "die beim Aufruf von außen mit einem Wert versehen werden kann",
            "elements": [
              [
                56,
                117
              ]
            ]
          }
        ]
      },
      "answersAnnotation": [
        {
          "text": "eine Variable",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Ein Parameter ist ein Platzhalter für einen Wert eines bestimmten Datentyps.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Manche Operationen benötigen Parameter, um etwas durchführen zu können. Dieser steht hinter der Operation in Klammern.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Ist eine Variable welche an eine Methode übergeben wird.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "An die Operation übergebene Daten eines festgelegten Datentyps.",
          "id": "7ba019a2553e1137a4bbb8d3c779a48e5ceb2ca3a162e6e0a945ef0f"
        },
        {
          "text": "Parameter sind Datenstrukturen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Datentyp, der in der OPeration benötigt wird um ausgeführt werden zu können",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "eine übergebene variable",
          "id": "c1b8144ee1a30244a571c3d9b48b2c394a7489065d2565968f521645"
        },
        {
          "text": "Ein Parameter kann z.B. eine Variable wie ein Int sein, und ist ein Teil, mit dem die Operation etwas macht.",
          "id": "0ce8152aa92136af039b687c01c7dccfcb271f3db2d0ddcb3cfdd3e6"
        },
        {
          "text": "Ein Parameter einer Operation ist die Eingabe, welche Daten enthält.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Ein Wert, der einer Operation bei ihrem Aufruf übergeben wird.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "ein Parameter ist ein Wert der der Operation übergeben wird. Mit den Parametern werden Variablen in der Operation initialisiert und bekommen so direkt einen Wert zugewiesen",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Ein Parameter ist eine Variable, die einer Operation übergeben wird. Mit dieser Variablen arbeitet die Operation.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Eine eingegebene Variable.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Eine Variable, die einer Klasse, Methode oder einem Block gehört.",
          "id": "408f0afbe2440a4383a1e75b7d5b0b4202c7f7131a9acf9bd70492f3"
        },
        {
          "text": "Ein datentyp und art der eingabe",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "operation wird mit den übergebenen Datenausgeführt. Übergebene daten sind parameter",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Parameter beschreiben welche und wie viele Variablentypen der Operation beim Aufruf übergeben werden müssen.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "Ein Wert für die Ausführung der Subroutine.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "Ein Parameter ist eine Variable die später in ihrer Operation verwendet werden kann.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Die zu übergebenden Werte, die eine Operation zum funktionieren benötigt",
          "id": "53750c72b7bb26cb6ff7115e383ca150d5a632a909a7f79e2f5274a4"
        },
        {
          "text": "Dies werden übergeben um beim Ausführen als Argumente bearbeitet zu werden",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Ein Wert, den die Methode übergeben bekommt.",
          "id": "8416c38cc898f1ac7cc9d64e89dab1f70f5ddab002a5b2a1713f93f5"
        },
        {
          "text": "bh",
          "id": "192f56eb9bd894a72b30c303247b107be2c4591f310dd69a67927f48"
        },
        {
          "text": "Ein Parameter ist ein Übergabewert einer Methode.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Eine Variable.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Variablen, denen beim Aufruf der Operation Werte zugewiesen werden können",
          "id": "b51d18b551043c1f145f22dbde6f8531faeaf68c54ed9dd79ce24d17"
        },
        {
          "text": "Ein übergebenes Objekt, auf dem die Operation ausgeführt wird.",
          "id": "f09265efb456b0336079ad5b238daa1e38a11b1d71cc0e1a4e8edd56"
        },
        {
          "text": "Ein Parameter ist ein Wert der der Funktion übergeben Werden kann, sodass die Anweisungen damit arbeiten können.",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "Variablen mit Werten",
          "id": "ae8820303e493738a211ebb2ae3a2f90b286f20f767609beb77522c0"
        },
        {
          "text": "Ein Parameter wird an eine Operation übergeben und dann von ihr verarbeitet.",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "Lokale Variable der Operation die ihr beim Aufruf von außen mitgegeben werden kann",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Eine Variable, der beim Aufruf einer Operation Werte zugewiesen wird.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        }
      ]
    },
    {
      "text": "Was ist eine lokale Variable?",
      "id": 50812,
      "title": "Definition lokale Variable",
      "type": "definition",
      "referenceAnswer": {
        "text": "Eine lokale Variable ist nur in einem bestimmten Kontext (Scope) definiert ist.",
        "aspects": [
          {
            "text": "Eine lokale Variable ist nur in einem bestimmten Kontext (Scope) definiert ist",
            "elements": [
              [
                0,
                78
              ]
            ]
          }
        ]
      },
      "answersAnnotation": [
        {
          "text": "eine Variable die über mehrere Methoden hinweg aufegerufen werden kann",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Eine Variable, welche nur innerhalb einer Operation erhalten bleibt (oder lokaler innerhalb einer Schleife).",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Eine Variable, welche nur innerhalb einer Funktion. Nur hier ist sie gültig.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Eine Variable die nur innerhalb einer Operation existiert.",
          "id": "7ba019a2553e1137a4bbb8d3c779a48e5ceb2ca3a162e6e0a945ef0f"
        },
        {
          "text": "Eine lokale Variable existiert nur innerhalb einer Operation.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "lokale variable kann nur innerhalb der operation verwendet werden",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "eine variable, die nur in der jeweiligen methode benutzt werden kann",
          "id": "c1b8144ee1a30244a571c3d9b48b2c394a7489065d2565968f521645"
        },
        {
          "text": "Eine lokale Variable ist eine Variable die nur innerhalb einer Operation aufgerufen wird.",
          "id": "0ce8152aa92136af039b687c01c7dccfcb271f3db2d0ddcb3cfdd3e6"
        },
        {
          "text": "Eine lokale Variable ist eine Variable einer Operation, die nur innerhalb der Operation selbst benutzt werden kann.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Eine lokale variable ist eine Variable die in einer Operation deklariert wird und auch nur in dieser Operation bekannt\\/ gültig sind.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Eine lokale Variable ist eine Variable die nur in der Operation zur Verfügung steht, in der sie deklariert und initialisiert wurde",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Auf eine lokale Variable kann nur eine Operation zugreifen, in der diese initialisiert wurde.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Eine Variable die nur auf einen bestimmten Teil des Codes, bzw. einer Operation Bezug nimmt.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Eine Variable, die nur beim Aufruf der Methode initialisiert wird, nur von der Methode zugreifbar ist und die nach dem Beenden der Methode gelöscht wird.",
          "id": "408f0afbe2440a4383a1e75b7d5b0b4202c7f7131a9acf9bd70492f3"
        },
        {
          "text": "zugriff nur innerhalb einer operation",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Variable, auf die nur die aktuelle Operation zugreifen kann",
          "id": "271f93f45e9b4067327ed5c8cd30a034730aaace4382803c3e1d6c2f"
        },
        {
          "text": "eine variable die innerhalb einer operation deklariert wurde und nur in dem block wo sie deklariert wurde verfügbar ist",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Eine lokale Variable existiert nur in einem bestimmten Bereich des Quellcodes. Außerhalb diese Bereichs kann nicht auf die Variable zugegriffen werden.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "Eine Variable, die nur in einer Operation initialisiert ist.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Diese hat einen beschränkten Gültigkeitsbereich - so ist das int i in einer Methode ein anderes int i als das in der main() - insofern nicht als Parameter übergeben.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "Eine lokale Variable ist eine Variable die nur in einem Teil eines Programms existiert.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "EIne Variable die nur in einer bestimmten Operation initialisiert ist.",
          "id": "53750c72b7bb26cb6ff7115e383ca150d5a632a909a7f79e2f5274a4"
        },
        {
          "text": "eine variable auf die nur innerhalb des gleichen Blocks drauf zugegriffen werden kann",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Eine Variable, die nur in der Methode deklariert und verwendet wird und somit nicht vomn Rest der Klasse verwendet werden kann.",
          "id": "8416c38cc898f1ac7cc9d64e89dab1f70f5ddab002a5b2a1713f93f5"
        },
        {
          "text": "jnj",
          "id": "192f56eb9bd894a72b30c303247b107be2c4591f310dd69a67927f48"
        },
        {
          "text": "Eine lokale Variable ist eine Variable, die nicht dauerhaft im Programm zur Verfügung steht. Das kann beispielweise die Variable in der For-Schleife sein.  Nach der Schleife ist die Variable nicht mehr 'vorhanden'.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Eine Variable, die nur in einer Operation deklariert wird.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Eine lokale Variable existiert nur innerhalb des Operation und während der Ausführung. Bei einem erneuten Aufruf wird die Variable erneut erzeugt. Am Ende wird sie gelöscht.",
          "id": "b51d18b551043c1f145f22dbde6f8531faeaf68c54ed9dd79ce24d17"
        },
        {
          "text": "Eine lokale Variable ist eine Variable, die nur innerhalb einer Operation verwendet wird.",
          "id": "f09265efb456b0336079ad5b238daa1e38a11b1d71cc0e1a4e8edd56"
        },
        {
          "text": "eine Variable die nur innerhalb der Funktion bekannt ist",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "eine Variable die in einem bestimmten Abschnitt  verwendet wird",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Eine Varibale die nur dort definiert ist",
          "id": "ae8820303e493738a211ebb2ae3a2f90b286f20f767609beb77522c0"
        },
        {
          "text": "Eine Variable die nur in ihrer Klasse aufrufbar ist.",
          "id": "b8607e0369fbf3e33bc0e358f840915d8c085d1496097351913c0122"
        },
        {
          "text": "Eine lokale Variable ist nur innerhalb einer Operation sichtbar.",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "Eine lokale Variable ist eine Variable, die innerhalb der Operation deklariert wurde und demnach nur innerhalb der Operation definiert ist.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        }
      ]
    },
    {
      "text": "Was ist eine globale Variable?",
      "id": 50814,
      "title": "Definition globale Variable",
      "type": "definition",
      "referenceAnswer": {
        "text": "Auf eine globale Variable kann von überall innerhalb eines Programms zugegriffen werden.",
        "aspects": [
          {
            "text": "Auf eine globale Variable kann von überall innerhalb eines Programms zugegriffen werden",
            "elements": [
              [
                0,
                87
              ]
            ]
          }
        ]
      },
      "answersAnnotation": [
        {
          "text": "variable die ber verschiedene metoden genutzt werden kann",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Eine Variable, welche innerhalb der gesamten Klasse aufrufbar ist.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Variablen welche im gesamten Programm an jeder Stelle aufgerufen werden können.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Eine Variable auf die aus jedem Kontext zugegriffen werden kann",
          "id": "7ba019a2553e1137a4bbb8d3c779a48e5ceb2ca3a162e6e0a945ef0f"
        },
        {
          "text": "Eine globale Variable ist in der gesamten Kasse definiert.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "kann in jedem kontext verwendet werden",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "eine variable die für alle klassen eines programms definiert ist",
          "id": "c1b8144ee1a30244a571c3d9b48b2c394a7489065d2565968f521645"
        },
        {
          "text": "Eine globale Variable ist außerhalb einzelner Operationen definiert und kann somit in alle Unterklassen des Programms verwendet werden.",
          "id": "0ce8152aa92136af039b687c01c7dccfcb271f3db2d0ddcb3cfdd3e6"
        },
        {
          "text": "Eine globale Variable ist eine Variable auf die im gesamten Programm zugegriffen werden kann, unabhängig vom Scope.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Eine VAriable die in einer gesamten Klasse gültig und deklariert ist.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "eine globale Variable steht allen Operationen zur Verfügung und wird mithilfe von static deklariert",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Eine globale Variable wird in einer Klasse außerhalb einer Operation initialisiert, sodass jede Methode innerhalb dieser Klasse darauf zugreifen kann.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Sie gilt für alle Operationen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Das ist eine Variable, die direkt in der Klasse definiert ist.",
          "id": "408f0afbe2440a4383a1e75b7d5b0b4202c7f7131a9acf9bd70492f3"
        },
        {
          "text": "eine von überalle in allen operatioenn verfügbare variable",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Eine Variable, auf die auch andere Operationen zugreifen können",
          "id": "271f93f45e9b4067327ed5c8cd30a034730aaace4382803c3e1d6c2f"
        },
        {
          "text": "variable die innerhalb der klasse aber außerhalb von Operationen deklariert wurde und überall in der klasse aufgerufen und verändert werden kann",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Eine globale Variable existiert in einer Klasse unabhängig von Operationen.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "Eine Variable, die immer genutzt werden kann und erst bei Beenden das Programms zerstört wird.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "Eine Variable auf die von überall drauf zugegriffen werden kann.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "EIne Variable die in einer Klasse initialisiert ist und auf die von allen Operationen zugegriffen werden kann",
          "id": "53750c72b7bb26cb6ff7115e383ca150d5a632a909a7f79e2f5274a4"
        },
        {
          "text": "Eine variable, auf die nicht nur alles operationen der eigenen Klasse zugreifen können, sondern auch andere Klassen (wenn public)",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Eine Globale Variable",
          "id": "8416c38cc898f1ac7cc9d64e89dab1f70f5ddab002a5b2a1713f93f5"
        },
        {
          "text": "kkjkj",
          "id": "192f56eb9bd894a72b30c303247b107be2c4591f310dd69a67927f48"
        },
        {
          "text": "Eine globale Variable steht zu jeder Zeit im Programm zu Verfügung und kann jeder Zeit genutzt werden. Also auch in Methoden oder ähnliches.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Eine Variable, auf die aus verschiedenen Kontexten zugegriffen werden kann. Oft eine statische Klassenvariable.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Eine globale Variable existiert auch zwischen den Operationen und alle Operationen können auf sie zugreifen.",
          "id": "b51d18b551043c1f145f22dbde6f8531faeaf68c54ed9dd79ce24d17"
        },
        {
          "text": "Eine globale Variable steht alles Operationen einer Klasse zur Verfügung.",
          "id": "f09265efb456b0336079ad5b238daa1e38a11b1d71cc0e1a4e8edd56"
        },
        {
          "text": "eine Variable die von allen Methoden gesehen werden kann",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "Alle Klassen eines Paketes können darafu zugreifen",
          "id": "ae8820303e493738a211ebb2ae3a2f90b286f20f767609beb77522c0"
        },
        {
          "text": "Eine Variable die von überall aufgerufen und verändert werden kann.",
          "id": "b8607e0369fbf3e33bc0e358f840915d8c085d1496097351913c0122"
        },
        {
          "text": "Eine globale Variable ist ach außerhalb einer operation gültig, aber innerhalb der Klasse.",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "Variable auf die von überall zugegriffen werden kann",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Eine globale Variable ist innerhalb einer Klasse und außerhalb einer Operation definiert.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        }
      ]
    },
    {
      "text": "Warum sind nicht einfach alle Variablen global?",
      "id": 50815,
      "title": "Grund für lokale Variablen",
      "type": "reason",
      "referenceAnswer": {
        "text": "Das binden von Variablen an bestimmte Ausführungskontexte spart Arbeitsspeicher und es erlaubt die unabhängige Wiederverwendung von Variablennamen in verschiedenen Kontexten.",
        "aspects": [
          {
            "text": "Das binden von Variablen an bestimmte Ausführungskontexte spart Arbeitsspeicher",
            "elements": [
              [
                0,
                79
              ]
            ]
          },
          {
            "text": "und es erlaubt die unabhängige Wiederverwendung von Variablennamen in verschiedenen Kontexten",
            "elements": [
              [
                80,
                173
              ]
            ]
          }
        ]
      },
      "answersAnnotation": [
        {
          "text": "Dann würde es zu viele geben, sodass es unübersichtlich wird und zu viel Arbeitsspeicher verbraucht",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Weil manche Variablen nicht von überall her verändert werden sollen, sondern nur innerhalb zB einer Operation.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Damit die Werte dieser Variablen nicht ausversehen überschrieben werden.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Damit sich zB Objekte untereinander unterscheiden können",
          "id": "7ba019a2553e1137a4bbb8d3c779a48e5ceb2ca3a162e6e0a945ef0f"
        },
        {
          "text": "Damit nicht von überall ihre Werte unerwünscht verändert werden können.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "weil sie sonst in jedem kontext verändert werden könnten",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "wenn man z.b. eine nebenoperation mit einer zahl durchführen will, diese aber nicht in der anderen methode verändern soll",
          "id": "c1b8144ee1a30244a571c3d9b48b2c394a7489065d2565968f521645"
        },
        {
          "text": "Weil es manchmal praktischer ist, Variablen lokal zu verändern und an einer anderen Stelle anders zu benutzen.",
          "id": "0ce8152aa92136af039b687c01c7dccfcb271f3db2d0ddcb3cfdd3e6"
        },
        {
          "text": "Um die Strukturierung des Codes zu ermöglichen.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Da viele variablen nur in einem bestimmten Kontext benötigt werden",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "es sind nicht einfach alle Variablen global da man auf manche Variablen den Zugriff von außen verhindern möchte",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Um zu vermeiden, dass man bestimmte Variablen von außen ändern kann (Sicherheit).",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Das wird zu komplex.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Weil es zu unsicher wäre. Jede Methode könnte die Variablen manipulieren. Darüber hinaus müssten sie alle die ganze Zeit gespeichert bleiben.",
          "id": "408f0afbe2440a4383a1e75b7d5b0b4202c7f7131a9acf9bd70492f3"
        },
        {
          "text": "versehentliche oder ungewollte änderungen",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Weil man so sehr leicht am Programm herum pfuschen könnte. Einige Variable müssen aus Sicherhetsgründen (z.B. auch Datenschutz) lokal sein",
          "id": "271f93f45e9b4067327ed5c8cd30a034730aaace4382803c3e1d6c2f"
        },
        {
          "text": "objektorientierte Programmierung, Objekte zb brauchen variablen",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Manche Variablen sollen von außerhalb einer Operation nicht geändert werden können.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "Weil man somit schnell keine einfachen Namen mehr hat und man schnell durcheinander kommen wird.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "Weil dann zuviele Variablen benötigt würden, was nicht übersichtlich wäre. Außerdem können mit lokalen Varibalen Namen wiederverwendet werden.",
          "id": "f09265efb456b0336079ad5b238daa1e38a11b1d71cc0e1a4e8edd56"
        },
        {
          "text": "Weil nicht jeder Teilaspekt eines Programms mit jedem anderen zu tun hat. Außerdem würde das mehr Speicher kosten, weil die eigentlich lokalen Variablen dann nicht nach Abschluss einer Operation, Schleife, o.Ä. gelöscht werden könnten.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Mehr Speicherbedarf, Programme können von außen manipuliert werden",
          "id": "53750c72b7bb26cb6ff7115e383ca150d5a632a909a7f79e2f5274a4"
        },
        {
          "text": "in manchen Kontexten macht es mehr Sinn Variablen Global zu definieren",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "jnjn",
          "id": "192f56eb9bd894a72b30c303247b107be2c4591f310dd69a67927f48"
        },
        {
          "text": "Um einen konstanten Wert zu haben, der überall genutzt werden kann.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Oftmals sollen mit konstanten Werten mehrer Operationen ausgeführt werden, die unterschiedliche Ergebnisse erbringen, im Prozess aber nicht die Variable ändern sollen.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Besonders wenn die Programme sehr lang werden würde das das ganze Programm unübersichtlich gestalten.",
          "id": "b51d18b551043c1f145f22dbde6f8531faeaf68c54ed9dd79ce24d17"
        },
        {
          "text": "dadurch würden methoden sich ggf. gegenseitig beeinflussen sodass es zu Problemen kommen kann die nur schwer zu finden sind",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "Um sie zu schützen",
          "id": "ae8820303e493738a211ebb2ae3a2f90b286f20f767609beb77522c0"
        },
        {
          "text": "Es verhindert Namenskonflikte bei mehrmaligem Gebrauch.",
          "id": "b8607e0369fbf3e33bc0e358f840915d8c085d1496097351913c0122"
        },
        {
          "text": "bei einer globalen Variablen ist während der gesamten Laufzeit der Speicherplatz reserviert. Evtl. wird die Variable aber nur in einer Operation oder in einer Schleife benötigt. wenn sie dann lokal definiert wird, wird nach Beendigung der Operation oder Schleife der Speicherplatz wieder freigegeben.",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "Speichereinsparung und Namenswiederverwendung",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "zumindest rekursive Funktionsaufrufe benötigen lokale Variablen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        }
      ]
    },
    {
      "text": "Was ist das Prinzip von 'call by value'?",
      "id": 50817,
      "title": "'Call by value'",
      "type": "definition",
      "referenceAnswer": {
        "text": "'Call by value' bedeutet, dass bei der Parameterübergabe die Kopie des Wertes einer Variablen übergeben wird. So haben Änderungen dieses Wertes innerhalb der Funktion keinen Effekte auf den ursprünglichen Wert.",
        "aspects": [
          {
            "text": "'Call by value' bedeutet, dass bei der Parameterübergabe die Kopie des Wertes einer Variablen übergeben wird",
            "elements": [
              [
                0,
                108
              ]
            ]
          },
          {
            "text": "So haben Änderungen dieses Wertes innerhalb der Funktion keinen Effekte auf den ursprünglichen Wert",
            "elements": [
              [
                110,
                209
              ]
            ]
          }
        ]
      },
      "answersAnnotation": [
        {
          "text": "die Variable wird über ihren Wert definiert bsp Int, flow, long",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Bezieht sich auf eine Variable die als Wert den tatsächlichen Wert gespeichert hat.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Der Wert ist direkt in der Variable gespeichert",
          "id": "7ba019a2553e1137a4bbb8d3c779a48e5ceb2ca3a162e6e0a945ef0f"
        },
        {
          "text": "Das Prinzip von call by value ist, dass wenn die Variable abgerufen wird, mit dem Wert an sich gearbeitet wird.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "wird durch wert aufgerufen",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "der eigentliche wert einer variablen wird aufgerufen",
          "id": "c1b8144ee1a30244a571c3d9b48b2c394a7489065d2565968f521645"
        },
        {
          "text": "Call by value bedeutet, dass eine Veränderung eines Parameters keine Auswirkungen auf die aufgerufene Variable hat.",
          "id": "0ce8152aa92136af039b687c01c7dccfcb271f3db2d0ddcb3cfdd3e6"
        },
        {
          "text": "Beim Aufrufen einer Operation werden die Parameter kopiert, sodass diese innerhalb der Operation verändert werden können, und außerhalb der Operation sich nicht verändern.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Wenn eine Variable direkt einen Wert verwaltet, wie bei integer oder boolean.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "beim call by value wird der Wert kopiert",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Ruft einen primitiven Datentyp auf.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Die Veränderung des Parameters hat keine Auswirkung auf die übergegebene Variable des primitiven Datentyps.",
          "id": "408f0afbe2440a4383a1e75b7d5b0b4202c7f7131a9acf9bd70492f3"
        },
        {
          "text": "aufrufen im programm",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Aufrufen, wenn bestimmter Wert gefunden",
          "id": "271f93f45e9b4067327ed5c8cd30a034730aaace4382803c3e1d6c2f"
        },
        {
          "text": "Man ruft direkt die Variable ab - nicht den Pointer.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "Dass nicht die Referenz von Daten sondern die tatsächlichen Daten abgerufen werden.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "man bezieht sich auf den Inhalt eines Objektes, nicht auf dessen Namen",
          "id": "53750c72b7bb26cb6ff7115e383ca150d5a632a909a7f79e2f5274a4"
        },
        {
          "text": "Wenn wir einen einfachen Datentypen aufrufen, schauen wir direkt auf den Wert, eine Änderung dieses Wertes hat keinen Einfluss auf den Parameter",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "dcv",
          "id": "192f56eb9bd894a72b30c303247b107be2c4591f310dd69a67927f48"
        },
        {
          "text": "Das Prinzip findet bei Methoden statt. In Java werden beispielsweise Int-Werte mithilfe von Call-by-Value aufgerufen. Es wird quasi eine Kopie von dem Parameter erstellt.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Parameter werden durch einfaches Kopieren des Inhalt der Variable (primitiver Datentyp) intitialisiert.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Das Prinzip von call by value ist, dass ein konkreter Wert übergeben wird.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Der Wert wurde kopiert und übergeben",
          "id": "b51d18b551043c1f145f22dbde6f8531faeaf68c54ed9dd79ce24d17"
        },
        {
          "text": "primitive Datentypen speichern den Inhalt an sich",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Das Aufrufen einer Varibale gibt den Wert zurück.",
          "id": "f09265efb456b0336079ad5b238daa1e38a11b1d71cc0e1a4e8edd56"
        },
        {
          "text": "es wird eine variable an eine methode übergeben, jedoch nur der Wert dieser, somit hat die Methode keinen Einfluss auf die Variable direkt.",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "der wert wird wiedergegeben",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Es wird eine Kopie der Variable an die Operation übergeben, so das der ursprüngliche Wert nicht verändert wird.",
          "id": "b8607e0369fbf3e33bc0e358f840915d8c085d1496097351913c0122"
        },
        {
          "text": "Bei call-by-value wird auf einen direkten Wert im Speicher zugegriffen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "es wird eine Kopie erzeugt, der Originalwert wird nicht verändert, die Methode arbeitet mit der Kopie",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "Nur der Wert wird kopiert und übergeben, Änderungen haben keinen weiteren Einfluss",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Der Wert wird kopiert.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        }
      ]
    },
    {
      "text": "Was ist das Prinzip von 'call by reference'?",
      "id": 50818,
      "title": "'Call by reference'",
      "type": "definition",
      "referenceAnswer": {
        "text": "'Call by reference' bedeutet, dass bei der Parameterübergabe eine Referenz auf einen Wert übergeben wird. So beeinflussen Veränderungen des Parameters innerhalb der Operation auch den Wert der beim Funktionsaufruf übergebenen Variablen.",
        "aspects": [
          {
            "text": "'Call by reference' bedeutet, dass bei der Parameterübergabe eine Referenz auf einen Wert übergeben wird",
            "elements": [
              [
                0,
                104
              ]
            ]
          },
          {
            "text": "So beeinflussen Veränderungen des Parameters innerhalb der Operation auch den Wert der beim Funktionsaufruf übergebenen Variablen",
            "elements": [
              [
                106,
                235
              ]
            ]
          }
        ]
      },
      "answersAnnotation": [
        {
          "text": "bei der übergabe werden referenzen übergeben, sodass änderungen auch die ursprünglich variable betreffen",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "'Call by reference' bedeutet, dass bei der Parameterübergabe die Kopie der Referenz einer Variablen übergeben wird.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Die Referenz auf den Wert wird als Parameter übergeben. Somit kann der Wert überall verändert werden.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Es wird die Referenz übergeben, sodass Änderungen sich auf beide auswirken.",
          "id": "7ba019a2553e1137a4bbb8d3c779a48e5ceb2ca3a162e6e0a945ef0f"
        },
        {
          "text": "Das Prinzip von call by reference ist, dass bei der Übergabe von Werten die Referenz übergeben wird, Veränderungen sich also auf den ursprünglichen Wert auswirken.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "die Referenz einer variablen, also der Speicherort wird übergeben",
          "id": "c1b8144ee1a30244a571c3d9b48b2c394a7489065d2565968f521645"
        },
        {
          "text": "Call by reference bedeutet, dass bei der Parameterübergabe die Referenz der durch die Funktion aufgerufenen und veränderten Variablen kopiert und übergeben wird.",
          "id": "0ce8152aa92136af039b687c01c7dccfcb271f3db2d0ddcb3cfdd3e6"
        },
        {
          "text": "Das Prinzip call by reference bedeutet, dass beim Aufrufen einer Operation die Parameter als Verweis übergeben werden. Dadurch werden Änderungen innerhalb der Operation sich auf die ursprünglichen Werte auswirken.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Das bei einem Parameter die Referenz übergeben wird und eine Änderung dieser Referenz Auswirkungen auf die ursprungsvariable hat.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "bei call by reference wird nicht der Wert sondern die Referenz kopiert",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Ruft eine Referenz auf.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Wenn ein Array als Parameter übergeben wird, haben die Änderungen des Parameters auswirkung auf das Array.",
          "id": "408f0afbe2440a4383a1e75b7d5b0b4202c7f7131a9acf9bd70492f3"
        },
        {
          "text": "zugriff auf die kopie",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Die Referenz der Variablen wird übergeben",
          "id": "271f93f45e9b4067327ed5c8cd30a034730aaace4382803c3e1d6c2f"
        },
        {
          "text": "Man übergibt einen Pointer auf die Variable, die man dann beliebig ändern kann.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "Call by reference bedeutet, dass die Referenz und nicht die eigentlichen Daten abgerufen werden. Bei der Parameterübergabe einer Operation bedeutet das dann, dass die in der Referenz stehenden Daten im Laufe der Operation verändert werden könnten.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Bei call by reference wird die Referenz auf einen Wert übergeben, ursprünglicher Wert\\/Objekt wird verändert, es geht nicht nur um Inhalt",
          "id": "53750c72b7bb26cb6ff7115e383ca150d5a632a909a7f79e2f5274a4"
        },
        {
          "text": "Wir über geben nur die Referenz auf ein Objekt (zB bei Strings, Arrays, Objekten), dadurch verändern wir auch das in den Parametern gespeicherte",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "kml",
          "id": "192f56eb9bd894a72b30c303247b107be2c4591f310dd69a67927f48"
        },
        {
          "text": "Ist bei der Parameterübergabe von Objekten der Fall. Hier ist es keine Kopie, wie bei dem Prinzip Call-by-Value, sondern es verweist auf die Referenz des Objekts.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Hier wird die Referenz übergeben. Änderungen innerhalb der Funktion wirken sich nun auch auf den ursprünglichen Wert aus.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Bei der Parameterübergabe wird eine Kopie der Referenz auf ein Objekt übergeben.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Bei der Parameterübergabe wird eine Kopie der Referenz der Variable übergeben. Die Veränderung des Parameters hat somit Auswirkungen auf den Inhalt der Variable",
          "id": "b51d18b551043c1f145f22dbde6f8531faeaf68c54ed9dd79ce24d17"
        },
        {
          "text": "variable hält als wert eine Referenz auf den Inhalt im speicher",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Beim Übergeben einer Variable wird die Referenz kopiert.",
          "id": "f09265efb456b0336079ad5b238daa1e38a11b1d71cc0e1a4e8edd56"
        },
        {
          "text": "call bei refernce übergibt die Referenz der variablen also die Adresse im Speicher wodurch eine methode auf diese zugreifen kann und diese ändern kann.",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "die referenz wird kopiert",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Es wird der ursprüngliche Wert an die Operation übergeben, sodass Änderungen innerhalb der Operation Auswirkungen auf den ursprünglichen Wert haben.",
          "id": "b8607e0369fbf3e33bc0e358f840915d8c085d1496097351913c0122"
        },
        {
          "text": "hier wird die Referenz auf eine Variable übergeben und von der Operation auch der Originalwert geändert",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "Die Feferen wird übergeben, Veränderungen bleiben auch außerhalb der Operation erhalten",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        }
      ]
    },
    {
      "text": "Wozu dienen Pakete in Java?",
      "id": 50819,
      "title": "Funktion von Paketen in Java",
      "type": "description",
      "referenceAnswer": {
        "text": "Pakete werden genutzt um Klassen semantisch zu gruppieren.",
        "aspects": [
          {
            "text": "Pakete werden genutzt um Klassen semantisch zu gruppieren",
            "elements": [
              [
                0,
                67
              ]
            ]
          }
        ]
      },
      "answersAnnotation": [
        {
          "text": "Damit nicht immer alles von vorne programmiert werden muss",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Sie können bestimmte Operationen zur Verfügung stellen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Pakete bündeln Klassen, welche in Verbindung stehen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Implementierung von Operationen",
          "id": "7ba019a2553e1137a4bbb8d3c779a48e5ceb2ca3a162e6e0a945ef0f"
        },
        {
          "text": "d",
          "id": "c1b8144ee1a30244a571c3d9b48b2c394a7489065d2565968f521645"
        },
        {
          "text": "Pakete sind eine Sammlung von Klassen und dienen der Übersichtlichkeit.",
          "id": "0ce8152aa92136af039b687c01c7dccfcb271f3db2d0ddcb3cfdd3e6"
        },
        {
          "text": "Packete in Java dienen dazu meherer Operationen zusammenzufassen und für andere Packete bereitzustellen.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Um verschiedene Operationen zu speichern und in diversen Klassen auf diese verweisen zu können.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Pakete dienen zur Sammlung von Operationen auf die von Klassen dann schneller zugegriffen werden kann",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Speicherung von Klassen",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Sammeln zusammenhörige Klassen.",
          "id": "408f0afbe2440a4383a1e75b7d5b0b4202c7f7131a9acf9bd70492f3"
        },
        {
          "text": "um ganze klassen und cluster zurverfügung zu stellen",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Klassen, die auf verschiedene Operationen aufgeteilt werden können",
          "id": "271f93f45e9b4067327ed5c8cd30a034730aaace4382803c3e1d6c2f"
        },
        {
          "text": "Klassen zusammenzufassen, Sichtbarkeit zu kontrollieren",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Organisation und einfachere Versionsverwaltung des Quellcodes.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "Pakete bestehen aus mehreren Klassen, die im Normalfall miteinander zu tun haben. Sie können zum Beispiel untereinander auf protected variablen zugreifen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Weniger Programmieraufwand, weniger Speicherbedarf",
          "id": "53750c72b7bb26cb6ff7115e383ca150d5a632a909a7f79e2f5274a4"
        },
        {
          "text": "Bündelung zusammengehörender Klassen",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "l,l,,m",
          "id": "192f56eb9bd894a72b30c303247b107be2c4591f310dd69a67927f48"
        },
        {
          "text": "Klassen werden in Pakete gespeichert und koennen spaeter als ganzes in anderen Java-Programmen importiert werden.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Fassen mehrer Klassen zusammen. Innerhalb von können Werte und Operationen aus verschiedenen Klassen genutzt werden.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Pakete sind Sammlungen zusammengehörenden Klassen.",
          "id": "b51d18b551043c1f145f22dbde6f8531faeaf68c54ed9dd79ce24d17"
        },
        {
          "text": "Pakete bündeln eine Ansammlung von Klassen, die importiert und genutzt werden können.",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "Zusammenpacken von Klassen",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "..",
          "id": "ae8820303e493738a211ebb2ae3a2f90b286f20f767609beb77522c0"
        },
        {
          "text": "Klassen werden zu Paketen zusammengefasst. Ich weiß nicht genau. Hatten wir das in der Vorlesung?",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "Semanteische gruppierung von Klassen",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        }
      ]
    },
    {
      "text": "Wie werden Klassen in Java einem Paket zugeordnet?",
      "id": 50820,
      "title": "Paketzuordnung",
      "type": "procedure",
      "referenceAnswer": {
        "text": "Die Dateien der zum Paket zugehörigen Klassen müssen im selben Verzeichnis liegen und dem Paket mit der Anweisung 'package <Verzeichnispfad>' hinzugefügt werden.",
        "aspects": [
          {
            "text": "Die Dateien der zum Paket zugehörigen Klassen müssen im selben Verzeichnis liegen",
            "elements": [
              [
                0,
                91
              ]
            ]
          },
          {
            "text": "und dem Paket mit der Anweisung 'package <Verzeichnispfad>' hinzugefügt werden",
            "elements": [
              [
                92,
                160
              ]
            ]
          }
        ]
      },
      "answersAnnotation": [
        {
          "text": "Über den methodenkopf, public oder private bspw",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Die Klassen werden in einem Ordner gespeichert.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Durch den Befehl package.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "semantik",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "j",
          "id": "c1b8144ee1a30244a571c3d9b48b2c394a7489065d2565968f521645"
        },
        {
          "text": "Die Klasse muss in einem Verzeichnis sein, dass dem Paketnamen entspricht.",
          "id": "0ce8152aa92136af039b687c01c7dccfcb271f3db2d0ddcb3cfdd3e6"
        },
        {
          "text": "Klassen in Java werden zu einem Paket durch ihren Ordner zugeordnet.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "In dem sie in so einem Paket abgespeichert werden.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "mit der Definition package am Anfang des Codes.",
          "id": "408f0afbe2440a4383a1e75b7d5b0b4202c7f7131a9acf9bd70492f3"
        },
        {
          "text": "import",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Indem sie über den Pfad zugeordnet werden",
          "id": "271f93f45e9b4067327ed5c8cd30a034730aaace4382803c3e1d6c2f"
        },
        {
          "text": "paket.klasse.java",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Man packt diese in eine Datei, welche via package XY zu einem solchen zugehörig erklärt wurde.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "Dadurch in welchem Ordner sie gespeichert sind. Klassen im gleichen Ordner bilden ein Paket.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "package.NameDesPackets",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "l,l,",
          "id": "192f56eb9bd894a72b30c303247b107be2c4591f310dd69a67927f48"
        },
        {
          "text": "Das ist dann der jeweilige Ordnername.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Klassen müssen sich in einem Verzeichnis befinden, dass dem Namen des Pakets entspricht.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Um einen Klasse einem Paket zuzuordnen, muss die Klasse in einem Verzeichnis sein, das dem Paketnamen entspricht. In der Java Daten muss zu Beginn das Paket angegeben werden.",
          "id": "b51d18b551043c1f145f22dbde6f8531faeaf68c54ed9dd79ce24d17"
        },
        {
          "text": "ordner",
          "id": "ae8820303e493738a211ebb2ae3a2f90b286f20f767609beb77522c0"
        },
        {
          "text": "Mit dem Schlüsselwort package",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "Ein Verzeichnis packag'Dateipfad'",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "import dies.ist.mein.pakage.Klasse;",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        }
      ]
    },
    {
      "text": "Warum macht es Sinn eine Menge zu sortieren?",
      "simple": true,
      "id": 50884,
      "title": "Grund fürs Sortieren",
      "type": "reason",
      "referenceAnswer": {
        "text": "Das durchsuchen einer sortierten Menge ist deutlich schneller.",
        "aspects": [
          {
            "text": "Das durchsuchen einer sortierten Menge ist deutlich schneller",
            "elements": [
              [
                0,
                67
              ]
            ]
          }
        ]
      },
      "answersAnnotation": [
        {
          "text": "Viele andere Implementierungen sind dann wesentlich effizienter kürzer",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Eine sortierte Menge kann schneller durchsucht werden.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Um Elemente (leichter) finden zu können. Beispiele: Eintrag in Kundendatenbank, Wort in einer Schlüsselwortliste für Syntax Highlighting, IP-Adresse in  ARP-Tabelle.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Wenn man öfter auf diese Menge zugreift, kann die Laufzeit eines Algorithmus verkürzt werden.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Um die Daten übersichtlicher darzustellen und einfacher an gesuchte Daten zu gelangen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Um die Suche zu beschleunigen",
          "id": "7ba019a2553e1137a4bbb8d3c779a48e5ceb2ca3a162e6e0a945ef0f"
        },
        {
          "text": "Wenn eine Menge sortiert ist, ist es mit weniger Aufwand verbunden auf einzelne Daten zuzugreifen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Ist eine Menge sortiert, kann leichter ein Wert in ihr gesucht werden.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Dadurch kann die Laufzeit für die Suche eines bestimmten elements verkürzt werden",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Um einen besseren Überblick zu bekommen und weitere Operationen durchführen zu können.",
          "id": "0ce8152aa92136af039b687c01c7dccfcb271f3db2d0ddcb3cfdd3e6"
        },
        {
          "text": "Mit einer Sortierten Menge ist es einfacher zu Arbeiten. Zum Beispiel mit der binären Suche können Elemente viel schneller gesucht werden.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Um Suchen zu vereinfachen, für eine einfachere Dokumentation.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Einfacher etwas zu suchen",
          "id": "6332531eeafc6e0ede272192be898f549950fb32b209d04f0a98306a"
        },
        {
          "text": "Wenn eine Menge sortiert ist, ist es deutlich einfacher einzelne Elemente in der Menge zu finden",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Besserer Zugriff und bessere Übersicht. Außerdem ist dann die binäre Suche möglich.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Durch das sortieren kann eine Suche beschleunigt werden, da dann nicht alle Elemente durchlaufen werden müssen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Weil man dann mehr Informationen über das Inhalt hat und kann in der Menge z.B. viel effizienter suchen.",
          "id": "408f0afbe2440a4383a1e75b7d5b0b4202c7f7131a9acf9bd70492f3"
        },
        {
          "text": "verkürzung der laufzeit beim suchen",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Um schneller gesuchte Daten zu finden",
          "id": "271f93f45e9b4067327ed5c8cd30a034730aaace4382803c3e1d6c2f"
        },
        {
          "text": "Schnelleres finden der daten",
          "id": "c1b8144ee1a30244a571c3d9b48b2c394a7489065d2565968f521645"
        },
        {
          "text": "Möchte man eine Menge nach bestimmten Werten mithilfe der binären Suche durchsuchen, muss sie vorher sortiert sein.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "schneller suchen zugriff",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "Kürzere Laufzeit für Suche",
          "id": "53750c72b7bb26cb6ff7115e383ca150d5a632a909a7f79e2f5274a4"
        },
        {
          "text": "Wenn wir etwas suchen, geht es schneller",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "llmlm",
          "id": "192f56eb9bd894a72b30c303247b107be2c4591f310dd69a67927f48"
        },
        {
          "text": "Sie kann dann mit der binären Suche durchsucht werden, was deutlich schneller als die lineare Suche ist.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Damit wir Daten schneller finden koennen.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Auf einer sortierten Menge können verschieden Operationen (z.B. suchen) schneller durchgeführt werden.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Man sortiert eine Menge, um darin leichter bestimmte Elemente\\/Objekte zu finden",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Es macht es einfacher, dinge zu suchen.",
          "id": "8416c38cc898f1ac7cc9d64e89dab1f70f5ddab002a5b2a1713f93f5"
        },
        {
          "text": "Somit wird die Suche eines Elementes um einiges erleichtert und verschnellert.",
          "id": "b51d18b551043c1f145f22dbde6f8531faeaf68c54ed9dd79ce24d17"
        },
        {
          "text": "In einer sortieren Menge findet man bestimmte Einträge viel schneller und leichter.",
          "id": "f09265efb456b0336079ad5b238daa1e38a11b1d71cc0e1a4e8edd56"
        },
        {
          "text": "um ggf. schneller an einzelne Werte zu kommen.",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "ordnung",
          "id": "ae8820303e493738a211ebb2ae3a2f90b286f20f767609beb77522c0"
        },
        {
          "text": "Sortierte Mengen sind leichter zu durchsuchen.",
          "id": "b8607e0369fbf3e33bc0e358f840915d8c085d1496097351913c0122"
        },
        {
          "text": "In einer sortierten Menge kann man leichter suchen.",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "Um gesuchte Einträge schneller zu finden",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "Suche ist schneller und leichter",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "so ist es leichter ein Element zu finden",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        }
      ]
    },
    {
      "text": "Was ist die Idee von SelectionSort?",
      "id": 50885,
      "title": "Idee von SelectionSort",
      "type": "description",
      "referenceAnswer": {
        "text": "Die Idee ist iterativ das größte Element aus dem aktuellen Array auszusortieren.",
        "aspects": [
          {
            "text": "Die Idee ist iterativ das größte Element aus dem aktuellen Array auszusortieren",
            "elements": [
              [
                0,
                79
              ]
            ]
          }
        ]
      },
      "answersAnnotation": [
        {
          "text": "Bei jedem druchlauf den größten\\/kleinsten wert ans ende bringen und die länge um eins verkürzen bis die länge nur noch eins ist",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Es wird das erste Element als Minimum angenommen, dass Array wird durchlaufen und es wird nach einer kleineren Zahl gesucht. Wurde eine gefunden, wird der Index gespeichert und das Array wird weiter durchlaufen. Wenn der Durchlauf beendet ist, wird die erste Zahl mit der kleinsten Zahl getauscht. Danach wird das nächste Element als kleintes angeommen und der Durchlauf startet von vorne!",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Anfangsstück des Arrays ist sortiert, Rest nicht. Zu Beginn ist der Rest das ganze Array. Suche das kleinste Element von Rest und hänge es an den Anfang an. Wiederhole bis Rest leer.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Eine Menge wird sortiert, indem jedes Element mit dem Nachbarn verglichen wird. Das Größere wird zum Maximum und dann bis zum Ende verschoben. Der Vorgang wiederholt sich für jedes andere Element.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Zunächst wird der größte Wert im Array gesucht und dieser tauscht anschließend mit dem letzten Wert den Platz. Dann wird der zweigrößte Wert gesucht, welcher mit dem vorletzten Element den Platz tauscht. Dies macht man solange, bis das Array sortiert ist.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Das Array wird von links nach rechts durchlaufen, dabei werden immer das linke und rechte Element miteinander verglichen. Das kleinste Element wird sich gemerkt. Jetzt wird das Array weiter bis zum Ende durchlaufen, dabei wird immer mit dem gemerkten kleinsten Element verglichen. Ist ein Element noch kleiner ist dies nun das neue kleinste Element. Wurde nun das Array bis zum Ende durchlaufen wird das kleinste Element an den Anfang getauscht. Und der Vorgang startet vom neuem, bis alle Elemente sortiert sind. Dabei wird der sortierte Anfang nicht weiter beachtet.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Man sucht das kleinste Element der unsortierten Elemente und packt es rechts neben das zuvor kleinste.",
          "id": "7ba019a2553e1137a4bbb8d3c779a48e5ceb2ca3a162e6e0a945ef0f"
        },
        {
          "text": "Es wird für jede Position geguckt, welcher Wert da hingehört.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Die Datenmenge wird von vorne bis hinten durchlaufen und das bislang größte Element in einem extra Speicher aufbewahrt. und anschließend mit dem letzten Element getauscht. Dann wird die Datenmenge wieder durchgelaufen, aber nur bis zum vorletzten Element, wohin das größte Element von dieser Runde getauscht wird. usw bis Datenmenge nur 1 element groß",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Man vergleicht einen Wert mit jedem aus der zu sortierenden Menge und reiht ihn dann an seinen richtigen Platz ein.",
          "id": "0ce8152aa92136af039b687c01c7dccfcb271f3db2d0ddcb3cfdd3e6"
        },
        {
          "text": "SelectionSort sucht bei jedem Schritt das kleinste bzw. größte Element einer Menge und nimmt diese heraus und wiederholt dies solange bis die Menge sortiert ist.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Pro Durchgang wird aus der betrachteten Menge das Maximum gesucht und dann an die letzte Stelle der Menge gestellt, dann wird die Menge bis auf die letzte Stelle betrachtet, und es wird wieder das nächste Maximum gesucht.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Man sucht immer den größten Wert und packt ihn ans Ende",
          "id": "6332531eeafc6e0ede272192be898f549950fb32b209d04f0a98306a"
        },
        {
          "text": "bei Selection Sort wird in jedem Durchlauf das jeweils kleinste, bzw. größte Element gesucht und dann entweder an den Anfang oder das Ende des zu sortierenden Arrays gestellt. Im nächsten Durchlauf wird wieder das kleinste\\/ größte Element außer dem vorherigen gesucht und auch dieses wieder an den Anfang bzw ans Ende gestellt",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "SelectionSort korrigiert Fehlstellungen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Die Menge durchzugehen und den größten Mitglied aufs Ende zu stellen. Dann in der Menge ohne den größten Mitglied das Gleiche zu machen und so weiter, bis die ganze Menge komplett sortiert ist.",
          "id": "408f0afbe2440a4383a1e75b7d5b0b4202c7f7131a9acf9bd70492f3"
        },
        {
          "text": "Das array nach dem maximum absuchen und dieses ans ende fügen. Jede runde durchlauf um  1 verkürzt",
          "id": "c1b8144ee1a30244a571c3d9b48b2c394a7489065d2565968f521645"
        },
        {
          "text": "In jedem Durchlauf wird das größte (oder kleinste) Element gesucht, um es an das Ende (oder Anfang) des Arrays zu verschieben. Der nächste Durchlauf endet ein Element früher (oder beginnt ein Element später).",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "vergleiche erstes element mit allen anderen, tasusche wenn erstes kleiner, für alle elemente",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "wir gehen von vorne bis hinten durch die zahlen und vergleichen alle elemente miteinander und setzten das höchste ans ende",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "ll,",
          "id": "192f56eb9bd894a72b30c303247b107be2c4591f310dd69a67927f48"
        },
        {
          "text": "Das (Teil-)Array wird durchlaufen um das Maximum zu finden. Dieses wird dann ans Ende des (Teil-)Arrays verschoben. Dann wird das Gleiche mit dem Teilarray ohne den letzten Eintrag gemacht. Das Ganze wird so oft gemacht bis das  verbleibende Teilarray leer ist.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "SelectionSort macht sich das Prinzip der Maximum-Suche oder auch Minimum-Suche und schiebt das Element entweder nach ganz vorne oder nach ganz hinten.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Eine Menge wird mehrmals durchlaufen, wobei immer das Maximum gesucht wird und ans Ende gestellt wird. (Die zudruchlaufende Menge verkürzt sich also nach jedem durchlauf um eins.)",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Man geht ein (unsortiertes) Array durch. Man sucht sich den größten Wert raus und tauscht ihn an die letzte Stelle. Dann sucht man den zweitgrößten Wert und tauscht diesen an die vorletzte Stelle und so weiter. Absteigend Sortieren verläuft analog.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Wir gehen davon aus das unser erstes Element das Minimum ist. 1. Wir vergleichen das Minimum mit allen anderen Elementen. 2. Wenn wir ein kleineres Element finden wir dieses zum Minimum. 3. Wir wiederholen schritt 1-2 bis kein kleineres Element gefunden wird. Das Minimum wird an Stelle unseres aller ersten Minimums gesetzt. 4. Wir gehen an die zweite Stelle und wiederholen schritt 1-3",
          "id": "b51d18b551043c1f145f22dbde6f8531faeaf68c54ed9dd79ce24d17"
        },
        {
          "text": "Es wird die Menge durchgelaufen, nach dem Maximum gesucht und dieses ans Ende getauscht. Danach wird das Ende eins nach vorn gesetzt und das ganze wiederholt",
          "id": "8416c38cc898f1ac7cc9d64e89dab1f70f5ddab002a5b2a1713f93f5"
        },
        {
          "text": "es wird ein array nach dem maximun dursucht dieses ans ende gesetzt und dann der zweitgrößte Wert gesucht, dadurch wird das array für jeden Wert einmal durchlaufen",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "Immer das größte element der unsortierten menge an das ende der unsortierten menge packen",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Man nehme das größte objekt einer me nge und bringt es nach hinten und so macht man weiter",
          "id": "ae8820303e493738a211ebb2ae3a2f90b286f20f767609beb77522c0"
        },
        {
          "text": "Es wird jeweils das Maximum gesucht und aussortiert.",
          "id": "b8607e0369fbf3e33bc0e358f840915d8c085d1496097351913c0122"
        },
        {
          "text": "durch Vergleich mit jedem Element der Menge wird das Maximum gefunden, Das bislang gefundene Maximum wird markiert (wie merken uns den Index im Array), solange keine andere Zahl gefunden wird, die größer ist. Wenn wir am Ende angelangt sind, wird das Maximum ans Ende des Arrays getauscht. Wir fangen von vorne an und vergleichen bis zum vorletzten Element des Arrays. Die Laufzeit ist immer O(n^2), weil im Algorithmus nicht festgestellt wird, wenn das Array schon sortiert ist.",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "Das ganze Array durchgehen um das größte\\/kleinste Element zu finden und mit der letzen\\/ersten unsortierte Stelle tauschen",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "Finde das größte Objekt und tausche es an das Ende, wiederhole für zweitgrößtes und n-1",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Das Maximum im jeweiligen Bereich wird gesucht und sich gemerkt",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Die Idee von SelectionSort ist systematisch Nachbartausche durchzuführen bis die Fehlstellung gleich null ist.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        }
      ]
    },
    {
      "text": "Was macht SelectionSort so ineffizient?",
      "id": 50886,
      "title": "Ineffizienz von SelectionSort",
      "type": "reason",
      "referenceAnswer": {
        "text": "Die für die Bestimmung des größten Elementes gemachten Vergleiche werden nicht wiederverwendet.",
        "aspects": [
          {
            "text": "Die für die Bestimmung des größten Elementes gemachten Vergleiche werden nicht wiederverwendet",
            "elements": [
              [
                0,
                94
              ]
            ]
          }
        ]
      },
      "answersAnnotation": [
        {
          "text": "Es werden nur wenig der gewonnen Daten verwendet",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Für jeden Durchlauf müssen alle Elemente im unsortierten Bereich verglichen werden",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Bei jedem Suchen eines größten (kleinsten) Elementes müssen alle verbleibenden verglichen werden.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Zu viele Vergleiche bzw. Durchläufe der Menge.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "SelectionSort vergleicht viele Werte, nutzt die meisten davon aber nicht. Pro Durchlauf wird nur eine Fehlstelle korrigiert.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Der Anzahl an Elementen einsprechend häufig muss das Array durchlaufen werden.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Es muss jedes Mal der gesamte Array durchlaufen werden.",
          "id": "7ba019a2553e1137a4bbb8d3c779a48e5ceb2ca3a162e6e0a945ef0f"
        },
        {
          "text": "Es werden jede Positionen immer durchgegangen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Es sind sehr viele Nachbartausche notwendig.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Man macht keinen Nachbarvergleich und behandelt die Fehlstellungen nicht",
          "id": "6e680aa34a6a42a1b26318a46ede5692ed07ca9d850a34c462d23006"
        },
        {
          "text": "SelectionSort braucht die gleiche Laufzeit für ein sortiertes array wie für ein unsortiertes, weil es nicht früher abbricht, sondern den Algorithmus für alle stellen des arrays durchführt.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Man nutzt die Information, die man durch jeden Vergleich erhält, nicht weiter, sondern kümmert sich immer nur um ein Element.",
          "id": "0ce8152aa92136af039b687c01c7dccfcb271f3db2d0ddcb3cfdd3e6"
        },
        {
          "text": "Die gewonnenen Informationen der Vergleiche werden nicht effizient genutzt.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Die Menge wird in jedem Durchgang immer komplett durchgegangen und es gibt keine gesonderte Abbruchbedingung, außer wenn die Menge einmal komplett durchlaufen wurde.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Man muss das Array im schlechtesten Fall zweimal durchlaufen",
          "id": "6332531eeafc6e0ede272192be898f549950fb32b209d04f0a98306a"
        },
        {
          "text": "SelectionSort ist ineffizient da es immer wieder alle Elemente durchgeht und die Elemente bei jedem Durchgang nur um eins verringert werden",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Es hat IMMER die Laufzeit O(n\\u00b2).",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Währen des Durchlaufs werden keine Informationen gespeichert.",
          "id": "408f0afbe2440a4383a1e75b7d5b0b4202c7f7131a9acf9bd70492f3"
        },
        {
          "text": "Dauert lange",
          "id": "271f93f45e9b4067327ed5c8cd30a034730aaace4382803c3e1d6c2f"
        },
        {
          "text": "Informationen, die man beim itarieren bekommt. Werden nicht genutzt. Jede Runde wir nur ein Element verändert, läuft demenstprechend immer gleich lang, egal wie die ursprüngliche Reihenfolge war.",
          "id": "c1b8144ee1a30244a571c3d9b48b2c394a7489065d2565968f521645"
        },
        {
          "text": "Vergleiche aus den einzelnen Durchgängen werden sofort wieder vergessen",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "l,l,",
          "id": "192f56eb9bd894a72b30c303247b107be2c4591f310dd69a67927f48"
        },
        {
          "text": "Jedes Teilarray muss komplett durchlaufen werden um das Maximum zu finden und daher müssen sehr viele Einträge geprüft werden.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Die Laufzeit beträgt zu jeder Zeit O(n\\u00b2).",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Viele Vergleiche mit wenig gespeicherten Erkenntnissen.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Dass sich keine Informationen gemerkt werden, außer der aktuell größte Wert. Damit muss man in jedem Durchlauf Vergleiche machen, die man hätte umgehen können, wenn während der ersten Durchläufe Informationen gesammelt hätte. Außerdem erkennt SelectionSort nicht, wenn ein sortiertes Array vorliegt.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Wir vergleichen jedes Element mit jedem, auch wenn die Datenstruktur vorsortiert ist.",
          "id": "b51d18b551043c1f145f22dbde6f8531faeaf68c54ed9dd79ce24d17"
        },
        {
          "text": "Jedes Mal muss das größte Element erneut gesucht werden, weil bei jedem Durchgang sich nur das aktuelle Element gemerkt wird",
          "id": "8416c38cc898f1ac7cc9d64e89dab1f70f5ddab002a5b2a1713f93f5"
        },
        {
          "text": "alle elemente werden miteinander verglichen, in jedem fall eine Laufzeit von O(n^2) die gamachten verglecihe werden nicht wieder verwendet",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "dass das Array für jeden Wert einmal durchlaufen wird und zwischenergebnisse nicht genutzt werden",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "Das wir selbst bei einer sortierten reihe einmal jeden durchlauf machen müssen",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Seeeeeehr viele Vergleiche",
          "id": "ae8820303e493738a211ebb2ae3a2f90b286f20f767609beb77522c0"
        },
        {
          "text": "Vergleiche werden nicht mehrfach verwendet.",
          "id": "b8607e0369fbf3e33bc0e358f840915d8c085d1496097351913c0122"
        },
        {
          "text": "Für jedes Element des Arrays wird mit jedem verglichen. Der Algorithmus merkt nicht, ob das Array schon sortiert ist.",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "Bei jedem durchlauf muss jeder Eintrag verglichen werden.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "Das Wissen aus den Vergleichen geht verloren",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Die Vergleichsergebnisse werden sich nicht gemerkt",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        }
      ]
    },
    {
      "text": "Was ist die gemeinsame Grundidee von Sortierverfahren die auf Nachbartäuschen basieren?",
      "id": 50887,
      "title": "Sortieren von Nachbarn",
      "type": "description",
      "referenceAnswer": {
        "text": "Die Sortierverfahren beruhen darauf Fehlstellungen von benachbarte Elemente zu korrigieren.",
        "aspects": [
          {
            "text": "Die Sortierverfahren beruhen darauf Fehlstellungen von benachbarte Elemente zu korrigieren",
            "elements": [
              [
                0,
                90
              ]
            ]
          }
        ]
      },
      "answersAnnotation": [
        {
          "text": "Mit jedem Tausch wird das Array etwas sortierter",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Die Sortierverfahren beruhen darauf benachbarte Elemente zu vergleichen und Fehlstellungen zu korrigieren. Das Array wird so lange durchlaufen, bis alle Nachbarn richtig sortiert sind.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Es werden Fehlstellungen korrigiert.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Bei jedem Tausch das Array sortierter bekommen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Keine unnötigen Wege zu gehen.",
          "id": "7ba019a2553e1137a4bbb8d3c779a48e5ceb2ca3a162e6e0a945ef0f"
        },
        {
          "text": "Es wird entweder das größte oder kleinste Element gesucht und an die richtige Stelle im Array gebracht. Dann wird mit dem nächst kleineren bzw größeren fortgefahren.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "fehlstellungen korrigieren bis es keine mehr gibt",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Man nutzt jeden Vergleich.",
          "id": "0ce8152aa92136af039b687c01c7dccfcb271f3db2d0ddcb3cfdd3e6"
        },
        {
          "text": "Die gemeinsame Grundidee ist die Anzahl der Vertauschten Elementen zu reduzieren.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Das jeder Vergleich einen nachhaltigen Unterschied macht und nicht mehrmals durchgeführt werden muss.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "es wird immer das aktuelle Element mit dem vorherigen oder nachfolgenden verglichen",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Fehlstellungen sollen korrigiert werden bis es keine mehr gibt.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Die Nachbarn zu vergleichen und in die richtige Reihenfolge zu bringen.",
          "id": "408f0afbe2440a4383a1e75b7d5b0b4202c7f7131a9acf9bd70492f3"
        },
        {
          "text": "Dass jeder den Wert des Nachbarn kennt und so in Abhängigkeit dazu tauschen kann",
          "id": "271f93f45e9b4067327ed5c8cd30a034730aaace4382803c3e1d6c2f"
        },
        {
          "text": "Die Informationen die man beim Durchlaufen des Arrays verwenden, um schneller zu sortieren",
          "id": "c1b8144ee1a30244a571c3d9b48b2c394a7489065d2565968f521645"
        },
        {
          "text": "Mit jedem Tausch wird eine Fehlstellung im Array eliminiert",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "kmkm",
          "id": "192f56eb9bd894a72b30c303247b107be2c4591f310dd69a67927f48"
        },
        {
          "text": "Dass bei angestrebter aufsteigender Sortierung größere Einträge dazu tendieren nach oben zu wandern und Kleinere nach unten.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Das die Laufzeit sich gegenueber von SelectionSort verbessern kann.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Jedes verbessern einer Fehlstellung bringt uns einen Schritt näher zum sortierten Array.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Dass man einzelne Werte nach und nach an die richtige Position tauscht.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Nacheinander werden zwei aufeinanderfolgende Elemente im Array miteinander verglichen und eventuell getauscht. Solange bis kein Tausch mehr durchgeführt wird.",
          "id": "b51d18b551043c1f145f22dbde6f8531faeaf68c54ed9dd79ce24d17"
        },
        {
          "text": "Die Grundidee ict es, Fehlstellungen zu korrigieren.",
          "id": "8416c38cc898f1ac7cc9d64e89dab1f70f5ddab002a5b2a1713f93f5"
        },
        {
          "text": "Wir gehen das Array  durch und vergleichen die nachbarn",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "man will das durchlaufen eines arrays reduzieren",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "Fehlstellungen zu finden",
          "id": "ae8820303e493738a211ebb2ae3a2f90b286f20f767609beb77522c0"
        },
        {
          "text": "Es werden jeweils benachbarte Elemente verglichen und im Falle einer Fehlstellung getauscht. Dies geschieht solange, bis keine Fehlstellungen mehr vorhanden sind.",
          "id": "b8607e0369fbf3e33bc0e358f840915d8c085d1496097351913c0122"
        },
        {
          "text": "Es sollen Fehlstellungen repariert werden.",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "Weniger Vergleiche zu benötigen",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "Korigieren von Fehlstellungen wiederholen, bis keine mehr existieren",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Man vergleicht Element um das größte Element zu finden",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        }
      ]
    },
    {
      "text": "Warum sind Sortierverfahren die darauf beruhen Fehlstellungen von Nachbarn zu beheben im best-case besser als n*log(n)?",
      "id": 50888,
      "title": "BubbleSort",
      "type": "reason",
      "referenceAnswer": {
        "text": "Bei einem sortierten Array gibt es keine Fehlstellungen. Das Array muss deshalb nur einmal durchlaufen werden.",
        "aspects": [
          {
            "text": "Bei einem sortierten Array gibt es keine Fehlstellungen",
            "elements": [
              [
                0,
                55
              ]
            ]
          },
          {
            "text": "Das Array muss deshalb nur einmal durchlaufen werden",
            "elements": [
              [
                57,
                109
              ]
            ]
          }
        ]
      },
      "answersAnnotation": [
        {
          "text": "Best case: Schon sortiert. Nach n-1 Vergleichen ist man dann fertig.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Weil ein sortiertes Array nur genau n Vergleiche und somit eine Laufzeit von O(n) benötigt.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Im Best-Case ist das Array schon sortiert. Der Algorithmus kann abbrechen, wenn das Array einmal durchgegangen wurde. Damit ist die Laufzeit n.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Da viele Fehlstellung bereits beim ersten Durchlauf korrigiert werden.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Weil im best case die Laufzeit n ist, da nur einmal durchgelaufen werden muss.",
          "id": "7ba019a2553e1137a4bbb8d3c779a48e5ceb2ca3a162e6e0a945ef0f"
        },
        {
          "text": "Da sie im best-case nur das Array durchlaufen und alle Nachbarn einmal vergleichen, also eine Laufzeit von O(n) haben.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Das array wird nur einmal durchgelaufen dh die Laufzeit ist n",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Weil im besten Fall das Array schon vorsortiert ist und nur einmal durchlaufen werden muss (um festzustellen dass jede einzelne Position passt).",
          "id": "0ce8152aa92136af039b687c01c7dccfcb271f3db2d0ddcb3cfdd3e6"
        },
        {
          "text": "Falls die Menge vorsortiert ist, wird dies durch ein einmaliges durchlaufen sofort festgestellt.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Weil sie dann in einem bereits sortierten Array nur die Laufzeit O(n) benötigen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Weil in dem best-case, d.h. wenn das Array schon vorsortiert war, laufen sie nur einmal durch. Wenn richtig implementiert, kommt ein One-Way-Flag - nichts zu tauschen - und der Algorithmus ist fertig. O(n)",
          "id": "408f0afbe2440a4383a1e75b7d5b0b4202c7f7131a9acf9bd70492f3"
        },
        {
          "text": "dann ist es schon sortiert",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Weil das Array so immer in geordneterer Reihenfolge auftaucht",
          "id": "271f93f45e9b4067327ed5c8cd30a034730aaace4382803c3e1d6c2f"
        },
        {
          "text": "im best case liegt das array bereits sortiert vor und muss deshalb nur einmal durchlaufen werden",
          "id": "c1b8144ee1a30244a571c3d9b48b2c394a7489065d2565968f521645"
        },
        {
          "text": "Bei vorsortierten Arrays muss das Array nur einmal durchlaufen werden. Daher O(n)",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "kjkjk",
          "id": "192f56eb9bd894a72b30c303247b107be2c4591f310dd69a67927f48"
        },
        {
          "text": "Weil sie, wenn alles schon sortiert ist nicht korrigieren müssen, d.h. sie müssen nur einmal das Array durchlaufen, was O(n) benötigt.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Weil das Array im besten Fall nur einmal durchlaufen werden muss.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Solche Verahren werden abgebrochen, wenn kein Tausch durchgeführt wurde. Wenn das Array sortiert war, passiert das in der Zeit n.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Weil sie nur einmal das Array durchlaufen und sofort erkennen (außer unoptimiertes SelectionSort), wenn im gesamten Array keine Fehlstellung vorliegt. Die Laufzeit beträgt dann O(n).",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Weil din dem Fall das Array im Best case vorsortiert ist, es also keine Fehlstellung gibt, die man beheben muss",
          "id": "8416c38cc898f1ac7cc9d64e89dab1f70f5ddab002a5b2a1713f93f5"
        },
        {
          "text": "das Array muss wenn es vorsortiert ist nur einmal durchlaufen werden",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Weil im besten Fall schon eine sortierte Menge vorliegt und die Menge nur einmal durchlaufen werden muss um herauszufinden dass keine Fehlstellung vorliegt.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "weil im Best Case, nur maximal ein durchlauf nötig isst und somit nur O(n)",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "Bei sortierten daten brauch man nur 1 durchlauf",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Vergleichsbasierend",
          "id": "ae8820303e493738a211ebb2ae3a2f90b286f20f767609beb77522c0"
        },
        {
          "text": "Im besten Fall muss der Datensatz nur einmal durchlaufen werden (O(n)).",
          "id": "b8607e0369fbf3e33bc0e358f840915d8c085d1496097351913c0122"
        },
        {
          "text": "Der best case ist, wenn das Array bereits sortiert ist. Dann werden n Vergleiche gemacht und kein Mal getauscht. Der Algorithmus bricht ab, wenn nict getauscht wurde in einem Durchgang.",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "Da ein bereits richtig sortiertes Array in einem Durchlauf abgearbeitet werden kann",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "Nur ein Durchlauf erforderlich, wenn das Array bereits sortiert ist",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Da dass Array nur einmal durchlaufen werden muss",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        }
      ]
    },
    {
      "text": "Was ist die Idee von Heapsort?",
      "id": 50889,
      "title": "Idee HeapSort",
      "type": "description",
      "referenceAnswer": {
        "text": "Die Grundidee ist es die durch Vergleiche erlangten Informationen in einem Binärbaum zu speichern. Die Elemente werden so in den Baum übertragen, dass der Vater größer ist als seine Söhne. Das größte Element befindet sich somit in der Wurzel. Es wird iterativ entfernt und der Baum wird wiederhergestellt.",
        "aspects": [
          {
            "text": "Die Grundidee ist es die durch Vergleiche erlangten Informationen in einem Binärbaum zu speichern",
            "elements": [
              [
                0,
                97
              ]
            ]
          },
          {
            "text": "Die Elemente werden so in den Baum übertragen, dass der Vater größer ist als seine Söhne",
            "elements": [
              [
                99,
                187
              ]
            ]
          },
          {
            "text": "Das größte Element befindet sich somit in der Wurzel",
            "elements": [
              [
                189,
                241
              ]
            ]
          },
          {
            "text": "Es wird iterativ entfernt und der Baum wird wiederhergestellt",
            "elements": [
              [
                243,
                304
              ]
            ]
          }
        ]
      },
      "answersAnnotation": [
        {
          "text": "Möglichst viele der gewonnen Daten zu verwenden, es wird ein Binärbaum konstruiert",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Ein Binärbaum wird erstellt, das Maximum\\/Minimum wird zum 0. Knoten, darunter sind die jeweiligen Kinder, welche aufsteigend bis zum 0. Knoten sortiert werden, danach wird dieser abgeschnitten.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Man strukturiert die Vergleiche so, dass eine Veränderung möglichste viele Informationen erhält.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "In einem Binärbaum wird der Vater als größeres Element mit seinen kleineren Kindern dargestellt.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "DIe Elemente werden in einem binärbaum dargestellt und nacheinander ausgelesen.",
          "id": "7ba019a2553e1137a4bbb8d3c779a48e5ceb2ca3a162e6e0a945ef0f"
        },
        {
          "text": "Mit einem Binärbaum suchen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Man interpretiert die Daten in einem Baum. Mit heapify() wird dieser zu einem Heap gemacht und die Wurzel entfernt. Durch eine weitere Anwendung von heapify() wird der Baum wieder zu einem heap gemacht.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Alle Vergleiche werden genutzt. Die Beziehung des Vaters zu seinen Kindern ist stets, dass der Vater größer als seine Kinder ist. Das Maximum ist die Wurzel d.h. immer bekannt in einem Heap. Die Wurzel wird abgeschnitten und in ein Array gepackt, anschließend das letzte Blatt an den Platz der Wurzel gesetzt und der Baum wird zu einem Heap repariert, woraufhin das Maximum wieder bekannt ist und wieder abgeschnitten werden kann...",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Heapsort schreibt alle Positionen eines Arrays in einen Baum, wo immer die Wurzel den größten Wert hat und immer die Wurzel eines Teilbaums den größten Wert des Teilbaums.",
          "id": "0ce8152aa92136af039b687c01c7dccfcb271f3db2d0ddcb3cfdd3e6"
        },
        {
          "text": "Bei dem Heapsort wird zunächst aus der gegebenen Menge ein heap erstellt. Bei dem Heap ist die Wurzel das größte Element. Nun nimmt man die Wurzel hinaus und setzt das letzte Element des Heaps als neue Wurzel und stellt erneut den heap durch heapify wieder her. Dies wird solange wiederholt bis der heap leer ist.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Die Menge wird als ein Heap betrachtet, bei dem der Vater immer größer als seine Kinder ist. Dann entspricht die Wurzel immer dem Maximum und dieses kann mehrmals herausgelesen werden.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "die Idee ist das in einem Heap alles unter einem Knoten sortiert ist",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Ein Array als Baum zu definieren und dann die größten Elemente sortiert in ein neues Array zu übertragen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Das Array als Binärbaum zu betrachten und den so zu sortieren, dass Vater größer als jedes Kind ist.",
          "id": "408f0afbe2440a4383a1e75b7d5b0b4202c7f7131a9acf9bd70492f3"
        },
        {
          "text": "Suchen in form von bäumen",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "die idee ist es, das array in einen binärbaum zu sortieren, der voraussetzt, dass der Knoten immer größer als die Kinder ist. Mit dieser Information kann man immer die Wurzel rausziehen und nach und nach den Heap abbauen",
          "id": "c1b8144ee1a30244a571c3d9b48b2c394a7489065d2565968f521645"
        },
        {
          "text": "Die zu sortierenden Elemente werden in einem Binärbaum angeordnet und mithilfe der Operation heapify () sortiert",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "kjk",
          "id": "192f56eb9bd894a72b30c303247b107be2c4591f310dd69a67927f48"
        },
        {
          "text": "Das Array wird in einen Binärbaum mit der Eigenschaft, dass alle Väter größer als ihre Kinder sind, umgewandelt. Dadurch ist die Wurzel der größte Eintrag. Diese wird rausgenommen, das letzte Blatt hochgetauscht und dann wird das Ganze mit dem verbleibenden Teilarray gemacht.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Ein Binärbaum mit Vater-Kind-Beziehung.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Ein Array wird als binärer Baum interpretiert, der die Heapbedingung erfüllt. Die Maximumssuche kann jetzt n mal in der Zeit logn  durchgeführt werden.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Ein Array wird als Binärbaum interpretiert, wodurch man bei jedem Vergleich Informationen speichert und somit wiederverwerten kann.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Die Elemente werden in einem Binärbaum angeordnet. Der Vater ist hierbei immer größer als die Kinder. Um diese Bedingung zu erfüllen muss heapify auf jeder der Teilbäume angewendet werden.",
          "id": "b51d18b551043c1f145f22dbde6f8531faeaf68c54ed9dd79ce24d17"
        },
        {
          "text": "Die Elemente werden so in einem Binärbaum arrangiert, dass eine Kante immer einen Vergleich zwischen zwei Elementen darstellt, bei welchem der Vater das größere Element ist. Die so gespeicherten Vergleichsinformationen verschnellern die Suche nach dem größten Element.",
          "id": "8416c38cc898f1ac7cc9d64e89dab1f70f5ddab002a5b2a1713f93f5"
        },
        {
          "text": "Wir bauen einen Binärbaum wo der Vater größer ist als seine Kinder (Heap) und ersetzen die Wurzel (das größte Element ) immer mit einem Blatt und tauschen dann durch bis die Heapbedinngung wieder erfüllt ist",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "heapsort nutzt einen Baum um die Werte zu speichern mit der Bedingung Kinder sind kleiner als Eltern",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "Ein Baum verwenden um so immer den größten ans ende zu packen",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Baum",
          "id": "ae8820303e493738a211ebb2ae3a2f90b286f20f767609beb77522c0"
        },
        {
          "text": "Die Menge wird als Baum darestellt. Die Kanten bilden dabei jeweils Vergleiche, wobei der Knoten jeweils Größer als seine Kinder ist.",
          "id": "b8607e0369fbf3e33bc0e358f840915d8c085d1496097351913c0122"
        },
        {
          "text": "Wir interpretieren das Array als Baum, bei dem jeder Knoten im Wert größer ist als seine Kinder. Beim Aufbau eines Heaps merken wir uns an den Kanten die schon erfolgten Vergleiche und nutzen diese später wieder. Wenn der Heap aufgebaut ist, steht auf jeden Fall das größte Element in der Wurzel. Diese wird dann abgeschnitten und an die letzte Stelle im Array geschrieben. Das letzte Blatt (also der vorletzte Wert im Array) wird dann in die Wurzel geschrieben. Dann werden solange Täusche vorgenommen bis diese neue Zahl an der richtigen Stelle steht du somit der Baum wieder ein heap ist. dann steht wieder das größte Element in der Wurzel und kann ins zweitletzte Element des Arrays geschrieben werden.",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "Binärer Baum, Kanten repräsintieren Vergleiche, Vater größer als Kinder",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Ein binärer Baum, bei dem jeder Vater größer als seine beiden Kinder ist",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        }
      ]
    },
    {
      "text": "Welche Eigenschaften eines Heaps sind essentiell für das Sortieren?",
      "id": 50890,
      "title": "Eigenschaften eines Heaps",
      "type": "description",
      "referenceAnswer": {
        "text": "Der größte Wert aller Knoten in jedem Teilbaum ist in dessen Wurzel. Ein Heap besitzt eine maximale Tiefe von log(n).",
        "aspects": [
          {
            "text": "Der größte Wert aller Knoten in jedem Teilbaum ist in dessen Wurzel",
            "elements": [
              [
                0,
                97
              ]
            ]
          },
          {
            "text": "Ein Heap besitzt eine maximale Tiefe von log(n)",
            "elements": [
              [
                99,
                187
              ]
            ]
          }
        ]
      },
      "answersAnnotation": [
        {
          "text": "Der Vater ist größer als die Kinder",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Binärbaum, also nur zwei Kinder pro Vater.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Ein Heap ist ein Binärbaum, in dem jeder Vater größer oder gleich den Kindern ist.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Kinder sind kleiner als der Vater. Darstellung in einem Binärbaum. Wurzel ist das größte Element.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Die Väter sind größer als die Kinder",
          "id": "7ba019a2553e1137a4bbb8d3c779a48e5ceb2ca3a162e6e0a945ef0f"
        },
        {
          "text": "Die Eigenschaft, dass er ein Binärbaum ist, also jeder Vater nur zwei Kinder hat, und dass der Vater immer größer als die Kinder ist.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Der vater ist größer als das kind un ddas maximum ist die wurzel also bekannt!",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Dass die Wurzel jedes Teilbaums immer der größte Wert des Teilbaums ist.",
          "id": "0ce8152aa92136af039b687c01c7dccfcb271f3db2d0ddcb3cfdd3e6"
        },
        {
          "text": "Das größte Element des Heaps steht in der Wurzel.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Der Vater ist immer größer als seine Kinder, die Wurzel ist immer das Maximum.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "das jeder Teilbaum ein Heap ist",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Die Wurzel muss den größten Wert haben und die Kinder immer kleiner sein als ihre Väter.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Das linke Kind = 2i+1, das rechte Kind 2i+2, Vater (i-1)\\/2 ist größer als Kinder",
          "id": "408f0afbe2440a4383a1e75b7d5b0b4202c7f7131a9acf9bd70492f3"
        },
        {
          "text": "Dass der Vater und die Kinder bekannt sind",
          "id": "271f93f45e9b4067327ed5c8cd30a034730aaace4382803c3e1d6c2f"
        },
        {
          "text": "muss ein binärbaum mit tiefe log(n) sein und die Väter größer als ihre kinder.",
          "id": "c1b8144ee1a30244a571c3d9b48b2c394a7489065d2565968f521645"
        },
        {
          "text": "Die Wurzel ist das größte Element. Die Kindsknoten bzw. Blätter sind kleiner als der Vater.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "lm,lm",
          "id": "192f56eb9bd894a72b30c303247b107be2c4591f310dd69a67927f48"
        },
        {
          "text": "Dass der Vater größer ist als seine Kinder, dass nur die letzte Ebene (die Blätter) und evtl. ein Teil der vorletzten Ebene keine Kinder hat.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Die Vater-Kind-Beziehung",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Die Heapbedingung ist erfüllt, die Wurzel jedes Teilbaums ist größer als die Kinder.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Dass der Vater immer größer ist als seine Kinder, somit die Wurzel der größte Wert des gesamten Arrays ist.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Die Wurzel ist das Maximum",
          "id": "b51d18b551043c1f145f22dbde6f8531faeaf68c54ed9dd79ce24d17"
        },
        {
          "text": "Dass in der Wurzel immer das größte Element steht",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Die Bedingung dass die Kinder immer kleiner sind als die Eltern",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "Vater größer als Kinder",
          "id": "ae8820303e493738a211ebb2ae3a2f90b286f20f767609beb77522c0"
        },
        {
          "text": "Alle Ebenen bis auf die letzte müssen vollständig gefüllt sein.",
          "id": "b8607e0369fbf3e33bc0e358f840915d8c085d1496097351913c0122"
        },
        {
          "text": "Der Binärbaum muss vorsortiert sein",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "Für jeden Knoten gilt dass seine Kinder kleiner sind als er selbst. Wenn Kinder da sind.",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "Die Kanten stelllen einen Vergleich da, der Vater ist größer als seine beiden Kinder",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        }
      ]
    },
    {
      "text": "Wie muss ein Binärbaum strukturiert sein um ihn in einer Laufzeit von n*log(n) in einen Heap transformiert werden zu können? Die Binärbäume in den folgenden Aufgaben weisen stets diese Struktur auf.",
      "id": 50891,
      "title": "Struktur eines Heap",
      "type": "description",
      "referenceAnswer": {
        "text": "Alle Ebenen des Baumes, bis auf die letzte, müssen vollständig befüllt sein. Auf der vorletzten Ebene darf maximal ein Teilbaum nicht voll besetzt sein.",
        "aspects": [
          {
            "text": "Alle Ebenen des Baumes, bis auf die letzte, müssen vollständig befüllt sein",
            "elements": [
              [
                0,
                75
              ]
            ]
          },
          {
            "text": "Auf der vorletzten Ebene darf maximal ein Teilbaum nicht voll besetzt sein.",
            "elements": [
              [
                77,
                151
              ]
            ]
          }
        ]
      },
      "answersAnnotation": [
        {
          "text": "er muss sortiert sein der größte wert in der wurzel die kleinsten in den Blätter, es muss ein binärbaum sein",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Alle Ebenen des Baumes, bis auf die letzte, müssen vollständig befüllt sein. Die letzte Ebene muss vom linken Ende bis zum rechtesten Element vollständig befüllt sein.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Ein Knoten hat maximal zwei Kinder.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "geht das nicht bei jedem?",
          "id": "7ba019a2553e1137a4bbb8d3c779a48e5ceb2ca3a162e6e0a945ef0f"
        },
        {
          "text": "Er muss eine Tiefe von maximal n*log(n) haben.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "er muss die maximale tiefe log(n) haben. Alle möglichen Positionen sind besetzt. geringst mögliche tiefe. Jeder Vater hat zwangsläufig 2 kinder außer der letzte.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Er muss schon vorsortiert sein.",
          "id": "0ce8152aa92136af039b687c01c7dccfcb271f3db2d0ddcb3cfdd3e6"
        },
        {
          "text": "Der Binärbaum muss in den beiden Kindern der Wurzel Heaps besitzen.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Die Ebenen müssen soweit aufgefüllt werden, wie es möglich ist.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "unsortiert",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "darf nur 2 kinder haben, muss tiefe log(n) haben",
          "id": "c1b8144ee1a30244a571c3d9b48b2c394a7489065d2565968f521645"
        },
        {
          "text": "klkl",
          "id": "192f56eb9bd894a72b30c303247b107be2c4591f310dd69a67927f48"
        },
        {
          "text": "Egal wie.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Er muss konstanz gefüllt sein.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Wir füllen die Knoten von oben nach unten und von links nach rechts auf, anschließend überprüfen wir jeden Knoten, ob er die Bedinngungen erfüllt",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "geringe TIefe",
          "id": "ae8820303e493738a211ebb2ae3a2f90b286f20f767609beb77522c0"
        },
        {
          "text": "Er muss als Suchbaum strukturiert sein.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "Bis auf die letzte Ebene vollständig gefüllt, diese soweit wie möglich von links nach rechts gefüllt",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "alle Ebenen muss vollständig gefüllt sein",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        }
      ]
    },
    {
      "text": "Wie wird aus einem Binärbaum dessen beiden Teilbäume selber Heaps sind ein Heap erstellt? Wieso benötigt diese Operation eine log(n) Schritte?",
      "id": 50892,
      "title": "Heap reparieren",
      "type": "procedure",
      "referenceAnswer": {
        "text": "Das Element in der Wurzel tauscht immer wieder die Position mit dem größeren seiner Kinder bis der Heap wiederhergestellt ist. Der Binärbaum besitzt maximal log(n) Ebenen.",
        "aspects": [
          {
            "text": "Das Element in der Wurzel tauscht immer wieder die Position mit dem größeren seiner Kinder bis der Heap wiederhergestellt ist",
            "elements": [
              [
                0,
                125
              ]
            ]
          },
          {
            "text": "Der Binärbaum besitzt maximal log(n) Ebenen",
            "elements": [
              [
                127,
                170
              ]
            ]
          }
        ]
      },
      "answersAnnotation": [
        {
          "text": "das letzte (rechteste) Blatt wird die neue Wurzel und solange nach unten getauscht bis der heap wieder sortiert ist",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Das Element in der Wurzel tauscht immer wieder die Position mit dem größeren seiner Kinder, bis es selber wieder ein Blatt ist oder größer ist als beide Kinder. Der Binärbaum besitzt maximal log(n) Ebenen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Heapify auf die Teilbäume anwenden.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Das Letzte Blatt wird zur Wurzel und danach wird dieses mit dem jeweils größten Kind getauscht solange das Kinde größer ist. Die Laufzeit ergibt sich daraus, dass die Tiefe des Baumes maximal log(n) ist.",
          "id": "7ba019a2553e1137a4bbb8d3c779a48e5ceb2ca3a162e6e0a945ef0f"
        },
        {
          "text": "die zwei kinder werden verglichen und das größte der kinder wird mit dem vater getauscht wenn es größer als der vater ist. diese operation wird durchgeführt solange v kinder hat, dh es werden alle knoten auf der strecke auf der getausht wurde überprüft, bis man bei einem blatt ankommt. Die strecke bis man bei einem Blatt ankommt ist die tiefe eines baums, die maximal log(n ) ist. Dh es werden maximal log(n) tauschs durchgeführt.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Heapify wird auf jeden Knoten der Teilbäume angewandt. Weil man für jede Reparatur die Kanten entlang gehen muss, also dauert es die Tiefe des Baumes lang und die ist log(n).",
          "id": "0ce8152aa92136af039b687c01c7dccfcb271f3db2d0ddcb3cfdd3e6"
        },
        {
          "text": "Bei einem Binärbaum, dessen Teilbäume selber Heaps sind muss nur die Wurzel kontrolliert werden, dass für diese die Bedingung gilt.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Man tauscht die Wurzel mit dem größten Kind und wiederholt dies bis es größer ist als beide Kinder.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "heapify",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Weil log(n) ist die maximale Tiefe des Baumes. Die Wurzel (der Vater) wird mit beiden Kindern verglichen. Wenn kleiner, wird er mit dem größeren Kind vertauscht. und dann wieder mit den nächsten Kindern usw. bis die Kinder Blätter sind.",
          "id": "408f0afbe2440a4383a1e75b7d5b0b4202c7f7131a9acf9bd70492f3"
        },
        {
          "text": "Das größte Kind des obersten Knotens (bsp die Wurzel) wird mit dem Koten getauscht",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "die wurzel wird durch heapify mit dem größeren kind vertauscht, dadurch muss der komplette heap nochmals überprüft werden nach fehlstellungen",
          "id": "c1b8144ee1a30244a571c3d9b48b2c394a7489065d2565968f521645"
        },
        {
          "text": "mkm",
          "id": "192f56eb9bd894a72b30c303247b107be2c4591f310dd69a67927f48"
        },
        {
          "text": "Falls das größere Kind größer ist als der Vater werden diese getauscht. Das runtertauschen einer ungültigen Wurzel benötigt höchstens log(n) Schritte, weil es höchstens für jede Ebene einmal gemacht werden muss und der Baum log(n) viele Ebenen hat.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Es wird die Operation heapify() genutzt.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Die Wurzel muss mit den Kindern verglichen werden und möglicherweise, mit dem größeren getsucht werden. Dieser Schritt muss iterativ, logn mal passieren (entspricht der Tiefe des Tielbaums).",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Indem die Wurzel des Baumes die größten Kinder entlang nach unten wandert. Wenn oben einer der kleinsten Wert des ganzen Arrays stand, muss der Knoten die komplette Tiefe des Baumes nach unten wandern. Diese beträgt log(n).",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Wir wissen bereits, dass beide Teilbäume ein Heap sind. Nun muss sichergestellt werden, dass die Wurzel unser Maximum ist. Ist dies nicht der Fall muss die Reparatur durchgeführt werden und somit können wieder Fehler in den einzelnen Teilbäumen entstehen. Wir müssen nach der Änderung der Wurzel für den ganzen Baum kontrollieren ob jeder Teilbaum noch ein Heap ist. Dies benötigt eine Zeit von log n",
          "id": "b51d18b551043c1f145f22dbde6f8531faeaf68c54ed9dd79ce24d17"
        },
        {
          "text": "Max. Log(n) ebenen Die Wurzel wandert runter bis sie größer ist als ihre Kinder oder sie ein Blatt ist",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "es muss ein heapify durchgeführt werden, welcher sich ggf bis zu einem Blatt durchziehen kann",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "kp",
          "id": "ae8820303e493738a211ebb2ae3a2f90b286f20f767609beb77522c0"
        },
        {
          "text": "Das Element an der Wurzel wird mit dem letzten Kind getauscht. Dafür wird es immer wieder mit dem rechten Kind getauscht. D ein Baum log(n) Tiefe hat, benötigt die Operation log(n) Schritte.",
          "id": "b8607e0369fbf3e33bc0e358f840915d8c085d1496097351913c0122"
        },
        {
          "text": "Die heapify Funktion muss auf den Binärbaum angewendet werden.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "Die Wurzel wird durch sinnvolles Tauschen an die richtige Stelle gebracht. Immer am größten Kind entlang.",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        }
      ]
    },
    {
      "text": "Wie wird der initiale Heap aus einem Binärbaum erstellt?",
      "id": 50893,
      "title": "Heap Initiierung",
      "type": "procedure",
      "referenceAnswer": {
        "text": "Es wird in der vorletzten Ebene angefangen und in den Ebenen aufsteigend aus jedem Teilbaum des Binärbaumes ein Heap erstellt. Alle Blätter des Binärbaumes sind bereits Heaps und können ausgelassen werden.",
        "aspects": [
          {
            "text": "Es wird in der vorletzten Ebene angefangen und in den Ebenen aufsteigend aus jedem Teilbaum des Binärbaumes ein Heap erstellt",
            "elements": [
              [
                0,
                125
              ]
            ]
          },
          {
            "text": "Alle Blätter des Binärbaumes sind bereits Heaps und können ausgelassen werden",
            "elements": [
              [
                127,
                204
              ]
            ]
          }
        ]
      },
      "answersAnnotation": [
        {
          "text": "die ebenen werden beginnend mit der wurzel von links nach rechts aufgefüllt",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Von links nach rechts werden die Elemente aus dem Array in den Binärbaum eingetragen. Die erste Zahl ist also die Wurzel und anschließend werden der Reihe nach alle Ebenen gefüllt.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Väter mit größtem Kind tauschen solange dieses größer ist.",
          "id": "7ba019a2553e1137a4bbb8d3c779a48e5ceb2ca3a162e6e0a945ef0f"
        },
        {
          "text": "Es wird geprüft, ob die Wurzel größer als die Kinder ist. Ist dies nicht der Fall, wird mit dem größeren Kind getauscht.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "operation buildHeap fängt bei dem ersten Knoten von hinten das kein blatt ist( dh muss mindestens das linke kind haben welches im array die position 2i+1 hat wenn der knoten den index i hat) und führt die operation heapify. danach wird heapify bei dem knoten davor ausgeführt usw bis man bei der wurzel angelangt ist.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Genau so wie ein Heap reperariert wird. Wenn ein Kind größer als sein Vater ist werden diese getauscht, solange bis das Maximum oben steht.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Aus einem Binärbaum erstellt man einen Heap indem man von dem letzten Element welches kein Blatt ist bis zur Wuzel die Heapbedingung herstellt.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Wir beginnen zunächst mit dem letzten Knoten, der kein Blatt ist und wenden dann heapify auf ihn und alle darüber liegenden Knoten an (rückwärts bis zur Wurzel).",
          "id": "0ce8152aa92136af039b687c01c7dccfcb271f3db2d0ddcb3cfdd3e6"
        },
        {
          "text": "heapify größter wert nach oben",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Heapify (Vergleich mit Kindern) wird auf dem letzten Knoten durchgeführt, der sicher zumindest ein Kind hat und dann auf allen Knoten vor ihm, bis zu der Wurzel.",
          "id": "408f0afbe2440a4383a1e75b7d5b0b4202c7f7131a9acf9bd70492f3"
        },
        {
          "text": "heapify () beginnt beim rechtesten Blatt und vergleicht immer, ob die Wurzel größer ist, als die Kinder, geht also immer eine Ebene höher",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "durch heapify, man fängt bei dem tiefsten Knoten ganz rechts an und tauscht nach und nach aufsteigend die wurzel des teilbaums mit seinen kindern, falls diese größer sind als die wurzel.",
          "id": "c1b8144ee1a30244a571c3d9b48b2c394a7489065d2565968f521645"
        },
        {
          "text": "l,l,",
          "id": "192f56eb9bd894a72b30c303247b107be2c4591f310dd69a67927f48"
        },
        {
          "text": "Mit der Funktion buildHeap()",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Man tauscht bei einem Knoten das größere Kind mit dem Vater, falls es größer als der Vater ist. Das Ganze macht man für jeden Knoten, beginnend mit dem letzten mit Kindern und durchläuft dann alle Ebenen von unten nach oben.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Das Array wird asl Heap interpretiert. Die Kinder eines Knotens n sind links: an Stelle, 2n-1, und rechts bei, 2n-2. Dann muss n mal heapify aufgerufen werden. auf letztem Teilbaum, ...",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Mit der Methode heapify.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Ein Binärbaum ist ein Heap wenn alle seine Teilbäume Heap sind. Also fange ich bei dem Teilbaum in der untersten Ebene an und wende heapify an. Dass mache ich für jeden einzelnen der Teilbäume, bis ich bei der UWRZEL ANGEKOMMEN BIN, wo ich auch wieder heapify anwenden muss",
          "id": "b51d18b551043c1f145f22dbde6f8531faeaf68c54ed9dd79ce24d17"
        },
        {
          "text": "Wir fangen bei dem ersten Knoten, der kein Blatt mehr ist an und überprüfen seine Kinder, wenn nötig wird getauscht, so gehen wir von unten nach oben und von links nach rechts durch den Baum, bis alle Vater größer sind als ihre Kinder",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "der Binärbaum wird befüllt und dann von den Blättern an mittels heapify die Bedingung für jeden knoten erfüllt",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "heapify",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "heapify",
          "id": "ae8820303e493738a211ebb2ae3a2f90b286f20f767609beb77522c0"
        },
        {
          "text": "heapify auf alle Knoten, angefangen von unten, anwenden",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "Man beginnt am letzten Knoten, der kein blatt ist und ruft die Funktion heapify auf. Heapify tauscht das größere Kind mit dem vater, wenn es größer ist als der Vater.",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "Von der vorletzten Ebene aus werden alle Teilbäume zu Heaps gemacht",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Es wird solange getauscht bis jeder Vater größer als eine Kinder ist",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        }
      ]
    },
    {
      "text": "Was ist eine rekursive Operation?",
      "id": 50894,
      "title": "Rekursion",
      "type": "definition",
      "referenceAnswer": {
        "text": "Das ist eine Operation, die sich selbst wieder aufruft.",
        "aspects": [
          {
            "text": "Das ist eine Operation, die sich selbst wieder aufruft",
            "elements": [
              [
                0,
                64
              ]
            ]
          }
        ]
      },
      "answersAnnotation": [
        {
          "text": "eine operation die immer wieder dasselbe tut bis eine bestimmte leich tzu lösende situation eintrifft",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Eine Operation, die sich selbst aufruft und mit anderen Parametern weiter arbeitet.",
          "id": "4cfc3a1811fe40afa401b25ef7fa0379f1f7c1930a04f8755d678474"
        },
        {
          "text": "Eine Operation, die sich in sich selbst aufruft. Irgendwann gelangt sie zum Rekursionsanfang\\/-ende\\/-anker und errechnet rückwärts (rekursiv) den zu berechnenden Wert.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Eine Operation welche sich selbst aufruft.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Eine Operation, die sich selbst aufruft.",
          "id": "7ba019a2553e1137a4bbb8d3c779a48e5ceb2ca3a162e6e0a945ef0f"
        },
        {
          "text": "Eine Rekursive Operation ruft sich selbst wieder auf.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Eine rekursive Operation geht von einem großen Problem schrittweise zu einem kleineren Problem, bis dieses so klein ist, dass es gelöst werden kann. Dabei ruft die Operation sich selber immer wieder auf.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "eine operation die sich selbst aufruft (direkt oder indirekt)",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Eine Operation, die aus einem Rekursionanker besteht und sich selbst als Problemlösen wieder aufruft.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Eine rekursive Operation ist eine Operation die sich selbst in ihr aufruft.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Das ist eine Operation, die sich immer wieder selbst aufruft.",
          "id": "0ce8152aa92136af039b687c01c7dccfcb271f3db2d0ddcb3cfdd3e6"
        },
        {
          "text": "eine rekursive Operation ist eine Operation die sich immer wieder selbst aufruft und nach dem Prinzip divide and conquer ein großes Problem zerlegt und die Teilprobleme dann löst",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Eine Operation die sich selbst aufruft.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "ruft sich selbst immer wieder auf bis bedingung erfüllt",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Eine Operation, die sich selbst aufruft.",
          "id": "408f0afbe2440a4383a1e75b7d5b0b4202c7f7131a9acf9bd70492f3"
        },
        {
          "text": "Operation, die sich selber aufruft",
          "id": "271f93f45e9b4067327ed5c8cd30a034730aaace4382803c3e1d6c2f"
        },
        {
          "text": "Eine Operation, die sich selbst aufruft",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "eine sich selbst aufrufende operation",
          "id": "c1b8144ee1a30244a571c3d9b48b2c394a7489065d2565968f521645"
        },
        {
          "text": "l,l,",
          "id": "192f56eb9bd894a72b30c303247b107be2c4591f310dd69a67927f48"
        },
        {
          "text": "Ein Aufruf einer Methode in einer Methode. Das ganze kann direkt oder indirekt sein.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Eine Operation die sich selbst aufruft.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Eine Operation, die sich selbst aufruft (direkt oder indirekt).",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Eine Operation, die sich direkt oder indirekt selber auruft.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Eine rekursive Operation ist eine Operation, die sich selbst auflöst.",
          "id": "b51d18b551043c1f145f22dbde6f8531faeaf68c54ed9dd79ce24d17"
        },
        {
          "text": "Eine Operation die sich selbst aufruft und dadurch die Aufgaben in zu bewältigende Teile zerteilt",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "eine Operation die sich selbst aufruft",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "Eine Operation die sich selber aufruft",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Eine Operation die sich selbst aufruft.",
          "id": "ae8820303e493738a211ebb2ae3a2f90b286f20f767609beb77522c0"
        },
        {
          "text": "Eine Operation die sich selbst aufruft.",
          "id": "b8607e0369fbf3e33bc0e358f840915d8c085d1496097351913c0122"
        },
        {
          "text": "Eine Operation, die sich selbst aufruft.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "Eine Operation ruft sich selber auf.",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "Eine Operation die sich selbst aufruft",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        }
      ]
    },
    {
      "text": "Was ist die Idee des rekursiven MergeSort Algorithmus?",
      "id": 50895,
      "title": "Idee MergeSort",
      "type": "description",
      "referenceAnswer": {
        "text": "Die Problemgröße wird durch das halbieren der Menge immer wieder zu reduzieren bis das Sortieren der Hälften trivial ist. Alle sortierten Hälften werden dann sortiert wieder zusammengefügt.",
        "aspects": [
          {
            "text": "Die Problemgröße wird durch das halbieren der Menge immer wieder zu reduzieren bis das Sortieren der Hälften trivial ist",
            "elements": [
              [
                0,
                120
              ]
            ]
          },
          {
            "text": "Alle sortierten Hälften werden dann sortiert wieder zusammengefügt",
            "elements": [
              [
                122,
                188
              ]
            ]
          }
        ]
      },
      "answersAnnotation": [
        {
          "text": "die menge wird solange geteilt bis sie fertig sortiert ist",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Das Intervall einer Menge wird halbiert und vergleicht, wenn es bis auf zwei bzw. ein Element immer weiter rekursiv halbiert wurde die Elemente und vertauscht sie, falls nötig. Danach werden die Intervalle (Stapel) wieder zusammengemischt (eigentlich eher wieder aneinandergelegt).",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Devide and Conquer",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Die Operation ruft sich solange selbst auf, bis nur noch 2 Zahlen zu vergleichen sind. Danach gibt sie diese sortiert wieder zurück.",
          "id": "7ba019a2553e1137a4bbb8d3c779a48e5ceb2ca3a162e6e0a945ef0f"
        },
        {
          "text": "Bei MergeSort werden die zu sortierenden Elemente immer wieder in der Hälfte geteilt, bis jeweils nur noch zwei Elemente übrig sind. Diese werden sortiert und mit einem anderen sortierten Stapel vermischt (sodass es insgesamt sortiert ist, nicht irgendwie mischen).",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Duvide and conquer. Ein Array wird so lange aufgeteilt bis es nur 1 element hat. Dann werden 2 sortierte teile des arrays in einem neu angelegten array gemischt dh sortiert und in das ursprüngliche array übertragen.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Die gegebene Menge wird immer wieder aufgeteilt in zwei Mengen und rekursiv selbst weitergegeben. Hat man eine Menge von nur zwei Elementen sortiert man diese und gibt sie zurück.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Das eine Menge immer wieder aufgeteilt wird bis nur noch <= 2 Elemente vorhanden sind, die einfach sortiert werden können. Somit wird die Menge in kleinere Probleme aufgeteilt und sobald diese kleinsten Probleme gelöst sind wieder zusammengefügt.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Die Idee ist Divide and Conquer, dazu wird der zu sortierende Stapel immer wieder in zwei Hälften aufgeteilt und diese jeweils sortiert und sortiert wieder zusammengemischt.",
          "id": "0ce8152aa92136af039b687c01c7dccfcb271f3db2d0ddcb3cfdd3e6"
        },
        {
          "text": "bei Merge Sort wird das Array in Teilarrays unterteilt und dann wieder geteilt und wieder geteilt bis die Elemente einzeln vorliegen. Diese werden dann mit den anderen Teilarrays gemergt und dabei sortiert",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "MergeSort sortiert immer weiter geteilte Stapel erst, wenn diese höchstens zwei Elemente besitzen. Dann werden die einzelnen Elemente zusammengemischt und so sortiert.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "teile und herrsche",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Divide & Conquer. Die Menge wird auf zwei geteilt und rekursiv wieder und wieder, bis jede Teilmenge nur ein Element enthält und dann je nach Größe wieder zusammen geklebt.",
          "id": "408f0afbe2440a4383a1e75b7d5b0b4202c7f7131a9acf9bd70492f3"
        },
        {
          "text": "Divide & conquer Das zu sortierende Array wird solange in zwei Teilarrays aufgeteilt, bis die Teilarrays nur noch aus einem Element bestehen. Daraufhin geht die Rekursion rückwärts und fügt dabei die Teilarrays so zusammen, dass sie sortiert sind. Das geschieht solange, bis das Array vollständig sortiert ist.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "das array rekursiv in arrays der länge 2 oder 1 und diese zu sortieren und dann nach und nach die kurzen arrays mit anderen arrays zusammensortieren",
          "id": "c1b8144ee1a30244a571c3d9b48b2c394a7489065d2565968f521645"
        },
        {
          "text": "ml,l,",
          "id": "192f56eb9bd894a72b30c303247b107be2c4591f310dd69a67927f48"
        },
        {
          "text": "Devide and Conquer",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Ein (Teil-)Array wird so oft halbiert bis es nurnoch aus zwei Elementen besteht, diese werden dann sortiert. Dieses Teilarray wird mit einem anderen gemergt also so zusammengeführt, dass es immernoch sortiert ist. Das macht man dann so oft bis man wieder beim ursprünglichen Array angekommen ist.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Divide and conquer. Ein Problem wird in Teilprobleme aufgeteilt, die delegiert werden (auf denen die sort-operation rekursiv aufgerufen wird). Wenn die Probleme klein genug sind, können sie gelöst werden und die Lösungen können zur Problemlösung kombiniert werden.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Man teilt ein gegebenes Array so lange in der Hälfte, bis es maximal aus 2 Werten besteht, diese kann man leicht sortieren, danach werden die Teilarrays zusammengemischt.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Der Datensatz mit n Elementen wird so häufig halbiert bis jeweils nur noch 1 Element da ist. dann wird er sortiert wieder zusammengefügt",
          "id": "b51d18b551043c1f145f22dbde6f8531faeaf68c54ed9dd79ce24d17"
        },
        {
          "text": "Wir Teilen das was wir bekommen in zwei Teile, die jeweils wieder zerteilt werden, bis nur noch ein einzelnes element übrig ist, dann werden sie wieder zusammen gemischt, so dass immer die obersten elemente Zweier Teile verglichen werden und der Kleinere zu erst auf den Zusammenfügestapel kommt, bis alle Einzelteile wieder zusammengefügt wurden",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Divide and Conquer",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "Divide and Conquer",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Divide and Conquer",
          "id": "ae8820303e493738a211ebb2ae3a2f90b286f20f767609beb77522c0"
        },
        {
          "text": "Der Datensatz wird so lange rekursiv aufgeteilt, bis er nur noch zwei Elemente miteinander vergleichen muss. Anschließend werden die Elemente wieder ebenenweise zusammengefügt.",
          "id": "b8607e0369fbf3e33bc0e358f840915d8c085d1496097351913c0122"
        },
        {
          "text": "Die Menge wird rekursiv immer weiter geteilt, bis nur noch zwei Elemente vorhanden sind. Diese und die zurückgegebenen Mengen werden dann entsprechend wieder sortiert.",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "Die zu sortierende Menge wird immer weiter aufgeteilt, bis nur noch zwei oder weniger Objekte übrig sind, diese werden dann zurückgebeben und mit den anderen zusammengefügt",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Wir brauchen nur einen Vergleich zu programmieren, da wir von Beginn an die zu sortierende Menge teilen und dann für beide Hälften das Sort aufrufen, m Sort dann wieder teilen und für beide Hälften Sort aufrufen. Das passiert so lange, bis die zu sortierende Menge nur noch 2 Elemente hat. die sind ganz leicht zu sortieren. Bein Rückkehren werden die beiden Mengen zusamengemischt und wieder zurückgegeben.",
          "id": "525ab75c928c6fac98a0f62e4da5316b7247ccd704c967ef9142925c"
        },
        {
          "text": "Das zu sortierende Array wird immer weiter verkleinert",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        }
      ]
    },
    {
      "text": "Stellen Sie sich die rekursive Aufteilung der zu sortierenden Menge in einem Binärbaum vor. Erklären sie anhand der Struktur dieses Binärbaumes warum MergeSort in der Laufzeitklasse O(n*log(n)) liegt.",
      "id": 50896,
      "title": "Laufzeitherleitung MergeSort",
      "type": "reason",
      "referenceAnswer": {
        "text": "Auf jeder Ebene des Baumes sind alle n Elemente vorhanden. Beim mischen müssen also auf jeder Ebene insgesamt n Elemente wieder vermischt werden. Der Baum hat maximal log(n) Ebenen. Es müssen also log(n) mal alle n Elemente gemischt werden.",
        "aspects": [
          {
            "text": "Auf jeder Ebene des Baumes sind alle n Elemente vorhanden",
            "elements": [
              [
                0,
                57
              ]
            ]
          },
          {
            "text": "Beim mischen müssen also auf jeder Ebene insgesamt n Elemente wieder vermischt werden",
            "elements": [
              [
                59,
                144
              ]
            ]
          },
          {
            "text": "Der Baum hat maximal log(n) Ebenen",
            "elements": [
              [
                146,
                180
              ]
            ]
          },
          {
            "text": "Es müssen also log(n) mal alle n Elemente gemischt werden",
            "elements": [
              [
                182,
                239
              ]
            ]
          }
        ]
      },
      "answersAnnotation": [
        {
          "text": "jede ebene des binärbaums entspricht einer aufteilung der menge, da der binärbaum n*logn tiefen (max) besitzt kann auch das array nicht öfter geteilt werden",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Auf jeder Ebene des Baumes sind alle n Elemente vorhanden. Beim mischen müssen also auf jeder Ebene insgesamt n Elemente wieder vermischt werden. Der Baum hat maximal log(n) Ebenen. Es müssen also log(n) mal alle n Elemente gemischt werden.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Da sich die Menge an zu sortierenden Elementen mit jedem Schritt halbiert.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "log(n) bezeichnet, wie häufig die Menge aufgeteilt werden muss, bis es auf den Vergliech von 2 Zahlen reduziert ist. n ergibt sich durch das Mischen.",
          "id": "7ba019a2553e1137a4bbb8d3c779a48e5ceb2ca3a162e6e0a945ef0f"
        },
        {
          "text": "Die Datenmenge wird immer wieder durch 2 geteilt, also kann man sich den Ablauf von MergeSort in einem Binärbaum darstellen. Ein Binärbaum hat aber immer log(n) Ebenen. Für die Laufzeit kommt noch das Zurückgeben dazu, also liegt es insgesamt bei einer Laufzeit von O(n*log(n)).",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Weil der binärbaum höchstens log(n)- Mal aufgeteilt werden muss um Mengen zu erreichen, die enifach sortiert werden können.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Der Mergesort halbiert immer die Menge der zu sortierenden Menge. Dies entspricht den beiden Kindern eines Knoten aus einem Baum. Ein Binärbaum besitzt höchstens die Tiefe log(n) und dies kombiniert mit der Anzahl an Elementen ergibt die Laufzeitklasse O(n*log(n)).",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Jeder Knoten des Binärbaums hat wieder maximal 2 Kinder, deshalb hat er die Tiefe log(n) und man muss den Baum höchstens n*log(n) mal durchlaufen.",
          "id": "0ce8152aa92136af039b687c01c7dccfcb271f3db2d0ddcb3cfdd3e6"
        },
        {
          "text": "Tiefe ist maximal log(n) und daher müssen maximal log(n) mal die n Elemente gemischt werden.",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Weil die Tiefe des Baumes log(n) ist und die Vergleiche n.",
          "id": "408f0afbe2440a4383a1e75b7d5b0b4202c7f7131a9acf9bd70492f3"
        },
        {
          "text": "man kann sich den binärbaum rückwärts\\/umgedreht vorstellen, dabei werden die ersten teil arrays gebildet und dann aufsteigend bis zur wurzel die restlichen",
          "id": "c1b8144ee1a30244a571c3d9b48b2c394a7489065d2565968f521645"
        },
        {
          "text": "Die Wurzel stellt die zu sortierende Menge dar, die Kinder die jeweiligen Teilmengen. Da der der Binärbaum eine Tiefe von log (n) hat, hat das Aufteilen der Mengen eine Laufzeit von log (n). Am Ende des MergeSort Algorithmus' wird die zusammengefügte Menge noch ein letztes Mal sortiert, deshalb n * log (n).",
          "id": "9cbcb7142c0ba8e0acabe63fa0665db839f24ed7f11f2b8e2e8f47b6"
        },
        {
          "text": "rrg",
          "id": "192f56eb9bd894a72b30c303247b107be2c4591f310dd69a67927f48"
        },
        {
          "text": "Da das Array immer halbiert wird ähnelt es einem Binärbaum. Da ein Binärbaum die Tiefe log(n) hat, gilt das auch für wie oft wir unser Array aufteilen. Für jeden Vater (davon gibt es log(n)-1) müssen wir jetzt seine beiden Kinder mergen. Da wir immer nur den größeren vorderen Eintrag der beiden Kinder nehmen müssen und wir in der Ebene eines Baumes so viele Einträge haben wie die Einträge im Ursprungsarray (n Einträge) brauchen wir hierfür höchstens n Vergleiche. Da wir das für jede Ebene machen müssen brauchen wir höchstens n*log(n) Vergleiche. Daher O(n*log(n)).",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Die kleinsten Teilmengen befinden sich in der Ebene log(n). Mergesort muss also n mal iterativ diese Ebene erreichen und die Lösungen rekombinieren.",
          "id": "31da1a042dc910775ed8b487afbdafd929a7afdeaadc660cb963bd26"
        },
        {
          "text": "Weil ich n mal den Algorithmus aufrufen. Jedes mal hat eine Laufzeit von log n, da der Binärbaum log n ebenen besitzt",
          "id": "b51d18b551043c1f145f22dbde6f8531faeaf68c54ed9dd79ce24d17"
        },
        {
          "text": "bei jedem Aufruf halbieren wir die zu sortierende Menge, deslhalb O(logn), durch das vergleichen aller Elemente kommt das O(n)",
          "id": "dfd5f9139a820075df69d7895015360b76d0360f3d4b77a845689614"
        },
        {
          "text": "Kann ich nicht",
          "id": "ae8820303e493738a211ebb2ae3a2f90b286f20f767609beb77522c0"
        }
      ]
    }
  ]
}