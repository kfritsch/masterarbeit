<?xml version="1.0" encoding="UTF-8"?>
<test xmlns="urn:vips:test:v1.0" id="test-7230" type="practice"
      start="2018-12-05T12:00:00+01:00"
                end="2018-12-05T12:00:00+01:00"
            >
    <title>
        Quicksort    </title>
    <description>
            </description>
        <exercises>
                            <exercise id="exercise-50557" feedback="true">
            <title>
                Idee von Quicksort    </title>
            <description>
                Was ist die grundsätzliche Idee von Quicksort    </description>
                    <hint>
                    Bitte formulieren Sie ihre Antworten in vollständigen deutschen(!) Sätzen. Wenige kurze Sätze sollten in der Regel ausreichen.
        Nuzten Sie die Remarks Sektion um auf Unklarheiten in der Fragestellung einzugehen        </hint>
                <items>
                <item type="text-area">
                    <answers>
                                        <answer score="1">
                            Die zu sortierende Menge wird rekursiv in große und kleine Element aufgeteilt. Als Vergleichswert dient ein Element der Menge, das Pivotelement.                </answer>
                    </answers>
                                        </item>
            </items>
      </exercise>
                          <exercise id="exercise-50557" feedback="true">
          <title>
              Aufteilen der Liste    </title>
          <description>
              Wie wird jede Teilliste in größere und kleinere Elemente aufgeteilt?    </description>
                  <hint>
                  Bitte formulieren Sie ihre Antworten in vollständigen deutschen(!) Sätzen. Wenige kurze Sätze sollten in der Regel ausreichen.
      Nuzten Sie die Remarks Sektion um auf Unklarheiten in der Fragestellung einzugehen        </hint>
              <items>
              <item type="text-area">
                  <answers>
                                      <answer score="1">
                          Die Liste wird von beiden Seiten mit Inndies durchlaufen. An Elementen die sich auf der falschen Seite des Pivot Elementes befinden wird gewartet bis auf der Gegenseite ebenfalls ein falsches Element zum tauschen gefunden wurde oder die Indices sich kreuzen.                 </answer>
                  </answers>
                                      </item>
          </items>
      </exercise>
                    <exercise id="exercise-50556" feedback="true">
    <title>
        Quicksort vs Mergesort    </title>
    <description>
        Was sind die Vor- und Nachteile von Quicksort gegenüber Mergesort?    </description>
            <hint>
            Bitte formulieren Sie ihre Antworten in vollständigen deutschen(!) Sätzen. Wenige kurze Sätze sollten in der Regel ausreichen.
Nuzten Sie die Remarks Sektion um auf Unklarheiten in der Fragestellung einzugehen        </hint>
        <items>
        <item type="text-area">
            <answers>
                                <answer score="1">
                    Quicksort benötigt im Gegensatz zu Mergesort keinen zusätzlich Speicherplatz von O(n), hat dafür aber im Worst-Case eine Laufzeit von O(n²)               </answer>
            </answers>
                                </item>
    </items>
</exercise>
                    <exercise id="exercise-50557" feedback="true">
    <title>
        Grund für Worst-Case Laufzeit    </title>
    <description>
        Was ist der Grund für die schlechte Worst-Case Laufzeit von Quicksort?    </description>
            <hint>
            Bitte formulieren Sie ihre Antworten in vollständigen deutschen(!) Sätzen. Wenige kurze Sätze sollten in der Regel ausreichen.
Nuzten Sie die Remarks Sektion um auf Unklarheiten in der Fragestellung einzugehen        </hint>
        <items>
        <item type="text-area">
            <answers>
                                <answer score="1">
                    Bei einer zufälligen Wahl des Pivot Elementes kann es passieren, dass das Pivot Element jedes mal das kleinste oder größte Element der Menge ist, wodurch  diese nicht rekursiv halbiert wird sondern jeweils immer nur ein Element abgespalten wird.                </answer>
            </answers>
                                </item>
    </items>
</exercise>
                    <exercise id="exercise-50558" feedback="true">
    <title>
        Optimales Pivotelement    </title>
    <description>
        Welches Element müsste gewählt werden um eine optimale Laufzeit zu garantieren und warum wird dieses Element nicht einfach jedes mal bestimmt?   </description>
            <hint>
            Bitte formulieren Sie ihre Antworten in vollständigen deutschen(!) Sätzen. Wenige kurze Sätze sollten in der Regel ausreichen.
Nuzten Sie die Remarks Sektion um auf Unklarheiten in der Fragestellung einzugehen        </hint>
        <items>
        <item type="text-area">
            <answers>
                                <answer score="1">
                    Optimalerweise wäre des Pivotelement der Median der Menge. Den Median jedesmal zu bestimmen lohnt sic nicht, weil es die Laufzeit im Mittel verschlechtern würde.               </answer>
            </answers>
                                </item>
    </items>
</exercise>
                    <exercise id="exercise-50559" feedback="true">
    <title>
        Minimale Laufzeit von vergleichsbasierten Sortierverfahren   </title>
    <description>
        Beschreiben Sie die grobe Idee des Beweises, warum vergleichsbasierte Sortierverfahren eine minimale Laufzeit von n*log(n) haben.  </description>
            <hint>
            Bitte formulieren Sie ihre Antworten in vollständigen deutschen(!) Sätzen. Wenige kurze Sätze sollten in der Regel ausreichen.
Nuzten Sie die Remarks Sektion um auf Unklarheiten in der Fragestellung einzugehen        </hint>
        <items>
        <item type="text-area">
            <answers>
                                <answer score="1">
                    Sortieren kann als Suche einer bestimmten Permutation der zu sortierenden Menge aufgefasst werden. Jeder Vergleich hat eine Aufspaltung der potentiell möglichen Permutationen zur Folge, bis letztlich nurnoch eine mögliche Permutation übrig bleibt. Stellt man diese Aufspaltungen in einem Binärbaum dar, kann gezeigt werden, dass die Tiefe dieses Baumes mindestens bei n/4*log(n) liegt.               </answer>
            </answers>
                                </item>
    </items>
</exercise>
            </exercises>
</test>
