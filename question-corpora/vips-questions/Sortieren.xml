<?xml version="1.0" encoding="UTF-8"?>
<test xmlns="urn:vips:test:v1.0" id="test-7230" type="practice"
      start="2018-12-05T12:00:00+01:00"
                end="2018-12-05T12:00:00+01:00"
            >
    <title>
        Sortieren    </title>
    <description>
            </description>
        <exercises>
                    <exercise id="exercise-50556" feedback="true">
    <title>
        Grund fürs Sortieren    </title>
    <description>
        Warum macht es Sinn eine Menge zu sortieren?    </description>
            <hint>
            Bitte formulieren Sie ihre Antworten in vollständigen deutschen(!) Sätzen. Wenige kurze Sätze sollten in der Regel ausreichen.
Nuzten Sie die Remarks Sektion um auf Unklarheiten in der Fragestellung einzugehen        </hint>
        <items>
        <item type="text-area">
            <answers>
                                <answer score="1">
                    Das durchsuchen einer sortierten Menge ist deutlich schneller.               </answer>
            </answers>
                                </item>
    </items>
</exercise>
                    <exercise id="exercise-50557" feedback="true">
    <title>
        Idee von SelectionSort    </title>
    <description>
        Was ist die Idee von SelectionSort?    </description>
            <hint>
            Bitte formulieren Sie ihre Antworten in vollständigen deutschen(!) Sätzen. Wenige kurze Sätze sollten in der Regel ausreichen.
Nuzten Sie die Remarks Sektion um auf Unklarheiten in der Fragestellung einzugehen        </hint>
        <items>
        <item type="text-area">
            <answers>
                                <answer score="1">
                    Die Idee ist, iterativ das größte Element aus dem aktuellen Array auszusortieren.                </answer>
            </answers>
                                </item>
    </items>
</exercise>
                    <exercise id="exercise-50558" feedback="true">
    <title>
        Ineffizienz von SelectionSort    </title>
    <description>
        Was macht SelectionSort so ineffizient?   </description>
            <hint>
            Bitte formulieren Sie ihre Antworten in vollständigen deutschen(!) Sätzen. Wenige kurze Sätze sollten in der Regel ausreichen.
Nuzten Sie die Remarks Sektion um auf Unklarheiten in der Fragestellung einzugehen        </hint>
        <items>
        <item type="text-area">
            <answers>
                                <answer score="1">
                    Die für die Bestimmung des größten Elementes gemachten Vergleiche werden nicht wiederverwendet.                 </answer>
            </answers>
                                </item>
    </items>
</exercise>
                    <exercise id="exercise-50559" feedback="true">
    <title>
        Sortieren von Nachbarn    </title>
    <description>
        Was ist die gemeinsame Grundidee von Sortierverfahren die auf Nachbartäuschen basieren?   </description>
            <hint>
            Bitte formulieren Sie ihre Antworten in vollständigen deutschen(!) Sätzen. Wenige kurze Sätze sollten in der Regel ausreichen.
Nuzten Sie die Remarks Sektion um auf Unklarheiten in der Fragestellung einzugehen        </hint>
        <items>
        <item type="text-area">
            <answers>
                                <answer score="1">
                    Die Sortierverfahren beruhen darauf benachbarte Elemente zu vergleichen und  Fehlstellungen zu korrigieren. Das Array wird so lange durchlaufen, bis alle Nachbarn richtig sortiert sind.                 </answer>
            </answers>
                                </item>
    </items>
</exercise>
                    <exercise id="exercise-50560" feedback="true">
    <title>
        BubbleSort     </title>
    <description>
        Warum sind Sortierverfahren die darauf beruhen Fehlstellungen von Nachbarn zu beheben im best-case besser als n*log(n)?
    </description>
            <hint>
            Bitte formulieren Sie ihre Antworten in vollständigen deutschen(!) Sätzen. Wenige kurze Sätze sollten in der Regel ausreichen.
Nuzten Sie die Remarks Sektion um auf Unklarheiten in der Fragestellung einzugehen        </hint>
        <items>
        <item type="text-area">
            <answers>
                                <answer score="1">
                    Bei einem sortierten Array gibt es keine Fehlstellungen. Das Array muss deshalb nur einmal durchlaufen werden.                </answer>
            </answers>
                                </item>
    </items>
</exercise>
                    <exercise id="exercise-50561" feedback="true">
    <title>
        Idee HeapSort     </title>
    <description>
        Was ist die Idee von Heapsort?    </description>
            <hint>
            Bitte formulieren Sie ihre Antworten in vollständigen deutschen(!) Sätzen. Wenige kurze Sätze sollten in der Regel ausreichen.
Nuzten Sie die Remarks Sektion um auf Unklarheiten in der Fragestellung einzugehen        </hint>
        <items>
        <item type="text-area">
            <answers>
                                <answer score="1">
                    Die Elemente werden so in einem Binärbaum arrangiert, dass eine Kante immer einen Vergleich zwischen zwei Elementen darstellt, bei welchem der Vater das größere Element ist. Die so gespeicherten Vergleichsinformationen verschnellern die Suche nach dem größten Element.              </answer>
            </answers>
                                </item>
    </items>
</exercise>
                    <exercise id="exercise-50563" feedback="true">
    <title>
        Eigenschaften eines Heaps    </title>
    <description>
        Welche Eigenschaften eines Heaps sind essentiell für das sortieren?    </description>
            <hint>
            Bitte formulieren Sie ihre Antworten in vollständigen deutschen(!) Sätzen. Wenige kurze Sätze sollten in der Regel ausreichen.
Nuzten Sie die Remarks Sektion um auf Unklarheiten in der Fragestellung einzugehen        </hint>
        <items>
        <item type="text-area">
            <answers>
                                <answer score="1">
                    Der größte Wert aller Knoten in jedem Teilbaum ist in dessen Wurzel. Ein Heap besitzt eine maximale Tiefe von log(n).                </answer>
            </answers>
                                </item>
    </items>
</exercise>
                    <exercise id="exercise-50564" feedback="true">
    <title>
        Struktur eines Heap    </title>
    <description>
        Wie muss ein Binärbaum strukturiert sein um ihn in einer Laufzeit von n*log(n) in einen Heap transformiert werden zu können? Die Binärbäume in den folgenden Aufgaben weisen stets diese Struktur auf.    </description>
            <hint>
            Bitte formulieren Sie ihre Antworten in vollständigen deutschen(!) Sätzen. Wenige kurze Sätze sollten in der Regel ausreichen.
Nuzten Sie die Remarks Sektion um auf Unklarheiten in der Fragestellung einzugehen        </hint>
        <items>
        <item type="text-area">
            <answers>
                                <answer score="1">
                    Alle Ebenen des Baumes, bis auf die letzte, müssen vollständig befüllt sein. Die letzte Ebene muss vom linken Ende bis zum rechtesten Element vollständig befüllt sein.               </answer>
            </answers>
                                </item>
    </items>
</exercise>
                    <exercise id="exercise-50565" feedback="true">
    <title>
        Heap reparieren    </title>
    <description>
        Wie wird aus einem Binärbaum dessen beiden Teilbäume selber Heaps sind ein Heap erstellt? Wieso benötigt diese Operation eine log(n) Schritte?    </description>
            <hint>
            Bitte formulieren Sie ihre Antworten in vollständigen deutschen(!) Sätzen. Wenige kurze Sätze sollten in der Regel ausreichen.
Nuzten Sie die Remarks Sektion um auf Unklarheiten in der Fragestellung einzugehen        </hint>
        <items>
        <item type="text-area">
            <answers>
                                <answer score="1">
                    Das Element in der Wurzel tauscht immer wieder die Position mit dem größeren seiner Kinder, bis es selber wieder ein Blatt ist oder größer ist als beide Kinder. Der Binärbaum besitzt maximal log(n) Ebenen.                </answer>
            </answers>
                                </item>
    </items>
</exercise>
                    <exercise id="exercise-50566" feedback="true">
    <title>
        Heap Initiierung    </title>
    <description>
        Wie wird der initiale Heap aus einem Binärbaum erstellt?    </description>
            <hint>
            Bitte formulieren Sie ihre Antworten in vollständigen deutschen(!) Sätzen. Wenige kurze Sätze sollten in der Regel ausreichen.
Nuzten Sie die Remarks Sektion um auf Unklarheiten in der Fragestellung einzugehen        </hint>
        <items>
        <item type="text-area">
            <answers>
                                <answer score="1">
                    Es wird in der vorletzten Ebene angefangen und in den Ebenen aufsteigend aus jedem Teilbaum des Binärbaumes ein Heap erstellt. Alle Blätter des Binärbaumes sind bereits Heaps und können daher ausgelassen werden.                </answer>
            </answers>
                                </item>
    </items>
</exercise>
<exercise id="exercise-50566" feedback="true">
<title>
Rekursion    </title>
<description>
Was ist eine rekursive Operation?    </description>
<hint>
Bitte formulieren Sie ihre Antworten in vollständigen deutschen(!) Sätzen. Wenige kurze Sätze sollten in der Regel ausreichen.
Nuzten Sie die Remarks Sektion um auf Unklarheiten in der Fragestellung einzugehen        </hint>
<items>
<item type="text-area">
<answers>
            <answer score="1">
Das ist eine Operation, die sich selbst wieder aufruft.                </answer>
</answers>
            </item>
</items>
</exercise>
<exercise id="exercise-50566" feedback="true">
<title>
Idee MergeSort   </title>
<description>
Was ist die Idee des rekursiven MergeSort Algorithmus?    </description>
<hint>
Bitte formulieren Sie ihre Antworten in vollständigen deutschen(!) Sätzen. Wenige kurze Sätze sollten in der Regel ausreichen.
Nuzten Sie die Remarks Sektion um auf Unklarheiten in der Fragestellung einzugehen        </hint>
<items>
<item type="text-area">
<answers>
            <answer score="1">
Der Mergesort Algorithmus halbiert die zu sortierende Menge, sofern die Menge mehr als zwei Elemente enthält. Anschließend ruft er sich selbst an beiden Teilmenge auf, bevor er die sortierten Ergebnisse dann zusammenfügt. Eine Menge von 2 oder weniger Elementen wird einfach sortiert zurückgegeben.                </answer>
</answers>
            </item>
</items>
</exercise>
<exercise id="exercise-50566" feedback="true">
<title>
Laufzeitherleitung MergeSort    </title>
<description>
Stellen Sie sich die rekursive Aufteilung der zu sortierenden Menge in einem Binärbaum vor. Erklären sie anhand der Struktur dieses Binärbaumes warum MergeSort in der Laufzeitklasse O(n*log(n)) liegt.    </description>
<hint>
Bitte formulieren Sie ihre Antworten in vollständigen deutschen(!) Sätzen. Wenige kurze Sätze sollten in der Regel ausreichen.
Nuzten Sie die Remarks Sektion um auf Unklarheiten in der Fragestellung einzugehen        </hint>
<items>
<item type="text-area">
<answers>
            <answer score="1">
Auf jeder Ebene des Baumes sind alle n Elemente vorhanden. Beim mischen müssen also auf jeder Ebene insgesamt n Elemente wieder vermischt werden. Der Baum hat maximal log(n) Ebenen. Es müssen also log(n) mal alle n Elemente gemischt werden.                </answer>
</answers>
            </item>
</items>
</exercise>
            </exercises>
</test>
